{"text": "<bos>\nChapter 1\nGetting\nOrganized\nChapter 1: Getting Organized\n1.1 – Classes, Objects, and Applications\n1.2 – Organizing Classes\n1.3 – Exceptional Situations\n1.4 – Data Structures\n1.5 – Basic Structuring Mechanisms\n1.6 – Comparing Algorithms: Order of Growth\nAnalysis\n1.1 Classes, Objects,\nand Applications\n• Objects represent\n– information: we say the objects have attributes.\n– behavior: we say the objects have responsibilities.\n• Objects can represent “real-world” entities such\nas bank accounts.\n• Objects are self-contained and therefore easy to\nimplement, modify, test for correctness, and\nreuse.\nClasses and Objects\n• An object is an instantiation of a class.\n• Alternately, a class defines the structure of its\nobjects.\n• A class definition includes variables (data) and\nmethods (actions) that\n<eos>"}
{"text": "<bos>\ndetermine the behavior of\nan object.\n• Example: the Date class (next slide)\npackage ch01.dates; public int getMonth()\npublic class Date {\n{ return month;\nprotected int year, month, day; }\npublic static final\nint MINYEAR = 1583; public int getDay()\n{\n// Constructor return day;\npublic Date(int newMonth, }\nint newDay,\nint newYear) public int lilian()\n{ {\nmonth = newMonth; // Returns the Lilian Day Number\nday = newDay; // of this date.\nyear = newYear; // Algorithm goes here.\n} }\n// Observers @Override\npublic int getYear() public String toString()\n{ // Returns this date as a String.\nreturn year; {\n} return(month + \"/\" + day\n+ \"/\" + year);\n}\n}\nJava Access Control Modifiers\nWithin Within\nWithin the Subclasses Subclasses\nEverywhere\nClass in the Same in Other\nPackage Packages\npublic X X X X\n<eos>"}
{"text": "<bos>\nprotected X X X\npackage X X\nprivate X\nThe Unified Method\n• Use-case driven: a description of a sequence of\nactions performed by a user within the system to\naccomplish some task\n• Iterative and incremental: involves a series of\ndevelopment cycles\n• Architecture-centric: diagrams indicate the\noverall structure of the system, the way in which\nits components interact\nClass Diagram for Date Class\nObjects\nDate myDate = new Date(6, 24, 1951);\nDate yourDate = new Date(10, 11, 1953);\nDate ourDate = new Date(6, 15, 1985);\nApplications\n• An object-oriented application is a set of objects\nworking together, by sending each other\nmessages, to solve a problem.\n• In object-oriented programming a key step is\nidentifying classes that can be used to help\nsolve a problem.\n• An example – using our Date class\n<eos>"}
{"text": "<bos>\nto solve the\nproblem of calculating the number of days\nbetween two dates (next 3 slides)\nDaysBetween Design\ndisplay instructions\nprompt for and read in info about the first date\ncreate the date1 object\nprompt for and read in info about the second date\ncreate the date2 object\nif dates entered are too early\nprint an error message\nelse\nuse the date.lilian method to obtain the\nLilian Day Numbers\ncompute and print the number of days\nbetween the dates\n//----------------------------------------------------------------------\n// DaysBetween.java by Dale/Joyce/Weems Chapter 1\n//\n// Asks the user to enter two \"modern\" dates and then reports\n// the number of days between the two dates.\n//----------------------------------------------------------------------\npackage ch01.apps;\nimport java.util.Scanner;\n<eos>"}
{"text": "<bos>\npublic class DaysBetween\n{\npublic static void main(String[] args)\n{\nScanner scan = new Scanner(System.in);\nint day, month, year;\nSystem.out.println(\"Enter two 'modern' dates: month day year\");\nSystem.out.println(\"For example January 12, 1954 would be: 1 12 1954\");\nSystem.out.println();\nSystem.out.println(\"Modern dates occur after \" + Date.MINYEAR + \".\");\nSystem.out.println();\nSystem.out.println(\"Enter the first date:\");\nmonth = scan.nextInt();\nday = scan.nextInt();\nyear = scan.nextInt();\nDate d1 = new Date(month, day, year);\nSystem.out.println(\"Enter the second date:\");\nmonth = scan.nextInt();\nday = scan.nextInt();\nyear = scan.nextInt();\nDate d2 = new Date(month, day, year);\nif ((d1.getYear() <= Date.MINYEAR)\n||\n(d2.getYear() <= Date.MINYEAR))\nSystem.out.println(\"You entered a 'pre-modern'\n<eos>"}
{"text": "<bos>\ndate.\");\nelse\n{\nSystem.out.println(\"The number of days between\");\nSystem.out.print(d1);\nSystem.out.print(\" and \");\nSystem.out.print(d2);\nSystem.out.print(\" is \");\nSystem.out.println(Math.abs(d1.lilian() - d2.lilian()));\n}\n}\n}\n1.2 Organizing Classes\n• During object-oriented development hundreds of\nclasses can be generated or reused to help build\na system.\n• The task of keeping track of these classes would\nbe impossible without organizational structure.\n• Two of the most important ways of organizing\nJava classes are\n– inheritance: classes are organized in an “is-a”\nhierarchy\n– packages: let us group related classes together into a\nsingle named unit\nInheritance\n• Allows programmers\nto create a new class\nthat is a specialization\nof an existing class.\n• We say that the new\nclass is a subclass\n<eos>"}
{"text": "<bos>\nof\nthe existing class,\nwhich in turn is the\nsuperclass of the new\nclass.\nExample of Inheritance\npackage ch01.dates;\npublic class IncDate extends Date\n{\npublic IncDate(int newMonth, int newDay, int newYear)\n{\nsuper(newMonth, newDay, newYear);\n}\npublic void increment()\n// Increments this IncDate to represent the next day.\n// For example if this = 6/30/2005 then this becomes 7/1/2005.\n{\n// increment algorithm goes here\n}\n}\nDeclaring and Using\nDate and IncDate Objects\nDate myDate = new Date(6, 24, 1951);\nIncDate aDate = new IncDate(1, 11, 2001);\nSystem.out.println(\"mydate day is: \" + myDate.getDay());\nSystem.out.println(\"aDate day is: \" + aDate.getDay());\naDate.increment();\nSystem.out.println(\"the day after is: \" + aDate.getDay());\nSee Extended Class Diagram next slide.\nJava’s Inheritance Tree\n<eos>"}
{"text": "<bos>\n• Java supports single inheritance only.\n• Method calls are resolved by searching up the\ninheritance tree.\n• All Java classes can be traced up to the Object\nclass.\n• We use the @Override notation to indicate the\nredefinition of an inherited method.\nInheritance-Based Polymorphism\n• Polymorphism – an object variable can\nreference objects of different classes at different\ntimes.\n• A variable declared to be of “type” T can hold a\nreference to an object of type T or of any\ndescendant of T.\n• See example, next slide.\n// cutoff is random int between 1 and 100\nObject obj;\nif (cutoff <= 50)\nobj = new String(\"Hello\");\nelse\nobj = new Date(1,1,2015);\nSystem.out.println(obj.toString());\nWhat does the above code print?\nWe cannot predict. The binding of the obj variable to\na class (String or Date) occurs\n<eos>"}
{"text": "<bos>\ndynamically, at run time.\nobj is a polymorphic object.\nPackages\n• Java lets us group related classes together into\na unit called a package. Packages provide\nseveral advantages. They\n– let us organize our files.\n– can be compiled separately and imported into our\nprograms.\n– make it easier for programs to use common class\nfiles.\n– help us avoid naming conflicts (two classes can have\nthe same name if they are in different packages).\nUsing Packages\n• A Java compilation unit can consist of a file with\n– the keyword package followed by an identifier indicating the\nname of the package:\npackage someName;\n– import declarations, to make the contents of other packages\navailable:\nimport java.util.Scanner;\n– one or more declarations of classes; exactly one of these\nclasses must be public\n• The classes\n<eos>"}
{"text": "<bos>\ndefined in the file are members of the\npackage.\n• The imported classes are not members of the package.\n• The name of the file containing the compilation unit must\nmatch the name of the public class within the unit.\nUsing Packages\n• Each Java compilation unit is stored in its own\nfile.\n• The Java system identifies the file using a\ncombination of the package name and the name\nof the public class in the compilation unit.\n• Java restricts us to having a single public class\nin a file so that it can use file names to locate all\npublic classes.\n• Thus, a package with multiple public classes\nmust be implemented with multiple compilation\nunits, each in a separate file.\nUsing Packages\n• In order to access the contents of a package\nfrom within a program, you must import it into\nyour program:\nimport\n<eos>"}
{"text": "<bos>\npackagename.*;\nimport packagename.Classname;\n• The Java package rules are defined to work\nseamlessly with hierarchical file systems:\nimport ch02.stacks.*;\n1.3 Exceptional Situations\n• Exceptional situation Associated with an\nunusual, sometimes unpredictable event,\ndetectable by software or hardware, which\nrequires special processing. The event may or\nmay not be erroneous.\n• For example:\n– a user enters an input value of the wrong type\n– while reading information from a file, the end of the\nfile is reached\n– an impossible operation is requested of an object,\nsuch as an attempt to access information that is not\nyet available\nExceptions with Java\n• The Java exception mechanism has three major\nparts:\n– Defining the exception – usually as a subclass of\nJava's Exception class\n– Generating\n<eos>"}
{"text": "<bos>\n(raising) the exception – by recognizing\nthe exceptional situation and then using Java's throw\nstatement to \"announce\" that the exception has\noccurred\n– Handling the exception – using Java's try – catch\nstatement to discover that an exception has been\nthrown and then take the appropriate action\nExceptions and ADTs\nAn Example\n• We create a new date related class called\nSafeDate that includes a constructor which\nthrows an exception if it is passed an illegal date\n• First, we create our own exception class:\npublic class DateOutOfBoundsException extends Exception\n{\npublic DateOutOfBoundsException()\n{\nsuper();\n}\npublic DateOutOfBoundsException(String message)\n{\nsuper(message);\n}\n}\nHere is an example of a constructor that\nthrows the exception:\npublic SafeDate(int newMonth, int newDay, int\n<eos>"}
{"text": "<bos>\nnewYear)\nthrows DateOutOfBoundsException\n{\nif ((newMonth <= 0) || (newMonth > 12))\nthrow new DateOutOfBoundsException(\"month \" + newMonth + \"out of range\");\nelse\nmonth = newMonth;\nday = newDay;\nif (newYear < MINYEAR)\nthrow new DateOutOfBoundsException(\"year \" + newYear +\n\" is too early\");\nelse\nyear = newYear;\n}\nExample of a program that throws the exception out to interpreter:\npublic class UseSafeDate\n{\npublic static void main(String[] args)\nthrows DateOutOfBoundsException\n{\nSafeDate theDate;\n// Program prompts user for a date\n// M is set equal to user’s month\n// D is set equal to user’s day\n// Y is set equal to user’s year\ntheDate = new SafeDate(M, D, Y);\n// Program continues ...\n}\n}\nThe interpreter will stop the program and\nprint an “exception” message, for example\nException in thread\n<eos>"}
{"text": "<bos>\n\"main\" DateOutOfBoundsException: year 1051 is too early\nat SafeDate.<init>(SafeDate.java:18)\nat UseSafeDate.main(UseSafeDate.java:57)\nAn example of a program that catches and handles the exception:\npublic class UseSafeDate\n{\npublic static void main(String[] args)\n{\nSafeDate theDate;\nboolean DateOK = false;\nwhile (!DateOK)\n{\n// Program prompts user for a date\n// M is set equal to user’s month,\n// D is set equal to user’s day\n// Y is set equal to user’s year\ntry\n{\ntheDate = new SafeDate(M, D, Y);\nDateOK = true;\n}\ncatch(DateOutOfBoundsException DateOBExcept)\n{\noutput.println(DateOBExcept.getMessage());\n}\n}\n// Program continues ...\n}\n}\nGeneral guidelines for using\nexceptions\n• An exception may be handled any place in the software\nhierarchy—from the place in the program module where\nit is first\n<eos>"}
{"text": "<bos>\ndetected through the top level of the program.\n• Unhandled built-in exceptions carry the penalty of\nprogram termination.\n• Where in an application an exception is handled is a\ndesign decision; however, exceptions should always be\nhandled at a level that knows what the exception means.\n• An exception need not be fatal.\n• For non-fatal exceptions, the thread of execution can\ncontinue from various points in the program, but\nexecution should continue from the lowest level that can\nrecover from the exception.\nJava RunTimeException class\n• Exceptions of this class are thrown when a\nstandard run-time program error occurs.\n• Examples of run-time errors are division-by-zero\nand array-index-out-of-bounds.\n• These exceptions can happen in virtually any\nmethod or segment of code, so we are not\n<eos>"}
{"text": "<bos>\nrequired to explicitly handle these exceptions.\n• These exceptions are classified as unchecked\nexceptions.\nError Situations and ADTs\n• When dealing with error situations within our\nADT methods, we have several options:\n– Detect and handle the error within the method itself.\nBest approach if the error can be handled internally.\n– Detect the error within the method, throw an\nexception related to the error and force the calling\nmethod to deal with the exception. If not clear how to\nhandle an error situation, this approach might be best\n… throw it out to a level where it can be handled.\n– Ignore the error situation. With this approach, if the\npreconditions of a method are not met, the method is\nnot responsible for the consequences.\n1.4 Data Structures\n• The way you view and structure the data\n<eos>"}
{"text": "<bos>\nthat\nyour programs manipulate greatly influences\nyour success.\n• A language's set of primitive types (Java's are\nbyte, char, short, int, long, float, double, and\nboolean) are not sufficient, by themselves, for\ndealing with data that have many parts and\ncomplex interrelationships among those parts.\n• Data structures provide this ability.\nImplementation Dependent\nStructures\nArray Linked List\nImplementation Independent\nStructures\nStack\nQueue\nSorted List\nMap\nTree Graph\n1.5 Basic Structuring Mechanisms\n• All programs and data are held in memory.\n• Memory consists of a contiguous sequence of\naddressable words:\n• A variable in our program corresponds to a\nmemory location.\nDirect Addressing …\n• … is when the memory location associated with\nthe variable holds the value of the variable.\n• This\n<eos>"}
{"text": "<bos>\ncorresponds to how primitive variables are\nused in Java:\nIndirect Addressing …\n• … is when the\nmemory location\nassociated with the\nvariable holds the\naddress of the\nlocation that holds\nthe value of the\nvariable.\n• This corresponds to\nhow reference\nvariables (objects)\nare used in Java\nThe Two Basic Structuring\nMechanisms\nThere are two basic structuring mechanisms\nprovided in Java (and many other high level\nlanguages)\nArrays\nReferences\nReferences\n• Are memory addresses (use indirect addressing)\n• Sometimes referred to as links, addresses, or\npointers\n• Java uses the reserved word null to indicate\nan “absence of reference”\n• A variable of a reference (non-primitive) type\nholds the address of the memory location that\nholds the value of the variable, rather than the\nvalue itself.\n• This has\n<eos>"}
{"text": "<bos>\nseveral ramifications …\nStatements\nAssignment\nBe of aliases\naware\nStatements\nComparison\nManagement\nGarbage\n• Garbage The set of currently unreachable\nobjects\n• Garbage collection The process of finding all\nunreachable objects and deallocating their\nstorage space\n• Deallocate To return the storage space for an\nobject to the pool of free memory so that it can\nbe reallocated to new objects\n• Dynamic memory management The\nallocation and deallocation of storage space as\nneeded while an application is executing\nArrays\n• We assume students are already familiar with\narrays. The subsection on pages 38 to 43\nreviews some of the subtle aspects of using\narrays in Java:\n– they are handled “by reference”\n– they must be instantiated\n– initialization lists are supported\n– you can use arrays of objects\n–\n<eos>"}
{"text": "<bos>\nyou can use multi-dimensional arrays\n1.6 Comparing Algorithms:\nOrder of Growth Analysis\n• Alice: “I’m thinking of a number between 1 and\n1,000.”\n• Bob: “Is it 1?”\n• Alice: “No . . . it’s higher.”\n• Bob: “Is it 2?”\n• Alice: “No . . . it’s higher.”\n• Bob: “Is it 3?”\n• Alice: rolls her eyes . . .\nAlgorithms\n• A sequence of unambiguous instructions that\nsolve a problem, within a finite amount of time,\ngiven a set of valid input\n• Analysis of algorithms is important area of\ncomputer science\n• The efficiency of algorithms and the code that\nimplements them can be studied in terms of both\ntime (how fast it runs) and space (the amount of\nmemory required).\ntime and space can be\ninter-related\nCounting Operations\n• To measure the complexity of an algorithm we\nattempt to count the number of basic\n<eos>"}
{"text": "<bos>\noperations\nrequired to complete the algorithm\n• Rather than count all operations, select a\nfundamental operation, an operation that is\nperformed “the most”, and count it.\nCounting Operations Example\nProblem: guess secret • Number of operations:\nnumber between 1 and\n– Depends on how “lucky” you\n1,000 (the Hi-Lo game) are\nHi-Lo Sequential Search:\nSet guess to 0\ndo\nIncrement guess by 1\nAnnounce guess\nwhile (guess is not\ncorrect)\nThree Complexity Cases\n• Best case complexity Related to the minimum number\nof steps required by an algorithm, given an ideal set of\ninput values in terms of efficiency\n• Average case complexity Related to the average\nnumber of steps required by an algorithm, calculated\nacross all possible sets of input values\n• Worst case complexity Related to the maximum\nnumber of\n<eos>"}
{"text": "<bos>\nsteps required by an algorithm, given the\nworst possible set of input values in terms of efficiency\n• To simplify analysis yet still provide a useful approach,\nwe usually use worst case complexity\nCounting Operations Example\nProblem: guess secret • Number of operations\nnumber between 1 and worst case is:\n1,000 (the Hi-Lo game)\n– 1 to set guess\n– 1000 increments\nHi-Lo Sequential Search: – 1000 announces\nSet guess to 0 – 1000 tests for correctness\ndo – Total: 3001 ….. but\nIncrement guess by 1\n• This is too dependent on\nAnnounce guess\n– counting approach\nwhile (guess is not\n– language\ncorrect)\n– language level\n– compiler\n• and is difficult for more\ncomplex algorithms\nIsolate a fundamental operation\n• Rather than count all operations, select a\nfundamental operation, an operation that is\n<eos>"}
{"text": "<bos>\nperformed “the most”, and count it.\n• For the “guess the number” problem a basic\noperation might be “announce guess” …\n– count is 1,000\n• But what if problem size changes:\n– “I’m thinking of a number between 1 and 1 million!”\nSize of Input\n• To make our count generally useable we\nexpress it as a function of the size of the\nproblem\n• “I’m thinking of number between 1 and N”\n– Sequential Search: N “announces”\n– Binary Search (cut search area in half at each step):\nlog N “announces”\n2\nA further simplification:\nOrder of Growth Notation\n• We measure the complexity of an algorithm as the\nnumber of times a fundamental operation is performed,\nrepresented as a function of the size of the problem.\n• For example, an algorithm performed on an N element\narray may require 2N2 + 4N + 3 comparisons.\n•\n<eos>"}
{"text": "<bos>\nOrder of growth notation expresses computing time\n(complexity) as the term in the function that increases\nmost rapidly relative to the size of a problem.\n• In our example, rather than saying the complexity is 2N2\n+ 4N + 3 we say it is O(N2).\n• This works just as well for most purposes and simplifies\nthe analysis and use of the complexity measure.\nSelection Sort\n• If we were handed a list of names on a sheet of\npaper and asked to put them in alphabetical\norder, we might use this general approach:\n– Select the name that comes first in alphabetical order,\nand write it on a second sheet of paper.\n– Cross the name out on the original sheet.\n– Repeat steps 1 and 2 for the second name, the third\nname, and so on until all the names on the original\nsheet have been crossed out and written onto the\n<eos>"}
{"text": "<bos>\nsecond sheet, at which point the list on the second\nsheet is sorted.\nAn improvement\n• Our algorithm is simple but it has one drawback:\nIt requires space to store two complete lists.\n• Instead of writing the “first” name onto a\nseparate sheet of paper, exchange it with the\nname in the first location on the original sheet.\nAnd so on.\nSelection Sort Algorithm\nSelectionSort\nfor current going from 0 to SIZE - 2\nFind the index in the array of the smallest unsorted element\nSwap the current element with the smallest unsorted one\nAn example is depicted on the following slide …\nSelection Sort Snapshot\nSelection Sort Code\nstatic int minIndex(int startIndex, int endIndex)\n// Returns the index of the smallest value in\n// values[startIndex]..values[endIndex].\n{\nint indexOfMin = startIndex;\nfor (int\n<eos>"}
{"text": "<bos>\nindex = startIndex + 1; index <= endIndex; index++)\nif (values[index] < values[indexOfMin])\nindexOfMin = index;\nreturn indexOfMin;\n}\nstatic void selectionSort()\n// Sorts the values array using the selection sort algorithm.\n{\nint endIndex = SIZE – 1;\nfor (int current = 0; current < endIndex; current++)\nswap(current, minIndex(current, endIndex));\n}\nSelection Sort Analysis\n• We describe the number of comparisons as a function of\nthe number of elements in the array, i.e., SIZE. To be\nconcise, in this discussion we refer to SIZE as N\n• The minIndex method is called N - 1 times\n• Within minIndex, the number of comparisons varies:\n– in the first call there are N - 1 comparisons\n– in the next call there are N - 2 comparisons\n– and so on, until in the last call, when there is only 1 comparison\n•\n<eos>"}
{"text": "<bos>\nThe total number of comparisons is\n(N – 1) + (N – 2) + (N – 3) + ... + 1\n= N(N – 1)/2 = 1/2N2 – 1/2N\n• The Selection Sort algorithm is O(N2)\nCommon Orders of Magnitude\n• O(1) is called bounded time. The amount of work is not\ndependent on the size of the problem.\n• O(log N) is called logarithmic time. Algorithms that\n2\nsuccessively cut the amount of data to be processed in\nhalf at each step typically fall into this category.\n• O(N) is called linear time. Adding together the elements\nof an array is O(N).\n• O(N log N) is called N log N time. Good sorting\n2\nalgorithms, such as Quicksort, Heapsort, and Mergesort\npresented in Chapter 11, have N log N complexity.\n• O(N2) is called quadratic time. Some simple sorting\nalgorithms such as Selection Sort are O(N2) algorithms.\n• O(2N) is called\n<eos>"}
{"text": "<bos>\nexponential time. These algorithms are\nextremely costly.\nComparison of Growth Rates\nN log N Nlog N N2 N3 2N\n2 2\n1 0 1 1 1 2\n2 1 2 4 8 4\n4 2 8 16 64 16\n16 4 64 256 4,096 65,536\n64 6 384 4,096 262,144 requires\n20 digits\n128 7 896 16,384 2,097,152 requires\n39 digits\n256 8 2,048 65,536 16,777,216 requires\n78 digits\nWays to simplify analysis of\nalgorithms\n• Consider worst case only\n– but average case can also be important\n• Count a fundamental operation\n– careful; make sure it is the most used operation within\nthe algorithm\n• Use Order of Growth complexity\n– especially when interested in “large” problems\n<eos>"}
{"text": "<bos>\nChapter 10\nThe Graph\nADT\nChapter 10:\nThe Graph ADT\n10.1 – Introduction to Graphs\n10.2 – The Graph Interface\n10.3 – Implementations of Graphs\n10.4 – Application: Graph Traversals\n10.5 – Application: The Single-Source Shortest-Paths\nProblem\n10.1 Introduction to Graphs\nDefinitions\n• Graph: A data structure that consists of a set of\nvertices and a set of edges that relate the\nvertices to each other\n• Vertex: A node in a graph\n• Edge (arc): A pair of vertices representing a\nconnection between the two vertices in a graph\n• Undirected graph: A graph in which the edges\nhave no direction\n• Directed graph (digraph): A graph in which\neach edge is directed from one vertex to another\n(or the same) vertex\nFormally\n• a graph G is defined as follows:\nG = (V,E)\nwhere\nV(G) is a finite, nonempty set of\n<eos>"}
{"text": "<bos>\nvertices\nE(G) is a set of edges (written as pairs\nof vertices)\nMore Definitions\n• Adjacent vertices: Two vertices in a graph that\nare connected by an edge\n• Path: A sequence of vertices that connects two\nvertices in a graph\n• Complete graph: A graph in which every vertex\nis directly connected to every other vertex\n• Weighted graph: A graph in which each edge\ncarries a value\nTwo complete graphs\nA weighted graph\n10.2 The Graph Interface\n• What kind of questions might we ask\nabout a graph?\n– Does a path exist between vertex A and\nvertex D? Can we fly from Atlanta to\nDetroit?\n– What is the total weight along this path\nfrom A to D? How much does it cost to fly\nfrom Atlanta to Detroit? What is the total\ndistance?\n– What is the shortest path from A to D?\nWhat is the cheapest way to get from\n<eos>"}
{"text": "<bos>\nAtlanta to Detroit?\n– If I start at vertex A, where can I go?\nWhat cities are accessible if I start in\nAtlanta?\n– How many connected components are in\nthe graph? What groups of cities are\nconnected to each other?\nGraph Operations\n• What kind of operations are defined on a\ngraph?\n– We specify and implement a small set of\nuseful graph operations\n– Many other operations on graphs can be\ndefined; we have chosen operations that are\nuseful when building applications to answer\ntypical questions, such as those found on the\nprevious slide\nWeightedGraphInterface.java part I\n//----------------------------------------------------------------------------\n// WeightedGraphInterface.java by Dale/Joyce/Weems Chapter 10\n//\n// Interface for classes that implement a directed graph with weighted edges.\n//\n<eos>"}
{"text": "<bos>\nVertices are objects of class T and can be marked as having been visited.\n// Edge weights are integers.\n// Equivalence of vertices is determined by the vertices' equals method.\n//\n// General precondition: except for the addVertex and hasVertex methods,\n// any vertex passed as an argument to a method is in this graph.\n//----------------------------------------------------------------------------\npackage ch10.graphs;\nimport ch04.queues.*;\npublic interface WeightedGraphInterface<T>\n{\nboolean isEmpty();\n// Returns true if this graph is empty; otherwise, returns false.\nboolean isFull();\n// Returns true if this graph is full; otherwise, returns false.\nWeightedGraphInterface.java\npart II\nvoid addVertex(T vertex);\n// Preconditions: This graph is not full.\n// vertex is not already in this graph.\n//\n<eos>"}
{"text": "<bos>\nvertex is not null.\n//\n// Adds vertex to this graph.\nboolean hasVertex(T vertex);\n// Returns true if this graph contains vertex; otherwise, returns false.\nvoid addEdge(T fromVertex, T toVertex, int weight);\n// Adds an edge with the specified weight from fromVertex to toVertex.\nint weightIs(T fromVertex, T toVertex);\n// If edge from fromVertex to toVertex exists, returns the weight of edge;\n// otherwise, returns a special “null-edge” value.\nWeightedGraphInterface.java\npart III\nUnboundedQueueInterface<T> getToVertices(T vertex);\n// Returns a queue of the vertices that vertex is adjacent to.\nvoid clearMarks();\n// Unmarks all vertices.\nvoid markVertex(T vertex);\n// Marks vertex.\nboolean isMarked(T vertex);\n// Returns true if vertex is marked; otherwise, returns false.\nT getUnmarked();\n//\n<eos>"}
{"text": "<bos>\nReturns an unmarked vertex if any exist; otherwise, returns null.\n}\n10.3 Implementations of Graphs\n• In this section we introduce two graph\nimplementation approaches\n– an array based approach\n– a linked approach\nArray-Based Implementation\n• Adjacency matrix For a graph with N nodes,\nan N by N table that shows the existence (and\nweights) of all edges in the graph\n• With this approach a graph consists of\n– an integer variable numVertices\n– a one-dimensional array vertices\n– a two-dimensional array edges (the adjacency\nmatrix)\nA repeat of the abstract model\nThe array-based implementation\nWeightedGraph.java\ninstance variables\npackage ch10.graphs;\nimport ch04.queues.*;\npublic class WeightedGraph<T> implements WeightedGraphInterface<T>\n{\npublic static final int NULL_EDGE = 0;\nprivate static\n<eos>"}
{"text": "<bos>\nfinal int DEFCAP = 50; // default capacity\nprivate int numVertices;\nprivate int maxVertices;\nprivate T[] vertices;\nprivate int[][] edges;\nprivate boolean[] marks; // marks[i] is mark for vertices[i]\n. . .\nWeightedGraph.java\nConstructors\npublic WeightedGraph()\n// Instantiates a graph with capacity DEFCAP vertices.\n{\nnumVertices = 0;\nmaxVertices = DEFCAP;\nvertices = (T[ ]) new Object[DEFCAP];\nmarks = new boolean[DEFCAP];\nedges = new int[DEFCAP][DEFCAP];\n}\npublic WeightedGraph(int maxV)\n// Instantiates a graph with capacity maxV.\n{\nnumVertices = 0;\nmaxVertices = maxV;\nvertices = (T[ ]) new Object[maxV];\nmarks = new boolean[maxV];\nedges = new int[maxV][maxV];\n}\n...\nAdding a vertex\npublic void addVertex(T vertex)\n// Preconditions: This graph is not full.\n// Vertex is not already in this graph.\n<eos>"}
{"text": "<bos>\n// Vertex is not null.\n//\n// Adds vertex to this graph.\n{\nvertices[numVertices] = vertex;\nfor (int index = 0; index < numVertices; index++)\n{\nedges[numVertices][index] = NULL_EDGE;\nedges[index][numVertices] = NULL_EDGE;\n}\nnumVertices++;\n}\nTextbook also includes code for indexIs, addEdge,\nweightIs, and getToVertices.\nCoding the remaining methods is left as an exercise.\nLinked Implementation\n• Adjacency list A linked list that identifies all the\nvertices to which a particular vertex is\nconnected; each vertex has its own adjacency\nlist\n• We look at two alternate approaches:\n– use an array of vertices that each contain a reference\nto a linked list of nodes\n– use a linked list of vertices that each contain a\nreference to a linked list of nodes\nA repeat of the abstract model\nThe first link-based\n<eos>"}
{"text": "<bos>\nimplementation\nThe second link-based implementation\n10.4 Application: Graph Traversals\n• Our graph specification does not include\ntraversal operations.\n• We treat traversal as a graph application rather\nthan an innate operation.\n• The basic operations given in our specification\nallow us to implement different traversals\nindependent of how the graph itself is actually\nimplemented.\n• The application UseGraph in the ch10.apps\npackage contains the code for all the algorithms\npresented in Sections 10.4 and 10.5\nGraph Traversal\n• As we did for general trees, we look at two types\nof graph traversal:\n– The strategy of going as far as we can and then\nbacktracking is called a depth-first strategy.\n– The strategy of fanning out “level by level” is called a\nbreadth-first strategy.\n• We discuss\n<eos>"}
{"text": "<bos>\nalgorithms for employing both\nstrategies within the context of determining if two\ncities are connected in our airline example.\nCan we get from Austin to\nWashington?\nAlgorithm:\nIsPathDF (startVertex, endVertex): returns boolean\nSet found to false\nClear all marks\nMark the startVertex\nPush the startVertex onto the stack\ndo\nSet current vertex = stack.top()\nstack.pop()\nif current vertex equals endVertex\nSet found to true\nelse\nfor each adjacent vertex\nif adjacent vertex is not marked\nMark the adjacent vertex and\nPush it onto the stack\nwhile !stack.isEmpty() AND !found\nreturn found\nSet found to false\nClear all marks\nMark the startVertex\nPush the startVertex onto the stack\ndo\nSet current vertex = stack.top()\nstack.pop()\nif current vertex equals endVertex\nSet found to true\nelse\nfor each adjacent\n<eos>"}
{"text": "<bos>\nvertex\nif adjacent vertex is not marked\nMark the adjacent vertex and\nPush it onto the stack\nwhile !stack.isEmpty() AND !found\nreturn found\nBreadth first search – use queue\nIsPathBF (startVertex, endVertex): returns boolean\nSet found to false\nClear all marks\nMark the startVertex\nEnqueue the startVertex into the queue\ndo\nSet current vertex = queue.dequeue()\nif current vertex equals endVertex\nSet found to true\nelse\nfor each adjacent vertex\nif adjacent vertex is not marked\nMark the adjacent vertex and\nEnqueue it into the queue\nwhile !queue.isEmpty() AND !found\nreturn found\nExamples of\nsearch paths\n10.5 Application: The Single-Source\nShortest-Paths Problem\n• An algorithm that displays the shortest path from a\ndesignated starting city to every other city in the graph\n• In our example graph if\n<eos>"}
{"text": "<bos>\nthe starting point is Washington\nwe should get\nLast Vertex Destination Distance\n------------------------------------\nWashington Washington 0\nWashington Atlanta 600\nWashington Dallas 1300\nAtlanta Houston 1400\nDallas Austin 1500\nDallas Denver 2080\nDallas Chicago 2200\nAn erroneous approach\nshortestPaths(graph, startVertex)\ngraph.ClearMarks( )\nCreate flight(startVertex, startVertex, 0)\npq.enqueue(flight) // pq is a priority queue\ndo\nflight = pq.dequeue( )\nif flight.getToVertex() is not marked\nMark flight.getToVertex()\nWrite flight.getFromVertex, flight.getToVertex, flight.getDistance\nflight.setFromVertex(flight.getToVertex())\nSet minDistance to flight.getDistance()\nGet queue vertexQueue of vertices adjacent from flight.getFromVertex()\nwhile more vertices in vertexQueue\nGet next vertex from\n<eos>"}
{"text": "<bos>\nvertexQueue\nif vertex not marked\nflight.setToVertex(vertex)\nflight.setDistance(minDistance + graph.weightIs(flight.getFromVertex(), vertex))\npq.enqueue(flight)\nwhile !pq.isEmpty( )\nNotes\n• The algorithm for the shortest-path traversal is\nsimilar to those we used for the depth-first and\nbreadth-first searches, but there are three major\ndifferences:\n– We use a priority queue rather than a FIFO queue or\nstack\n– We stop only when there are no more cities to\nprocess; there is no destination\n– It is incorrect if we use a reference-based priority\nqueue improperly!\nThe Incorrect Part of the Algorithm\nwhile more vertices in vertexQueue\nGet next vertex from vertexQueue\nif vertex not marked\nflight.setToVertex(vertex)\nflight.setDistance(minDistance + graph.weightIs(flight.getFromVertex(), vertex))\n<eos>"}
{"text": "<bos>\npq.enqueue(flight)\n• This part of the algorithm walks through the queue of vertices adjacent to\nthe current vertex, and enqueues Flight objects onto the priority queue\npq based on the information.\n• The flight variable is actually a reference to a Flight object.\n• Suppose the queue of adjacent vertices has information in it related to the\ncities Atlanta and Houston.\n• The first time through this loop we insert information related to Atlanta in\nflight and enqueue it in pq.\n• But the next time through the loop we make changes to the Flight\nobject referenced by flight. We are inadvertently reaching into the\npriority queue and changing one of its entries.\nCorrecting the Algorithm\nwhile more vertices in vertexQueue\nGet next vertex from vertexQueue\nif vertex not marked\nSet newDistance to\n<eos>"}
{"text": "<bos>\nminDistance + graph.weightIs(flight.getFromVertex(), vertex)\nCreate newFlight(flight.getFromVertex(), vertex, newDistance)\npq.enqueue(newFlight)\nThe application UseGraph in the ch10.apps package\ncontains the code for all the algorithms presented in\nSections 10.4 and 10.5\nUnreachable Vertices\nWith this new graph we cannot fly from Washington to\nAustin, Chicago, Dallas, or Denver\nTo print unreachable vertices\n• Append the following to the\nshortestPaths method:\nSystem.out.println(\"The unreachable vertices are:\");\nvertex = graph.getUnmarked();\nwhile (vertex != null)\n{\nSystem.out.println(vertex);\ngraph.markVertex(vertex);\nvertex = graph.getUnmarked();\n}\n<eos>"}
{"text": "<bos>\nChapter 11\nSorting and\nSearching\nAlgorithms\nChapter 11:\nSorting and Searching\nAlgorithms\n11.1 – Sorting\n11.2 – Simple Sorts\n11.3 – O(N log N) Sorts\n2\n11.4 – More Sorting Considerations\n11.5 – Searching\n11.1 Sorting\n• Putting an unsorted list of data elements into\norder – sorting - is a very common and useful\noperation\n• We describe efficiency by relating the number of\ncomparisons to the number of elements in the\nlist (N)\nA Test Harness\n• To help us test our sorting algorithms we create an\napplication class called Sorts:\n• The class defines an array values that can hold 50\nintegers and static methods:\n– initValues: Initializes the values array with random numbers\nbetween 0 and 99\n– isSorted: Returns a boolean value indicating whether the\nvalues array is currently sorted\n– swap: swaps the\n<eos>"}
{"text": "<bos>\nintegers between values[index1] and\nvalues[index2], where index1 and index2 are parameters\nof the method\n– printValues: Prints the contents of the values array to the\nSystem.out stream; the output is arranged evenly in ten\ncolumns\nExample of Sorts main method\npublic static void main(String[] args) throws IOException\n{\ninitValues();\nprintValues();\nSystem.out.println(\"values is sorted: \" + isSorted());\nSystem.out.println();\nswap(0, 1); // normally we put sorting algorithm here\nprintValues();\nSystem.out.println(\"values is sorted: \" + isSorted());\nSystem.out.println();\n}\nOutput from Example\nthe values array is:\n20 49 07 50 45 69 20 07 88 02\n89 87 35 98 23 98 61 03 75 48 This part varies\n25 81 97 79 40 78 47 56 24 07 for each sample run\n63 39 52 80 11 63 51 45 25 78\n35 62 72 05 98 83 05 14 30\n<eos>"}
{"text": "<bos>\n23\nvalues is sorted: false\nthe values array is:\n49 20 07 50 45 69 20 07 88 02\n89 87 35 98 23 98 61 03 75 48\nThis does to, of course\n25 81 97 79 40 78 47 56 24 07\n63 39 52 80 11 63 51 45 25 78\n35 62 72 05 98 83 05 14 30 23\nvalues is sorted: false\n11.2 Simple Sorts\n• In this section we present three “simple” sorts\n– Selection Sort\n– Bubble Sort\n– Insertion Sort\n• Properties of these sorts\n– use an unsophisticated brute force approach\n– are not very efficient\n– are easy to understand and to implement\nSelection Sort\n• This algorithm was introduced in Section 1.6,\n\"Comparing Algorithms\"\n• If handed a list of names on a sheet of paper\nand asked to put them in alphabetical order, we\nmight use this general approach:\n– Select the name that comes first in alphabetical order,\nand write it on a second\n<eos>"}
{"text": "<bos>\nsheet of paper.\n– Cross the name out on the original sheet.\n– Repeat steps 1 and 2 for the second name, the third\nname, and so on until all the names on the original\nsheet have been crossed out and written onto the\nsecond sheet.\nAn improvement\n• Our algorithm is simple but it has one drawback:\nIt requires space to store two complete lists.\n• Instead of writing the “first” name onto a\nseparate sheet of paper, exchange it with the\nname in the first location on the original sheet.\nAnd so on.\nSelection Sort Algorithm\nSelectionSort\nfor current going from 0 to SIZE - 2\nFind the index in the array of the smallest unsorted element\nSwap the current element with the smallest unsorted one\nAn example is depicted on the following slide …\nSelection Sort Snapshot\nSelection Sort Code\nstatic int\n<eos>"}
{"text": "<bos>\nminIndex(int startIndex, int endIndex)\n// Returns the index of the smallest value in\n// values[startIndex]..values[endIndex].\n{\nint indexOfMin = startIndex;\nfor (int index = startIndex + 1; index <= endIndex; index++)\nif (values[index] < values[indexOfMin])\nindexOfMin = index;\nreturn indexOfMin;\n}\nstatic void selectionSort()\n// Sorts the values array using the selection sort algorithm.\n{\nint endIndex = SIZE – 1;\nfor (int current = 0; current < endIndex; current++)\nswap(current, minIndex(current, endIndex));\n}\nTesting\nSelection\nThe resultant output:\nSort\nthe values array is:\n92 66 38 17 21 78 10 43 69 19\n17 96 29 19 77 24 47 01 97 91\n13 33 84 93 49 85 09 54 13 06\nThe test harness:\n21 21 93 49 67 42 25 29 05 74\n96 82 26 25 11 74 03 76 29 10\ninitValues();\nprintValues(); values is sorted:\n<eos>"}
{"text": "<bos>\nfalse\nSystem.out.println(\"values is sorted: \"\n+ isSorted()); Selection Sort called\nSystem.out.println(); the values array is:\n01 03 05 06 09 10 10 11 13 13\nselectionSort(); 17 17 19 19 21 21 21 24 25 25\n26 29 29 29 33 38 42 43 47 49\nSystem.out.println(\"Selection Sort called\\n\"); 49 54 66 67 69 74 74 76 77 78\nprintValues(); 82 84 85 91 92 93 93 96 96 97\nSystem.out.println(\"values is sorted: \"\n+ isSorted()); values is sorted: true\nSystem.out.println();\nSelection Sort Analysis\n• We describe the number of comparisons as a function of\nthe number of elements in the array, i.e., SIZE. To be\nconcise, in this discussion we refer to SIZE as N\n• The minIndex method is called N - 1 times\n• Within minIndex, the number of comparisons varies:\n– in the first call there are N - 1 comparisons\n– in the next\n<eos>"}
{"text": "<bos>\ncall there are N - 2 comparisons\n– and so on, until in the last call, when there is only 1 comparison\n• The total number of comparisons is\n(N – 1) + (N – 2) + (N – 3) + ... + 1\n= N(N – 1)/2 = 1/2N2 – 1/2N\n• The Selection Sort algorithm is O(N2)\nNumber of Comparisons Required\nto Sort Arrays of Different Sizes\nUsing Selection Sort\nNumber of Elements Number of Comparisons\n10 45\n20 190\n100 4,950\n1,000 499,500\n10,000 49,995,000\nBubble Sort\n• With this approach the smaller data values “bubble up” to the front of\nthe array …\n• Each iteration puts the smallest unsorted element into its correct\nplace, but it also makes changes in the locations of the other\nelements in the array.\n• The first iteration puts the smallest element in the array into the first\narray position:\n– starting with the last\n<eos>"}
{"text": "<bos>\narray element, we compare successive pairs of\nelements, swapping whenever the bottom element of the pair is smaller\nthan the one above it\n– in this way the smallest element “bubbles up” to the top of the array.\n• The next iteration puts the smallest element in the unsorted part of\nthe array into the second array position, using the same technique\n• The rest of the sorting process continues in the same way\nBubble Sort Algorithm\nBubbleSort\nSet current to the index of first element in the array\nwhile more elements in unsorted part of array\n“Bubble up” the smallest element in the unsorted part,\ncausing intermediate swaps as needed\nShrink the unsorted part of the array by incrementing current\nbubbleUp(startIndex, endIndex)\nfor index going from endIndex DOWNTO startIndex +1\nif values[index] <\n<eos>"}
{"text": "<bos>\nvalues[index - 1]\nSwap the value at index with the value at index - 1\nAn example is depicted on the following slide …\nBubble Sort Snapshot\nBubble Sort Code\nstatic void bubbleUp(int startIndex, int endIndex)\n// Switches adjacent pairs that are out of order\n// between values[startIndex]..values[endIndex]\n// beginning at values[endIndex].\n{\nfor (int index = endIndex; index > startIndex; index--)\nif (values[index] < values[index – 1])\nswap(index, index – 1);\n}\nstatic void bubbleSort()\n// Sorts the values array using the bubble sort algorithm.\n{\nint current = 0;\nwhile (current < SIZE – 1)\n{\nbubbleUp(current, SIZE – 1);\ncurrent++;\n}\n}\nBubble Sort Analysis\n• Analyzing the work required by bubbleSort is\nthe same as for the selection sort algorithm.\n• The comparisons are in bubbleUp, which is\n<eos>"}
{"text": "<bos>\ncalled N – 1 times.\n• There are N – 1 comparisons the first time, N – 2\ncomparisons the second time, and so on.\n• Therefore, bubbleSort and selectionSort\nrequire the same amount of work in terms of the\nnumber of comparisons.\n• The Bubble Sort algorithm is O(N2)\nInsertion Sort\n• In Section 6.4, “Sorted Array-Based List Implementation,” we\ndescribed the Insertion Sort algorithm and how it could be used to\nmaintain a list in sorted order. Here we present essentially the same\nalgorithm.\n• Each successive element in the array to be sorted is inserted into its\nproper place with respect to the other, already sorted elements.\n• As with the previous sorts, we divide our array into a sorted part and\nan unsorted part.\n– Initially, the sorted portion contains only one element: the first element\nin the\n<eos>"}
{"text": "<bos>\narray.\n– Next we take the second element in the array and put it into its correct\nplace in the sorted part; that is, values[0] and values[1] are in order with\nrespect to each other.\n– Next the value in values[2] is put into its proper place, so\nvalues[0]..values[2] are in order with respect to each other.\n– This process continues until all the elements have been sorted.\nInsertion Sort Algorithm\ninsertionSort\nfor count going from 1 through SIZE - 1\ninsertElement(0, count)\nInsertElement(startIndex, endIndex)\nSet finished to false\nSet current to endIndex\nSet moreToSearch to true\nwhile moreToSearch AND NOT finished\nif values[current] < values[current - 1]\nswap(values[current], values[current - 1])\nDecrement current\nSet moreToSearch to (current does not equal startIndex)\nelse\nSet finished to\n<eos>"}
{"text": "<bos>\ntrue\nAn example is depicted on the following slide …\nInsertion Sort Snapshot\nInsertion Sort Code\nstatic void insertElement(int startIndex, int endIndex)\n// Upon completion, values[0]..values[endIndex] are sorted.\n{\nboolean finished = false;\nint current = endIndex;\nboolean moreToSearch = true;\nwhile (moreToSearch && !finished)\n{\nif (values[current] < values[current – 1])\n{\nswap(current, current – 1);\ncurrent--;\nmoreToSearch = (current != startIndex);\n}\nelse\nfinished = true;\n}\n}\nstatic void insertionSort()\n// Sorts the values array using the insertion sort algorithm.\n{\nfor (int count = 1; count < SIZE; count++)\ninsertElement(0, count);\n}\nInsertion Sort Analysis\n• The general case for this algorithm mirrors the\nselectionSort and the bubbleSort, so the\ngeneral case is O(N2) .\n• But\n<eos>"}
{"text": "<bos>\ninsertionSort has a “best” case: The\ndata are already sorted in ascending order\n– insertElement is called N times, but only one\ncomparison is made each time and no swaps are\nnecessary.\n• The maximum number of comparisons is made\nonly when the elements in the array are in\nreverse order.\n11.3 O(N log N) Sorts\n2\n• O(N2) sorts and are very time consuming for\nsorting large arrays.\n• Several sorting methods that work better when N\nis large are presented in this section.\n• The efficiency of these algorithms is achieved at\nthe expense of the simplicity seen in the\nselection, bubble, and insertion sorts.\nThe Merge Sort\n• The sorting algorithms covered in Section 10.2\nare all O(N2).\n• Note that N2 is a lot larger than\n(1/2N)2 + (1/2N)2 = 1/2N2\n• If we can cut the array into two pieces, sort each\n<eos>"}
{"text": "<bos>\nsegment, and then merge the two back together,\nwe should end up sorting the entire array with a\nlot less work.\nRationale for Divide and Conquer\nMerge Sort Algorithm\nmergeSort\nCut the array in half\nSort the left half\nSort the right half\nMerge the two sorted halves into one sorted array\nBecause mergeSort is itself a sorting algorithm, we might as well\nuse it to sort the two halves.\nWe can make mergeSort a recursive method and let it call itself\nto sort each of the two subarrays:\nmergeSort—Recursive\nCut the array in half\nmergeSort the left half\nmergeSort the right half\nMerge the two sorted halves into one sorted array\nMerge Sort Summary\nMethod mergeSort(first, last)\nDefinition: Sorts the array elements in ascending order.\nSize: last - first + 1\nBase Case: If size less than 2, do nothing.\n<eos>"}
{"text": "<bos>\nGeneral Case: Cut the array in half.\nmergeSort the left half.\nmergeSort the right half.\nMerge the sorted halves into one sorted array.\nStrategy\nfor\nmerging\ntwo\nsorted\narrays\nOur actual merge problem\nOur solution\nThe merge algorithm\nmerge (leftFirst, leftLast, rightFirst, rightLast)\n(uses a local array, tempArray)\nSet index to leftFirst\nwhile more elements in left half AND more elements in right half\nif values[leftFirst] < values[rightFirst]\nSet tempArray[index] to values[leftFirst]\nIncrement leftFirst\nelse\nSet tempArray[index] to values[rightFirst]\nIncrement rightFirst\nIncrement index\nCopy any remaining elements from left half to tempArray\nCopy any remaining elements from right half to tempArray\nCopy the sorted elements from tempArray back into values\nThe mergeSort method\nThe code for\n<eos>"}
{"text": "<bos>\nmerge follows the algorithm on the previous slide.\nmerge does most of the work!\nHere is mergeSort:\nstatic void mergeSort(int first, int last)\n// Sorts the values array using the merge sort algorithm.\n{\nif (first < last)\n{\nint middle = (first + last) / 2;\nmergeSort(first, middle);\nmergeSort(middle + 1, last);\nmerge(first, middle, middle + 1, last);\n}\n}\nAnalysing Merge Sort\nAnalyzing Merge Sort\n• The total work needed to divide the array in half, over\nand over again until we reach subarrays of size 1, is\nO(N).\n• It takes O(N) total steps to perform merging at each\n“level” of merging.\n• The number of levels of merging is equal to the number\nof times we can split the original array in half\n– If the original array is size N, we have log N levels. (This is the\n2\nsame as the analysis of the\n<eos>"}
{"text": "<bos>\nbinary search algorithm in Section\n1.6.)\n• Because we have log N levels, and we require O(N)\n2\nsteps at each level, the total cost of the merge operation\nis: O(N log N).\n2\n• Because the splitting phase was only O(N), we conclude\nthat Merge Sort algorithm is O(N log N).\n2\nComparing N2 and N log N\n2\nN log N N2 N log N\n2 2\n32 5 1,024 160\n64 6 4.096 384\n128 7 16,384 896\n256 8 65,536 2,048\n512 9 262,144 4,608\n1024 10 1,048,576 10,240\n2048 11 4,194,304 22,528\n4096 12 16,777,216 49,152\nDrawback of Merge Sort\n• A disadvantage of mergeSort is that it requires\nan auxiliary array that is as large as the original\narray to be sorted.\n• If the array is large and space is a critical factor,\nthis sort may not be an appropriate choice.\n• Next we discuss two O(N log N) sorts that move\n2\nelements around in\n<eos>"}
{"text": "<bos>\nthe original array and do not\nneed an auxiliary array.\nQuick Sort\n• A divide-and-conquer algorithm\n• Inherently recursive\n• At each stage the part of the array being sorted is divided into two\n“piles”, with everything in the left pile less than everything in the right\npile\n• The same approach is used to sort each of the smaller piles (a\nsmaller case).\n• This process goes on until the small piles do not need to be further\ndivided (the base case).\nQuick Sort Summary\nMethod quickSort (first, last)\nDefinition: Sorts the elements in sub array values[first]..values[last].\nSize: last - first + 1\nBase Case: If size less than 2, do nothing.\nGeneral Case: Split the array according to splitting value.\nquickSort the elements <= splitting value.\nquickSort the elements > splitting value.\nThe Quick Sort\n<eos>"}
{"text": "<bos>\nAlgorithm\nquickSort\nif there is more than one element in values[first]..values[last]\nSelect splitVal\nSplit the array so that\nvalues[first]..values[splitPoint – 1] <= splitVal\nvalues[splitPoint] = splitVal\nvalues[splitPoint + 1]..values[last] > splitVal\nquickSort the left sub array\nquickSort the right sub array\nThe algorithm depends on the selection of a “split value”,\ncalled splitVal, that is used to divide the array into two\nsub arrays.\nHow do we select splitVal?\nOne simple solution is to use the value in values[first]\nas the splitting value.\nQuick Sort Steps\nThe quickSort method\nstatic void quickSort(int first, int last)\n{\nif (first < last)\n{\nint splitPoint;\nsplitPoint = split(first, last);\n// values[first]..values[splitPoint – 1] <= splitVal\n// values[splitPoint] = splitVal\n//\n<eos>"}
{"text": "<bos>\nvalues[splitPoint+1]..values[last] > splitVal\nquickSort(first, splitPoint – 1);\nquickSort(splitPoint + 1, last);\n}\n}\nThe split\noperation\nThe code for split\nis on page 650\nAnalyzing Quick Sort\n• On the first call, every element in the array is\ncompared to the dividing value (the “split value”),\nso the work done is O(N).\n• The array is divided into two sub arrays (not\nnecessarily halves)\n• Each of these pieces is then divided in two, and\nso on.\n• If each piece is split approximately in half, there\nare O(log N) levels of splits. At each level, we\n2\nmake O(N) comparisons.\n• So Quick Sort is an O(N log N) algorithm.\n2\nDrawbacks of Quick Sort\n• Quick Sort isn’t always quicker.\n– There are log N levels of splits if each split divides the segment\n2\nof the array approximately in half. As we’ve\n<eos>"}
{"text": "<bos>\nseen, the array\ndivision of Quick Sort is sensitive to the order of the data, that is,\nto the choice of the splitting value.\n– If the splits are very lopsided, and the subsequent recursive calls\nto quickSort also result in lopsided splits, we can end up with a\nsort that is O(N2).\n• What about space requirements?\n– There can be many levels of recursion “saved” on the system\nstack at any time.\n– On average, the algorithm requires O(log N) extra space to hold\n2\nthis information and in the worst case requires O(N) extra space,\nthe same as Merge Sort.\nQuick Sort\n• Despite the drawbacks remember that Quick\nSort is VERY quick for large collections of\nrandom data\nHeap Sort\n• In Chapter 9, we discussed the heap - because\nof its order property, the maximum value of a\nheap is in the root node.\n• The\n<eos>"}
{"text": "<bos>\ngeneral approach of the Heap Sort is as\nfollows:\n– take the root (maximum) element off the heap, and\nput it into its place.\n– reheap the remaining elements. (This puts the next-\nlargest element into the root position.)\n– repeat until there are no more elements.\n• For this to work we must first arrange the original\narray into a heap\nBuilding a\nheap\nbuildHeap\nfor index going from first nonleaf node up to the root node\nreheapDown(values[index], index)\nSee next slide …\nThe changing contents of the array\nThe Sort Nodes algorithm\nSort Nodes\nfor index going from last node up to next-to-root node\nSwap data in root node with values[index]\nreheapDown(values[0], 0, index 2 1)\nThe heapSort method\nstatic void heapSort()\n// Post: The elements in the array values are sorted by key\n{\nint index;\n// Convert\n<eos>"}
{"text": "<bos>\nthe array of values into a heap\nfor (index = SIZE/2 – 1; index >= 0; index--)\nreheapDown(values[index], index, SIZE – 1);\n// Sort the array\nfor (index = SIZE – 1; index >=1; index--)\n{\nswap(0, index);\nreheapDown(values[0], 0, index – 1);\n}\n}\nAnalysis of Heap Sort\n• Consider the sorting loop\n– it loops through N ─ 1 times, swapping elements and reheaping\n– the comparisons occur in reheapDown (actually in its helper\nmethod newHole)\n– a complete binary tree with N nodes has O(log (N + 1)) levels\n2\n– in the worst cases, then, if the root element had to be bumped\ndown to a leaf position, the reheapDown method would make\nO(log N) comparisons.\n2\n– so method reheapDown is O(log2N)\n– multiplying this activity by the N ─ 1 iterations shows that the\nsorting loop is O(N log N).\n2\n• Combining the\n<eos>"}
{"text": "<bos>\noriginal heap build, which is O(N), and\nthe sorting loop, we can see that Heap Sort requires O(N\nlog N) comparisons.\n2\nThe Heap Sort\n• For small arrays, heapSort is not very efficient\nbecause of all the “overhead.”\n• For large arrays, however, heapSort is very\nefficient.\n• Unlike Quick Sort, Heap Sort’s efficiency is not\naffected by the initial order of the elements.\n• Heap Sort is also efficient in terms of space – it\nonly requires constant extra space.\n• Heap Sort is an elegant, fast, robust, space\nefficient algorithm!\nComparison of Sorting\nAlgorithms\n11.4 More Sorting Considerations\n• In this section we wrap up our coverage of\nsorting by\n– revisiting testing\n– revisiting efficiency\n– discussing special concerns involved with\nsorting objects rather than primitive types\n– considering the\n<eos>"}
{"text": "<bos>\n“stability” of sorting algorithms\nTesting\n• To thoroughly test our sorting methods we\nshould\n– vary the size of the array\n– vary the original order of the array\n• Random order\n• Reverse order\n• Almost sorted\n• All identical elements\nEfficiency\n• When N is small the simple sorts may be more\nefficient than the “fast” sorts because they\nrequire less overhead.\n• Sometimes it may be desirable, for efficiency\nconsiderations, to streamline the code as much\nas possible, even at the expense of readability.\nFor instance, instead of using a swap method\ndirectly code the swap operation within the\nsorting method.\nSpecial Concerns when Sorting\nObjects\n• When sorting an array of objects we are\nmanipulating references to the object, and not\nthe objects themselves\nStability of a Sorting Algorithm\n• Stable\n<eos>"}
{"text": "<bos>\nSort: A sorting algorithm that preserves\nthe order of duplicates\n• Of the sorts that we have discussed in this book,\nonly heapSort and quickSort are inherently\nunstable\n11.5 Searching\n• This section reviews material scattered\nthroughout the text related to searching.\n• Here we bring these topics together to be\nconsidered in relationship to each other to gain\nan overall perspective.\n• Searching is a crucially important information\nprocessing activity. Options are closely related\nto the way data is structured and organized.\nSequential Searching\n• If we want to add elements as quickly as possible to a\ncollection, and we are not as concerned about how long\nit takes to find them we would put the element\n– into the last slot in an array-based collection\n– into the first slot in a linked\n<eos>"}
{"text": "<bos>\ncollection\n• To search this collection for the element with a given\nkey, we must use a simple linear (or sequential) search\n– Beginning with the first element in the collection, we search for\nthe desired element by examining each subsequent element’s\nkey until either the search is successful or the collection is\nexhausted.\n– Based on the number of comparisons this search is O(N)\n– In the worst case we have to make N key comparisons.\n– On the average, assuming that there is an equal probability of\nsearching for any element in the collection, we make N/2\ncomparisons for a successful search\nOrdering\nHigh-Probability\n• Sometimes certain collection elements are in much\ngreater demand than others. We can then improve the\nsearch:\n– Put the most-often-desired elements at the beginning of the\n<eos>"}
{"text": "<bos>\ncollection\n– Using this scheme, we are more likely to make a hit in the first\nfew tries, and rarely do we have to search the whole collection.\n• If the elements in the collection are not static or if we\ncannot predict their relative demand, we can\n– move each element accessed to the front of the collection\n– as an element is found, it is swapped with the element that\nprecedes it\n• collections in which the relative positions of the elements\nare changed in an attempt to improve search efficiency\nare called self-organizing or self-adjusting collections.\nSorted collections\n• If the collection is sorted, a sequential search no longer needs to\nsearch the whole collection to discover that an element does not\nexist. It only needs to search until it has passed the element’s logical\nplace in the\n<eos>"}
{"text": "<bos>\ncollection—that is, until an element with a larger key\nvalue is encountered.\n• Another advantage of linear searching is its simplicity.\n• The binary search is usually faster, however, it is not guaranteed to\nbe faster for searching very small collections.\n• As the number of elements increases, however, the disparity\nbetween the linear search and the binary search grows very quickly.\n• The binary search is appropriate only for collection elements stored\nin a sequential array-based representation.\n• However, the binary search tree allows us to perform a binary\nsearch on a linked data representation\nHashing\n• We end our discussion of search\nalgorithms by pointing out that the hash\ntable approach to storage presented in\nSections 4 through 6 of Chapter 8 allows\nconstant search time in many\n<eos>"}
{"text": "<bos>\nsituations.\n<eos>"}
{"text": "<bos>\nChapter 2\nThe Stack\nADT\nChapter 2: The Stack ADT\n2.1 – Abstraction\n2.2 – The Stack\n2.3 – Collection Elements\n2.4 – The Stack Interface\n2.5 – Array-Based Stack Implementations\n2.6 – Application: Balanced Expressions\n2.7 – Introduction to Linked Lists\n2.8 – A Link-Based Stack\n2.9 – Application: Postfix Expression Evaluator\n2.10 – Stack Variations\n2.1 Abstraction\n• Abstraction A model of a system that includes\nonly the details essential to the perspective of\nthe viewer of the system\n• Information hiding The practice of hiding\ndetails within a module with the goal of\ncontrolling access to the details from the rest of\nthe system\n• Data abstraction The separation of a data\ntype’s logical properties from its implementation\n• Abstract data type (ADT) A data type whose\nproperties (domain and\n<eos>"}
{"text": "<bos>\noperations) are specified\nindependently of any particular implementation\nADT Perspectives or Levels\n• Application (or user or client or external) level: We use\nthe ADT to solve a problem. When working at this level\nwe only need to know how to create instances of the\nADT and invoke its operations.\n• Abstract (or logical) level: Provides an abstract view of\nthe data values (the domain) and the set of operations to\nmanipulate them. At this level, we deal with the “what”\nquestions. What is the ADT? What does it model? What\nare its responsibilities? What is its interface?\n• Implementation (or concrete or internal) level: Provides a\nspecific representation of the structure to hold the data\nand the implementation of the operations. Here we deal\nwith the “how” questions.\nPreconditions and\n<eos>"}
{"text": "<bos>\nPostconditions\n• Preconditions Assumptions that must be true\non entry into a method for it to work correctly\n• Postconditions or Effects The results\nexpected at the exit of a method, assuming that\nthe preconditions are true\n• We specify pre- and postconditions for a method\nin a comment at the beginning of the method\nJava: Abstract Method\n• Only includes a description of its parameters\n• No method bodies or implementations are\nallowed.\n• In other words, only the interface of the method\nis included.\nJava Interfaces\n• Similar to a Java class\n– can include variable declarations\n– can include methods\n• However\n– Variables must be constants\n– Methods must be abstract.\n– A Java interface cannot be instantiated.\n• We can use an interface to formally specify the logical\nlevel of an ADT:\n– It\n<eos>"}
{"text": "<bos>\nprovides a template for classes to fill.\n– A separate class then \"implements\" it.\n• For example, see the FigureInterface interface and\nthe Circle class (next slide) and Rectangle class\n(following slide) that implement it\nFigureInterface Circle Class\npackage ch02.figures; package ch02.figures;\npublic interface FigureInterface public class Circle implements\n{ FigureInterface\nfinal double PI = 3.14; {\nprotected double radius;\ndouble perimeter();\n// Returns perimeter of this figure. public Circle(double radius)\n{\ndouble area(); this.radius = radius;\n// Returns area of this figure. }\n}\npublic double perimeter()\n{\nreturn(2 * PI * radius);\n}\npublic double area()\n{\nreturn(PI * radius * radius);\n}\n}\nFigureInterface Rectangle Class\npackage ch02.figures; package ch02.figures;\npublic interface\n<eos>"}
{"text": "<bos>\nFigureInterface public class Rectangle implements\n{ FigureInterface\nfinal double PI = 3.14; {\nprotected double length, width;\ndouble perimeter();\n// Returns perimeter of this figure. public Rectangle(double length,\ndouble width)\ndouble area(); {\n// Returns area of this figure. this.length = length;\n} this.width = width;\n}\npublic double perimeter()\n{\nreturn(2 * (length + width));\n}\npublic double area()\n{\nreturn(length * width);\n}\n}\nUML Class Diagram\nBenefits from Using Interfaces\n• We can formally check the syntax of our specification.\nWhen we compile the interface, the compiler uncovers\nany syntactical errors in the method interface definitions.\n• We can formally verify that the interface “contract” is met\nby the implementation. When we compile the\nimplementation, the compiler ensures that\n<eos>"}
{"text": "<bos>\nthe method\nnames, parameters, and return types match what was\ndefined in the interface.\n• We can provide a consistent interface to applications\nfrom among alternate implementations of the ADT.\nInterface-Based Polymorphism\n• Polymorphism – an object variable can\nreference objects of different classes at different\ntimes.\n• A variable declared to be of an interface\n“type” T can hold a reference to any object of\nclass that implements that interface.\n• See example, next slide.\nFigureInterface[] figures = new FigureInterface[COUNT];\nfinal int COUNT = 5;\n// generate figures\nfor (int i = 0; i < COUNT; i++)\n{\nswitch (rand.nextInt(2))\n{\ncase 0: figures[i] = new Circle(1.0);\nbreak;\ncase 1: figures[i] = new Rectangle(1.0, 2.0);\nbreak;\n}\n}\nWhat is held in figures[3]?\nWe cannot predict. The binding of\n<eos>"}
{"text": "<bos>\nfigures[3] to a class\n(Circle or Rectangle) occurs dynamically, at run time.\nfigures[3] is a polymorphic object.\n2.2 The Stack\n• Stack A structure in which elements are added\nand removed from only one end; a “last in, first\nout” (LIFO) structure\nOperations on Stacks\n• Constructor\n– new - creates an empty stack\n• Transformers\n– push - adds an element to the top of a stack\n– pop - removes the top element off the stack\n• Observer\n– top - returns the top element of a stack\nEffects of\nStack\nOperations\nUsing Stacks\n• Stacks are often used for “system”\nprogramming:\n– Programming language systems use a stack to keep\ntrack of sequences of operation calls\n– Compilers use stacks to analyze nested language\nstatements\n– Operating systems save information about the current\nprocess on a stack, so that it\n<eos>"}
{"text": "<bos>\ncan work on a higher-\npriority, interrupting process\n• Stacks are good for storing “postponed\nobligations”\n2.3 Collection Elements\n• Collection An object that holds other objects.\nTypically we are interested in inserting,\nremoving, and obtaining the elements of a\ncollection.\n• A stack is an example of a Collection ADT. It\ncollects together elements for future use, while\nmaintaining a first in – last out ordering among\nthe elements.\nHow can we implement stacks that\nhold different types of elements?\nOne approach is to implement a separate stack\nclass for each element type:\nThis approach is too redundant and not\ngenerally useful.\nHow can we implement stacks that\nhold different types of elements?\nAnother approach is to implement a stack class\nthat can hold elements of class Object:\nThis\n<eos>"}
{"text": "<bos>\napproach requires extra effort to keep track\nof, and indicate, exactly what is in the stack.\nCollections of Class Object\n• Note: whenever an element is removed from the\ncollection it can only be referenced as an\nObject. If you intend to use it as something\nelse you must cast it into the type that you\nintend to use.\n• For example:\ncollection.push(“E. E. Cummings”); // push string on a stack\nString poet = (String) collection.top(); // cast top to String\nSystem.out.println(poet.toLowerCase()); // use the string\nHow can we implement stacks that\nhold different types of elements?\nAnother approach is to implement a stack class\nthat can hold elements of a particular interface:\nThis approach could work in certain specific situations\nbut it is not a general solution.\nHow can we implement stacks that\n<eos>"}
{"text": "<bos>\nhold different types of elements?\nGeneric stack – implement once and indicate the type\nof element to be held on instantiation\nThis is the approach we will use:\n• Parameterized types\n• Declared as <T>\n• Actual type provided upon instantiation\nGeneric Collections\n• Example of beginning of Stack class definition:\npublic class Stack<T>\n{\nprotected T[ ] elements ;\nprotected int topIndex = -1;\n...\n• Example of application declaring various stacks:\nStack<Integer> numbers;\nStack<BankAccount> investments;\nStack<String> answers;\n2.4 The Stack Interface\n• Recall from Section 2.1 that a stack is a \"last-in\nfirst-out\" structure, with primary operations\n– push - adds an element to the top of the stack\n– pop - removes the top element off the stack\n– top - returns the top element of a stack\n• In addition\n<eos>"}
{"text": "<bos>\nwe need a constructor that creates an\nempty stack\n• Our Stack ADT will be a generic stack.\n– The class of elements that a stack stores will be\nspecified by the client code at the time the stack is\ninstantiated.\nExceptional Situations\n• pop and top – what if the stack is empty?\n– throw a StackUnderflowException\n– plus define an isEmpty method for use by the\napplication\n• push – what if the stack is full?\n– throw a StackOverflowException\n– plus define an isFull method for use by the\napplication\nStackInterface\npackage ch02.stacks;\npublic interface StackInterface<T>\n{\nvoid push(T element) throws StackOverflowException;\n// Throws StackOverflowException if this stack is full,\n// otherwise places element at the top of this stack.\nvoid pop() throws StackUnderflowException;\n// Throws\n<eos>"}
{"text": "<bos>\nStackUnderflowException if this stack is empty,\n// otherwise removes top element from this stack.\nT top() throws StackUnderflowException;\n// Throws StackUnderflowException if this stack is empty,\n// otherwise returns top element of this stack.\nboolean isFull();\n// Returns true if this stack is full, otherwise returns false.\nboolean isEmpty();\n// Returns true if this stack is empty, otherwise returns false.\n}\nExample Use of a Stack\n• Instructors can now review and demonstrate the\nReverseStrings application found in package\nch02.apps.\n2.5 Array-Based Implementations\n• In this section we study an array-based\nimplementation of a bounded Stack ADT.\n• Additionally, we look at an alternate unbounded\nimplementation that uses the Java Library\nArrayList class.\nThe beginning of the\nArrayBoundedStack\n<eos>"}
{"text": "<bos>\nClass\n//---------------------------------------------------------------------\n// ArrayBoundedStack.java Dale/Joyce/Weems Chapter 2\n//\n// Implements StackInterface using an array to hold stack elements.\n//\n// Two constructors are provided: one that creates an array of a default\n// size and one that allows the calling program to specify the size.\n//---------------------------------------------------------------------------\npackage ch02.stacks;\npublic class ArrayBoundedStack<T> implements StackInterface<T>\n{\nprotected final int DEFCAP = 100; // default capacity\nprotected T[] elements; // holds stack elements\nprotected int topIndex = -1; // index of top element in stack\npublic ArrayBoundedStack()\n{\nelements = (T[]) new Object[DEFCAP];\n}\npublic ArrayBoundedStack(int maxSize)\n{\nelements = (T[])\n<eos>"}
{"text": "<bos>\nnew Object[maxSize];\n}\nVisualizing the stack\n• The empty stack: • After pushing “A”, “B”\nand “C”:\nDefinitions of Stack Operations\npublic boolean isEmpty()\n// Returns true if this stack is empty, otherwise returns false.\n{\nreturn (topIndex == -1);\n}\npublic boolean isFull()\n// Returns true if this stack is full, otherwise returns false.\n{\nreturn (topIndex == (elements.length - 1));\n}\nDefinitions of Stack Operations\npublic void push(T element)\n{\nif (isFull())\nthrow new StackOverflowException(\"Push attempted on a full stack.\");\nelse\n{\ntopIndex++;\nelements[topIndex] = element;\n}\n}\npublic void pop()\n{\nif (isEmpty())\nthrow new StackUnderflowException(\"Pop attempted on empty stack.\");\nelse\n{\nelements[topIndex] = null;\ntopIndex--;\n}\n}\nDefinitions of Stack Operations\npublic T top()\n{\nT topOfStack =\n<eos>"}
{"text": "<bos>\nnull;\nif (isEmpty())\nthrow new StackUnderflowException(\"Top attempted on empty stack.\");\nelse\ntopOfStack = elements[topIndex];\nreturn topOfStack;\n}\nFigure depicts Application,\nImplementation and Abstract\nviews of the code sequence:\nStackInterface<String> myStack;\nmyStack = new\nArrayBoundedStack<String>(3);\nmyStack.push(A);\nmyStack.push(B);\nThe beginning of the\nArrayListStack Class\n//---------------------------------------------------------------------------\n// ArrayListStack.java by Dale/Joyce/Weems Chapter 2\n//\n// Implements an unbounded stack using an ArrayList.\n//---------------------------------------------------------------------------\npackage ch02.stacks;\nimport java.util.*;\npublic class ArrayListStack<T> implements StackInterface<T>\n{\nprotected ArrayList<T> elements; // ArrayList\n<eos>"}
{"text": "<bos>\nthat holds stack elements\npublic ArrayListStack()\n{\nelements = new ArrayList<T>();\n}\nDefinitions of Stack Operations\npublic boolean isEmpty()\n// Returns true if this stack is empty, otherwise returns false.\n{\nreturn (elements.size() == 0);\n}\npublic boolean isFull()\n// Returns false – an ArrayListStack is never full.\n{\nreturn false;\n}\nDefinitions of Stack Operations\npublic void push(T element)\n{\nelements.add(element);\n}\npublic void pop()\n{\nif (isEmpty())\nthrow new StackUnderflowException(\"Pop attempted on empty stack.\");\nelse\nelements.remove(elements.size() - 1);\n}\npublic T top()\n{\nT topOfStack = null;\nif (isEmpty())\nthrow new StackUnderflowException(\"Top attempted on empty stack.\");\nelse\ntopOfStack = elements.get(elements.size() - 1);\nreturn topOfStack;\n}\n2.6 Application: Balanced\n<eos>"}
{"text": "<bos>\nExpressions\n• Given a set of grouping symbols, determine if the open\nand close versions of each symbol are matched\ncorrectly.\n• We’ll focus on the normal pairs, (), [], and {}, but in theory\nwe could define any pair of symbols (e.g., < > or / \\) as\ngrouping symbols.\n• Any number of other characters may appear in the input\nexpression, before, between, or after a grouping pair,\nand an expression may contain nested groupings.\n• Each close symbol must match the last unmatched\nopening symbol and each open grouping symbol must\nhave a matching close symbol.\nExamples\nThe Balanced Class\n• To help solve our problem we create a class\ncalled Balanced, with two instance variables of\ntype String (openSet and closeSet) and a\nsingle exported method test\n• The Constructor is:\npublic Balanced(String\n<eos>"}
{"text": "<bos>\nopenSet, String closeSet)\n// Preconditions: No character is contained more than once in the\n// combined openSet and closeSet strings.\n// The size of openSet == the size of closeSet.\n{\nthis.openSet = openSet;\nthis.closeSet = closeSet;\n}\nThe test method\n• Takes an expression as a string argument and\nchecks to see if the grouping symbols in the\nexpression are balanced.\n• We use an integer to indicate the result:\n– 0 means the symbols are balanced, such as (([xx])xx)\n– 1 means the expression has unbalanced symbols,\nsuch as (([xx}xx))\n– 2 means the expression came to an end prematurely,\nsuch as (([xxx])xx\nThe test method\n• For each input character, it does one of three\ntasks:\n– If the character is an open symbol, it is pushed on a\nstack.\n– If the character is a close symbol, it must be checked\n<eos>"}
{"text": "<bos>\nagainst the last open symbol, which is obtained from\nthe top of the stack. If they match, processing\ncontinues with the next character. If the close symbol\ndoes not match the top of the stack, or if the stack is\nempty, then the expression is ill-formed.\n– If the character is not a special symbol, it is skipped.\nTest for Well-Formed Expression\nAlgorithm (String expression)\nCreate a new stack of size equal to the length of subject\nSet stillBalanced to true\nGet the first character from expression\nwhile (the expression is still balanced\nAND\nthere are still more characters to process)\nProcess the current character\nGet the next character from expression\nif (!stillBalanced)\nreturn 1\nelse if (stack is not empty)\nreturn 2\nelse\nreturn 0\nExpansion of\n“Process the current character”\nif (the character\n<eos>"}
{"text": "<bos>\nis an open symbol)\nPush the open symbol character onto the stack\nelse if (the character is a close symbol)\nif (the stack is empty)\nSet stillBalanced to false\nelse\nSet open symbol character to the value at the top of the stack\nPop the stack\nif the close symbol character does not “match” the open symbol character\nSet stillBalanced to false\nelse\nSkip the character\nCode and Demo\n• Instructors can now walk through the code contained in\nBalanced.java found in the ch02.balanced\npackage and BalancedCLI.java and/or\nBalancedGUI.java found in the ch02.apps package,\nreview the notes on pages 104 and 105, and\ndemonstrate the running program.\nProgram Architecture\n2.7 Introduction to Linked Lists\n• Arrays and Linked Lists are both basic building\nblocks for implementing data structures.\n• They differ in\n<eos>"}
{"text": "<bos>\nterms of\n– use of memory\n– manner of access\n– efficiency for various operations\n– language support\nNodes of a Linked-List\n• A node in a linked list is an object that holds\nsome important information, such as a string,\nplus a link to the exact same type of object, i.e.\nto an object of the same class.\n• Self-referential class A class that includes an\ninstance variable or variables that can hold a\nreference to an object of the same class.\n• To support our linked implementations of our\nADTs we create the self-referential LLNode\nclass …\n//---------------------------------------------------\nLLNode\n// LLNode.java by Dale/Joyce/Weems Chapter 2\n//\n// Implements <T> nodes for a Linked List.\n//---------------------------------------------------\nClass\npackage support;\npublic class LLNode<T>\n{\n<eos>"}
{"text": "<bos>\nprotected T info;\nprotected LLNode<T> link;\npublic LLNode(T info)\n{\nthis.info = info;\nlink = null;\n}\npublic void setInfo(T info){ this.info = info;}\npublic T getInfo(){ return info; }\npublic void setLink(LLNode<T> link){ this.link = link;}\npublic LLNode<T> getLink(){ return link;}\n}\nUsing the LLNode class\n1: LLNode<String> sNode1 = new LLNode<String>(\"basketball\");\n2: suppose that in addition to sNode1\nwe have sNode2 with info “baseball”\nand perform\nsNode1.setLink(sNode2);\nTraversal of a Linked List\nLLNode<String> currNode = letters;\nwhile (currNode != null)\n{\nSystem.out.println(currNode.getInfo());\ncurrNode = currNode.getLink();\n}\nTracing a Traversal (part 1)\nLLNode<String> currNode = letters;\nwhile (currNode != null)\n{\nSystem.out.println(currNode.getInfo());\ncurrNode =\n<eos>"}
{"text": "<bos>\ncurrNode.getLink();\n}\nInternal View\nOutput\nTracing a Traversal (part 2)\nLLNode<String> currNode = letters;\nwhile (currNode != null)\n{\nSystem.out.println(currNode.getInfo());\ncurrNode = currNode.getLink();\n}\nInternal View\nOutput\nB\nTracing a Traversal (part 3)\nLLNode<String> currNode = letters;\nwhile (currNode != null)\n{\nSystem.out.println(currNode.getInfo());\ncurrNode = currNode.getLink();\n}\nInternal View\nOutput\nB\nC\nTracing a Traversal (part 4)\nLLNode<String> currNode = letters;\nwhile (currNode != null)\n{\nSystem.out.println(currNode.getInfo());\ncurrNode = currNode.getLink();\n}\nInternal View\nOutput\nB\nC\nD\nThree general cases of insertion\nInsertion at the front (part 1)\nSuppose we have the node newNode to insert into the\nbeginning of the letters linked list:\nInsertion at the front (part 2)\nOur\n<eos>"}
{"text": "<bos>\nfirst step is to set the link variable of the newNode\nnode to point to the beginning of the list :\nnewNode.setLink(letters);\nInsertion at the front (part 3)\nTo finish the insertion we set the letters variable to point\nto the newNode, making it the new beginning of the list:\nletters = newNode;\nInsertion at front of an empty list\nThe insertion at the front code is\nnewNode.setLink(letters);\nletters = newNode;\nWhat happens if our insertion code\nis called when the linked list is\nempty?\nAs can be seen at the right the\ncode still works, with the new node\nbecoming the first and only node on\nthe linked list.\n2.8 A Link-Based Stack\n• In this section we study a link-based\nimplementation of the Stack ADT.\n• After discussing the link-based approach we\ncompare our stack implementation approaches.\nThe\n<eos>"}
{"text": "<bos>\nLinkedStack Class\nWe only need a single instance variable, the “pointer” to\nthe ‘top’ of the stack:\npackage ch02.stacks;\nimport support.LLNode;\npublic class LinkedStack<T> implements StackInterface<T>\n{\nprotected LLNode<T> top; // reference to the top of this stack\npublic LinkedStack()\n{\ntop = null;\n}\n. . .\nVisualizing\nthe push\noperation\n(insertion at front of a linked-list)\nStackInterface<String> myStack;\nmyStack = new LinkedStack<String>();\nmyStack.push(A);\nmyStack.push(B);\nmyStack.push(C);\nThe push(C) operation (step 1)\n• Allocate space for the next stack node\nand set the node info to element\n• Set the node link to the previous top of stack\n• Set the top of stack to the new stack node\nThe push(C) operation (step 2)\n• Allocate space for the next stack node\nand set the node info to\n<eos>"}
{"text": "<bos>\nelement\n• Set the node link to the previous top of stack\n• Set the top of stack to the new stack node\nThe push(C) operation (step 3)\n• Allocate space for the next stack node\nand set the node info to element\n• Set the node link to the previous top of stack\n• Set the top of stack to the new stack node\nCode for the push method\npublic void push(T element)\n// Places element at the top of this stack.\n{\nLLNode<T> newNode = new LLNode<T>(element);\nnewNode.setLink(top);\ntop = newNode;\n}\nResult\nof push\nonto\nempty\nstack\nCode for the pop method\npublic void pop()\n// Throws StackUnderflowException if this stack is empty,\n// otherwise removes top element from this stack.\n{\nif (isEmpty())\nthrow new StackUnderflowException(\"Pop attempted on an empty stack.\");\nelse\ntop = top.getLink();\n}\nPop from\na stack\n<eos>"}
{"text": "<bos>\nwith three\nelements\nThe remaining operations\npublic T top()\n{\nif (isEmpty())\nthrow new StackUnderflowException(\"Top attempted on an empty stack.\");\nelse\nreturn top.getInfo();\n}\npublic boolean isEmpty()\n{\nreturn (top == null);\n}\npublic boolean isFull()\n// Returns false – a linked stack is never full.\n{\nreturn false;\n}\nComparing Stack Implementations\n• Storage Size\n– Array-based: takes the same amount of memory, no\nmatter how many array slots are actually used,\nproportional to maximum size\n– Link-based: takes space proportional to actual size of\nthe stack (but each element requires more space than\nwith array approach)\n• Operation efficiency\n– All operations, for each approach, are O(1)\n– Except for the Constructors:\n• Array-based: O(N)\n• Link-based: O(1)\nWhich is better?\n• The linked\n<eos>"}
{"text": "<bos>\nimplementation does not have space\nlimitations, and in applications where the\nnumber of stack elements can vary greatly, it\nwastes less space when the stack is small.\n• The array-based implementation is short,\nsimple, and efficient. Its operations have less\noverhead. When the maximum size is small and\nwe know the maximum size with certainty, the\narray-based implementation is a good choice.\nOur\nStack\nClasses\nand\nInterfaces\n2.9 Application: Postfix Expression\nEvaluator\n• Postfix notation is a notation for writing\narithmetic expressions in which the operators\nappear after their operands.\n• For example, instead of writing\n(2 + 14) × 23\nwe write\n2 14 + 23 ×\nExamples\nPostfix Expression Evaluation\nAlgorithm\nwhile more items exist\nGet an item\nif item is an operand\nstack.push(item)\nelse\noperand2 =\n<eos>"}
{"text": "<bos>\nstack.top()\nstack.pop()\noperand1 = stack.top()\nstack.pop()\nSet result to (apply operation corresponding to item\nto operand1 and operand2)\nstack.push(result)\nresult = stack.top()\nstack.pop()\nreturn result\nExample\nExample\nExample\nExample\nExample\nExample\nExample\nCode and Demo\n• Instructors can now walk through and\ndemonstrate the code contained in\nPostFixEvaluator.java from the\nch02.postfix package and PFixCLI.java\nand/or PFixGUI.java from the ch02.apps\npackage.\n2.10 Stack Variations\n• Changes we could make to our Stack\n– Use stacks of class Object instead of\ngeneric stacks\n– Implement the classic pop operation (both\nremove and return top element) instead of the\ncombination of pop and top operations\n– Instead of throwing exceptions we could\n• for example, state as a precondition that pop will\n<eos>"}
{"text": "<bos>\nnot be called on an empty stack\n• for example, state that pop returns a boolean\nindicating success\nThe Java Collections Framework\nStack\n• extends the Vector class which extends the\nObject class\n– inherits several useful operations such as\ncapacity, clear, clone, contains, isEmpty,\ntoArray, and toString.\n• in addition to our push and top methods,\nimplements\n– the classic pop operation (both remove and return top\nelement)\n– a search operation that returns the position of a\nspecified object in the stack\n<eos>"}
{"text": "<bos>\nChapter 3\nRecursion\nChapter 3: Recursion\n3.1 – Recursive Definitions, Algorithms\nand Programs\n3.2 – The Three Questions\n3.3 – Recursive Processing of Arrays\n3.4 – Recursive Processing of Linked Lists\n3.5 – Towers of Hanoi\n3.6 – Fractals\n3.7 – Removing Recursion\n3.8 – Deciding Whether to Use a Recursive Solution\n3.1 Recursive Definitions,\nAlgorithms and Programs\nRecursive Definitions\n• Recursive definition A definition in which\nsomething is defined in terms of smaller versions\nof itself. For example:\n– A folder is an entity in a file system which contains a\ngroup of files and other folders.\n– A compound sentence is a sentence that consists of\ntwo sentences joined together by a coordinating\nconjunction.\n– n! = 1 if n = 0\n= n X (n – 1)! if n > 0\nrecursive part of definition\nExample: Calculate\n<eos>"}
{"text": "<bos>\n4!\nExample: Calculate 4!\n. . .\nExample: Calculate 4!\n. . .\nRecursive Algorithms\n• Recursive algorithm A solution that is\nexpressed in terms of\n– smaller instances of itself and\n– a base case\n• Base case The case for which the solution can\nbe stated non-recursively\n• General (recursive) case The case for which\nthe solution is expressed in terms of a smaller\nversion of itself\nExamples of a Recursive Algorithm\nand a Recursive Program\nFactorial (int n)\n// Assume n >= 0\nif (n == 0)\nreturn (1)\nelse\nreturn ( n * Factorial ( n – 1 ) )\npublic static int factorial(int n)\n// Precondition: n is non-negative\n//\n// Returns the value of \"n!\".\n{\nif (n == 0)\nreturn 1; // Base case\nelse\nreturn (n * factorial(n – 1)); // General case\n}\nRecursion Terms\n• Recursive call A method call in which the method being\n<eos>"}
{"text": "<bos>\ncalled is the same as the one making the call\n• Direct recursion Recursion in which a method directly\ncalls itself, like the factorial method.\n• Indirect recursion Recursion in which a chain of two or\nmore method calls returns to the method that originated\nthe chain, for example method A calls method B which in\nturn calls method A\nIterative Solution for Factorial\n• We have used the factorial algorithm to demonstrate\nrecursion because it is familiar and easy to visualize. In\npractice, one would never want to solve this problem\nusing recursion, since a straightforward, more efficient\niterative solution exists:\npublic static int factorial(int n)\n{\nint retValue = 1;\nwhile (n != 0)\n{\nretValue = retValue * n;\nn = n - 1;\n}\nreturn(retValue);\n}\n3.2 The Three Questions\n• In this section we present\n<eos>"}
{"text": "<bos>\nthree questions to ask\nabout any recursive algorithm or program.\n• Using these questions helps us verify, design,\nand debug recursive solutions to problems.\nVerifying Recursive Algorithms\nTo verify that a recursive solution works, we must be able\nto answer “Yes” to all three of these questions:\n1. The Base-Case Question: Is there a nonrecursive way out of\nthe algorithm, and does the algorithm work correctly for this\nbase case?\n2. The Smaller-Caller Question: Does each recursive call to the\nalgorithm involve a smaller case of the original problem,\nleading inescapably to the base case?\n3. The General-Case Question: Assuming the recursive call(s)\nto the smaller case(s) works correctly, does the algorithm\nwork correctly for the general case?\nWe next apply these three questions to the factorial\n<eos>"}
{"text": "<bos>\nalgorithm.\nThe Base-Case Question\nFactorial (int n) Is there a nonrecursive way out\n// Assume n >= 0 of the algorithm, and does the\nif (n == 0) algorithm work correctly\nreturn (1)\nfor this base case?\nelse\nreturn ( n * Factorial ( n – 1 ) )\nThe base case occurs when n is 0.\nThe Factorial algorithm then returns the value of 1, which is\nthe correct value of 0!, and no further (recursive) calls\nto Factorial are made.\nThe answer is yes.\nThe Smaller-Caller Question\nFactorial (int n) Does each recursive call to the\n// Assume n >= 0 algorithm involve a smaller case\nif (n == 0) of the original problem, leading\nreturn (1)\ninescapably to the base case?\nelse\nreturn ( n * Factorial ( n – 1 ) )\nThe parameter is n and the recursive call passes the\nargument n - 1. Therefore each subsequent recursive call\n<eos>"}
{"text": "<bos>\nsends a smaller value, until the value sent is finally 0.\nAt this point, as we verified with the base-case question,\nwe have reached the smallest case, and no further\nrecursive calls are made. The answer is yes.\nThe General-Case Question\nFactorial (int n) Assuming the recursive call(s) to the\n// Assume n >= 0 smaller case(s) works correctly, does\nif (n == 0) the algorithm work correctly for the\nreturn (1)\ngeneral case?\nelse\nreturn ( n * Factorial ( n – 1 ) )\nAssuming that the recursive call Factorial(n – 1) gives us\nthe correct value of (n - 1)!, the return statement computes\nn * (n - 1)!.\nThis is the definition of a factorial, so we know that the algorithm\nworks in the general case. The answer is yes.\nConstraints on input arguments\n• Constraints often exist on the valid input arguments\n<eos>"}
{"text": "<bos>\nfor a\nrecursive algorithm. For example, for Factorial, n must\nbe >= 0.\n• You can use the three question analysis to determine\nconstraints:\n– Check if there are any starting argument values for which the\nsmaller call does not produce a new argument that is closer to\nthe base case.\n– Such starting values are invalid.\n– Constrain your legal input arguments so that these values are\nnot permitted.\nSteps for Designing Recursive\nSolutions\n1. Get an exact definition of the problem to be solved.\n2. Determine the size of the problem to be solved on this\ncall to the method.\n3. Identify and solve the base case(s) in which the\nproblem can be expressed non-recursively. This\nensures a yes answer to the base-case question.\n4. Identify and solve the general case(s) correctly in terms\nof a smaller case of\n<eos>"}
{"text": "<bos>\nthe same problem—a recursive\ncall. This ensures yes answers to the smaller-caller and\ngeneral-case questions.\n3.3 Recursive Processing of Arrays\n• Many problems related to arrays lend\nthemselves to a recursive solution.\n• A subsection of an array (a “subarray”) can also\nbe viewed as an array.\n• If we can solve an array-related problem by\ncombining solutions to a related problem on\nsubarrays, we may be able to use a recursive\napproach.\nBinary Search\n• Problem: find a target element in a sorted array\n• Approach\n– examine the midpoint of the array and compare the\nelement found there to our target element\n– eliminate half the array from further consideration\n– recursively repeat this approach on the remaining\nhalf of the array until we find the target or determine\nthat it is not in the array\n<eos>"}
{"text": "<bos>\nExample\n• We have a sorted array of int named values\nof size 8\n• Our target is 20\n• Variables first and last indicate the sub-\narray currently under consideration\n• Therefore, the starting configuration is:\nExample\n• The midpoint is the average of first and last\nmidpoint = (first + last) / 2\n• Since values[midpoint] is less than target\nwe eliminate the lower half of the array from\nconsideration\nExample\n• Set first to midpoint + 1 and calculate a\nnew midpoint resulting in\n• Since values[midpoint] is greater than\ntarget we eliminate the upper half of remaining\nportion of the array from consideration.\nExample\n• Set last to midpoint - 1 and calculate a\nnew midpoint resulting in\n• Since values[midpoint]equals target we\nare finished and return true\nExample – target not in array\n• Consider the\n<eos>"}
{"text": "<bos>\nabove example again, but this time\nwith 18 replacing 20 as the fifth element of\nvalues. The same sequence of steps would\noccur until at the very last step we have the\nfollowing:\nExample – target not in array\n• Since values[midpoint] is less than target\nwe set first to midpoint + 1:\n• The entire array has been eliminated (since\nfirst > last) and we return false.\nCode for the Binary Search\nboolean binarySearch(int target, int first, int last)\n// Precondition: first and last are legal indices of values\n//\n// If target is contained in values[first,last] return true\n// otherwise return false.\n{\nint midpoint = (first + last) / 2;\nif (first > last)\nreturn false;\nelse\nif (target == values[midpoint])\nreturn true;\nelse\nrecursive call\nif (target > values[midpoint])\nreturn binarySearch(target,\n<eos>"}
{"text": "<bos>\nmidpoint + 1, last);\nrecursive call\nelse\nreturn binarySearch(target, first, midpoint - 1);\n}\n3.4 Recursive Processing\nof Linked Lists\n• A linked list is a recursive structure\n• The LLNode class, our building block for linked\nlists, is a self-referential (recursive) class:\npublic class LLNode<T>\n{\nprotected T info; // information stored in list\nprotected LLNode<T> link; // reference to a node\n. . .\nrecursive reference\nRecursive nature of Linked Lists\n• A linked list is either empty or consists of a node\ncontaining two parts:\n– information\n– a linked list\ncontains info A plus a linked list (B – C)\nPrinting a Linked List Recursively\nvoid recPrintList(LLNode<String> listRef)\n{\nif (listRef != null)\n{\nSystem.out.println(listRef.getInfo());\nrecPrintList(listRef.getLink());\n}\n}\nComparison\nvoid\n<eos>"}
{"text": "<bos>\nrecPrintList(LLNode<String> listRef)\n{\nif (listRef != null)\n{\nSystem.out.println(listRef.getInfo());\nrecPrintList(listRef.getLink());\n}\nIterative approach is better\n}\nvoid iterPrintList(LLNode<String> listRef)\n{\nwhile (listRef != null)\n{\nSystem.out.println(listRef.getInfo());\nlistRef = listRef.getLink();\n}\nbut what if you want to print the list in reverse???\n}\nReverse Printing a Linked List\nvoid recPrintList(LLNode<String> listRef)\n{\nif (listRef != null)\n{\nrecPrintList(listRef.getLink());\nSystem.out.println(listRef.getInfo());\n}\n}\nTransforming a linked list\nrecursively\n• For example, insert an element at the end of the\nlist\nvoid recInsertEnd(String newInfo, LLNode<String> listRef)\n// Adds newInfo to the end of the listRef linked list\n{\nif (listRef.getLink() != null)\nrecInsertEnd(newInfo,\n<eos>"}
{"text": "<bos>\nlistRef.getLink());\nelse\nlistRef.setLink(new LLNode<String>(newInfo));\n}\nAlthough this works in the general case\nit does not work if the original list is empty\nProblem with the approach\nvoid recInsertEnd(String newInfo, LLNode<String> listRef)\n// Adds newInfo to the end of the listRef linked list\n{\nif (listRef.getLink() != null)\nrecInsertEnd(newInfo, listRef.getLink());\nelse\nlistRef.setLink(new LLNode<String>(newInfo));\n}\nIf we invoke, for example,\nrecInsertEnd(“Z”,myList)\nthe temporary variable listRef will hold a linked\nlist consisting of “Z” but myList will still be null.\nSolution\n• Rather than return void where we invoke as\nrecInsertEnd(“Z”, myList)\n• Need a solution that returns a linked list so we\ncan invoke as\nmyList = recInsertEnd(“Z”, myList)\n• This is the only way we can change\n<eos>"}
{"text": "<bos>\nthe value of\nmyList in the case that the list is empty\nSolution\nLLNode<String> recInsertEnd(String newInfo, LLNode<String> listRef)\n// Adds newInfo to the end of the listRef linked list\n{\nif (listRef != null)\nlistRef.setLink(recInsertEnd(newInfo, listRef.getLink()));\nelse\nlistRef = new LLNode<String>(newInfo);\nreturn listRef;\n}\nThis works in both the general case and\nthe case where the original list is empty.\n3.5 Towers of Hanoi\n• Move the rings, one at a time, to the third peg.\n• A ring cannot be placed on top of one that is smaller in\ndiameter.\n• The middle peg can be used as an auxiliary peg, but it\nmust be empty at the beginning and at the end of the\ngame.\n• The rings can only be moved one at a time.\nSample\nSolution\nGeneral Approach\nTo move the largest ring to peg 3, we must move the\n<eos>"}
{"text": "<bos>\nthree smaller\nrings to peg 2:\nThen the largest ring can be moved to peg 3:\nAnd finally the three smaller rings are moved from peg 2 to peg 3:\nRecursion\n• Can you see that our solution involved solving a smaller\nversion of the problem? We have solved the problem\nusing recursion.\n• The general recursive algorithm for moving n rings from\nthe starting peg to the destination peg 3 is:\nMove n rings from Starting Peg to Destination Peg\nMove n - 1 rings from starting peg to auxiliary peg\nMove the nth ring from starting peg to destination peg\nMove n - 1 rings from auxiliary peg to destination peg\nRecursive Method\npublic static void doTowers(\nint n, // Number of rings to move\nint startPeg, // Peg containing rings to move\nint auxPeg, // Peg holding rings temporarily\nint endPeg ) // Peg receiving\n<eos>"}
{"text": "<bos>\nrings being moved\n{\nif (n == 1) // Base case – Move one ring\nSystem.out.println(\"Move ring \" + n + \" from peg \" + startPeg\n+ \" to peg \" + endPeg);\nelse\n{\n// Move n - 1 rings from starting peg to auxiliary peg\ndoTowers(n - 1, startPeg, endPeg, auxPeg);\n// Move nth ring from starting peg to ending peg\nSystem.out.println(\"Move ring \" + n + \" from peg \" + startPeg\n+ \" to peg \" + endPeg);\n// Move n - 1 rings from auxiliary peg to ending peg\ndoTowers(n - 1, auxPeg, startPeg, endPeg);\n}\n}\nCode and Demo\n• Instructors can now walk through the code\ncontained in Towers.java in the ch03.apps\npackage and demonstrate the running program.\n3.6 Fractals\n• There are many different\nways that people define\nthe term “fractal.”\n• For our purposes we\ndefine a fractal as an\nimage that is composed of\nsmaller\n<eos>"}
{"text": "<bos>\nversions of itself.\nA T-Square Fractal\n• In the center of a square black* canvas we draw\na white* square, one-quarter the size of the\ncanvas:\n*Although our publisher\nsupplied figures are\ntinted blue, our code\ngenerates black and\nwhite images.\nA T-Square Fractal\n• We then draw four more squares, each\ncentered at a corner of the original white square,\neach one-quarter the size of the original white\nsquare:\nA T-Square Fractal\n• For each of these new squares we do the same,\n(recursively) drawing four squares of smaller\nsize at each of their corners :\nA T-Square Fractal\n• And again:\nA T-Square Fractal\n• And again:\nuntil we can no\nlonger draw any\nmore squares\nCode and Demo\n• Instructors can now walk\nthrough the code contained in\nTSquare.java in the\nch03.fractals package\nand demonstrate the\n<eos>"}
{"text": "<bos>\nrunning\nprogram.\n• Be sure to also check out\n– TSquareThreshold.java\nthat allows the user to\nindicate when to start stop\ndrawing squares\n– TSquareGray.java that\nuses different gray scale\nlevels for each set of\ndifferently sized squares\n3.7 Removing Recursion\n• We consider two general techniques that are\noften substituted for recursion\n– iteration\n– stacking.\n• First we take a look at how recursion is\nimplemented.\n– Understanding how recursion works helps us see how\nto develop non-recursive solutions.\nStatic Storage Allocation\n• A compiler that translates a high-level language\nprogram into machine code for execution on a\ncomputer must\n– Reserve space for the program variables.\n– Translate the high level executable statements into\nequivalent machine language statements.\nExample of Static\n<eos>"}
{"text": "<bos>\nAllocation\nConsider the following program:\npublic class Kids\n{\nprivate static int countKids(int girlCount, int boyCount)\n{\nint totalKids;\n. . .\n}\npublic static void main(String[] args)\n{\nint numGirls; int numBoys; int numChildren;\n. . .\n}\n}\nA compiler could create two separate machine code units for this program,\none for the countKids method and one for the main method. Each unit would\ninclude space for its variables plus the sequence of machine language\nstatements that implement its high-level code.\nLimitations of static allocation\n• Static allocation like this is the simplest\napproach possible. But it does not support\nrecursion.\n• The space for the countKids method is\nassigned to it at compile time. This works fine\nwhen the method will be called once and then\nalways return before it is\n<eos>"}
{"text": "<bos>\ncalled again. But a\nrecursive method can be called again and again\nbefore it returns. Where do the second and\nsubsequent calls find space for their parameters\nand local variables?\n• Therefore dynamic storage allocation is needed.\nDynamic Storage Allocation\n• Dynamic storage allocation provides memory\nspace for a method when it is called.\n• When a method is invoked, it needs space to\nkeep its parameters, its local variables, and the\nreturn address (the address in the calling code\nto which the computer returns when the method\ncompletes its execution).\n• This space is called an activation record or\nstack frame.\nDynamic Storage Allocation\nConsider a program whose main method calls proc1,\nwhich then calls proc2. When the program begins executing,\nthe “main” activation record is generated:\nAt\n<eos>"}
{"text": "<bos>\nthe first method call, an activation record is generated for proc1:\nDynamic Storage Allocation\nWhen proc2 is called from within proc1, its activation record is generated.\nBecause proc1 has not finished executing, its activation record is still around:\nWhen proc2 finishes executing, its activation record is released:\nDynamic Storage Allocation\n• The order of activation follows the Last-In-First-Out rule.\n• Run-time or system stack A system data structure that\nkeeps track of activation records during the execution of\na program\n• Each nested level of method invocation adds another\nactivation record to the stack. As each method\ncompletes its execution, its activation record is popped\nfrom the stack. Recursive method calls, like calls to any\nother method, cause a new activation record to be\n<eos>"}
{"text": "<bos>\ngenerated.\n• Depth of recursion The number of activation records\non the system stack, associated with a given a recursive\nmethod\nRemoving Recursion - Iteration\n• Suppose the recursive call is the last action executed in\na recursive method (tail recursion)\n– The recursive call causes an activation record to be put on the\nrun-time stack to contain the invoked method’s arguments and\nlocal variables.\n– When this recursive call finishes executing, the run-time stack is\npopped and the previous values of the variables are restored.\n– Execution continues where it left off before the recursive call was\nmade.\n– But, because the recursive call is the last statement in the\nmethod, there is nothing more to execute and the method\nterminates without using the restored local variable values.\n• In such a\n<eos>"}
{"text": "<bos>\ncase the recursion can easily be replaced with\niteration.\nExample of eliminating tail\nrecursion\npublic static int factorial(int n)\n{\nif (n == 0)\nreturn 1; // Base case\nelse\nreturn (n * factorial(n – 1)); // General case\n}\nDeclare a variable to hold the\nprivate static int factorial(int n)\nintermediate values; initialize it to\n{\nthe value returned in the base case. int retValue = 1; // return value\nUse a while loop so that each time while (n != 0)\n{\nthrough the loop corresponds to one\nretValue = retValue * n;\nrecursive call. The loop should\nn = n - 1;\ncontinue processing until the base }\nreturn(retValue);\ncase is met:\n}\nRemove Recursion - Stacking\n• When the recursive call is not the last action\nexecuted in a recursive method, we cannot\nsimply substitute a loop for the recursion.\n• In such\n<eos>"}
{"text": "<bos>\ncases we can “mimic” recursion by using\nour own stack to save the required information\nwhen needed, as shown in the Reverse Print\nexample on the next slide.\nRemove Recursion - Stacking\nstatic void iterRevPrintList(LLNode<String> listRef)\n// Prints the contents of the listRef linked list to standard output\n// in reverse order\n{\nStackInterface<String> stack = new LinkedStack<String>();\nwhile (listRef != null) // put info onto the stack\n{\nstack.push(listRef.getInfo());\nlistRef = listRef.getLink();\n}\n// Retrieve references in reverse order and print elements\nwhile (!stack.isEmpty())\n{\nSystem.out.println(stack.top());\nstack.pop();\n}\n}\n3.6 Deciding Whether to Use a\nRecursive Solution\n• In this section we consider factors used in\ndeciding whether or not to use a recursive\nsolution to a problem.\n•\n<eos>"}
{"text": "<bos>\nThe main issues are the efficiency and the clarity\nof the solution.\nEfficiency Considerations\n• Recursion Overhead\n– A recursive solution usually has more “overhead” than\na non-recursive solution because of the number of\nmethod calls\n• time: each call involves processing to create and dispose of\nthe activation record, and to manage the run-time stack\n• space: activation records must be stored\n• Inefficient Algorithms\n– Another potential problem is that a particular\nrecursive solution might just be inherently inefficient.\nThis can occur if the recursive approach repeatedly\nsolves the same sub-problem, over and over again\nClarity\n• For many problems, a recursive solution is\nsimpler and more natural for the programmer to\nwrite. The work provided by the system stack is\n“hidden” and therefore a\n<eos>"}
{"text": "<bos>\nsolution may be easier\nto understand.\n• Compare, for example, the recursive and\nnonrecursive approaches to printing a linked list\nin reverse order that were developed previously\nin this chapter. In the recursive version, we let\nthe system take care of the stacking that we had\nto do explicitly in the nonrecursive method.\n<eos>"}
{"text": "<bos>\nChapter 4\nThe Queue\nADT\nChapter 4: The Queue ADT\n4.1 – The Queue\n4.2 – The Queue Interface\n4.3 – Array-Based Queue Implementations\n4.4 – An Interactive Test Driver\n4.5 – Link-Based Queue Implementations\n4.6 – Application: Palindromes\n4.7 – Queue Variations\n4.8 – Application: Average Waiting Time\n4.9 – Concurrency, Interference, and\nSynchronization\n4.1 The Queue\n• Queue A structure in which elements are added\nto the rear and removed from the front; a “first in,\nfirst out” (FIFO) structure\nOperations on Queues\n• Constructor\n– new - creates an empty queue\n• Transformers\n– enqueue - adds an element to the rear of a queue\n– dequeue - removes and returns the front element of\nthe queue\nEffects of\nQueue\nOperations\nUsing Queues\n• Operating systems often maintain a queue of processes\nthat are ready\n<eos>"}
{"text": "<bos>\nto execute or that are waiting for a\nparticular event to occur.\n• Computer systems must often provide a “holding area”\nfor messages between two processes, two programs, or\neven two systems. This holding area is usually called a\n“buffer” and is often implemented as a queue.\n• Our software queues have counterparts in real world\nqueues. We wait in queues to buy pizza, to enter movie\ntheaters, to drive on a turnpike, and to ride on a roller\ncoaster. Another important application of the queue data\nstructure is to help us simulate and analyze such real\nworld queues\n4.2 The Queue Interface\n• We use a similar approach as with the Stack\nADT.\n• Our queues\n– are generic\n– queue related classes are held in\nch04.queues package\n• we define exceptions for both queue underflow\nand queue overflow\n• we\n<eos>"}
{"text": "<bos>\ncreate a QueueInterface\nQueueInterface\npackage ch04.queues;\npublic interface QueueInterface<T>\n{\nvoid enqueue(T element) throws QueueOverflowException1;\n// Throws QueueOverflowException if this queue is full;\n// otherwise, adds element to the rear of this queue.\nT dequeue() throws QueueUnderflowException;\n// Throws QueueUnderflowException if this queue is empty;\n// otherwise, removes front element from this queue and returns it.\nboolean isFull();\n// Returns true if this queue is full;\n// otherwise, returns false.\nboolean isEmpty();\n// Returns true if this queue is empty;\n// otherwise, returns false.\nint size();\n// Returns the number of elements in this queue.\n}\nExample Use of a Queue\n• Instructors can now review and demonstrate the\nRepeatStrings application found in package\nch04.apps.\n4.3\n<eos>"}
{"text": "<bos>\nArray-Based Queue\nImplementations\n• In this section we study two array-based\nimplementations of the Queue ADT\n– a bounded queue version\n– an unbounded queue version\n• We simplify some figures by using a capital letter\nto represent an element’s information\nFixed Front Design\n• After four calls to enqueue\nwith arguments ‘A’, ‘B’, ‘C’,\nand ‘D’:\n• Dequeue the front\nelement:\n• Move every element in the\nqueue up one slot\n• The dequeue operation is\ninefficient, so we do not\nuse this approach\nFloating\nFront\nDesign\nWe use this\napproach\nWrap\nAround\nwith\nFloating\nFront\nDesign\nThe ArrayBoundedQueue Class\npackage ch04.queues;\npublic class ArrayBoundedQueue<T> implements QueueInterface<T>\n{\nprotected final int DEFCAP = 100; // default capacity\nprotected T[] elements; // array that holds queue elements\n<eos>"}
{"text": "<bos>\nprotected int numElements = 0; // number of elements in the queue\nprotected int front = 0; // index of front of queue\nprotected int rear; // index of rear of queue\npublic ArrayBoundedQueue()\n{\nelements = (T[]) new Object[DEFCAP];\nrear = DEFCAP - 1;\n}\npublic ArrayBounddQueue(int maxSize)\n{\nelements = (T[]) new Object[maxSize];\nrear = maxSize - 1;\n}\nThe enqueue operation\npublic void enqueue(T element)\n// Throws QueueOverflowException if this queue is full,\n// otherwise adds element to the rear of this queue.\n{\nif (isFull())\nthrow new QueueOverflowException(\"Enqueue attempted on a full queue.\");\nelse\n{\nrear = (rear + 1) % elements.length;\nelements[rear] = element;\nnumElements = numElements + 1;\n}\n}\nThe dequeue operation\npublic T dequeue()\n// Throws QueueUnderflowException if this queue is\n<eos>"}
{"text": "<bos>\nempty,\n// otherwise removes front element from this queue and returns it.\n{\nif (isEmpty())\nthrow new QueueUnderflowException(“Dequeue attempted on empty queue.”);\nelse\n{\nT toReturn = elements[front];\nelements[front] = null;\nfront = (front + 1) % elements.length;\nnumElements = numElements - 1;\nreturn toReturn;\n}\n}\nRemaining Queue Operations\n(observers)\npublic boolean isEmpty()\n// Returns true if this queue is empty, otherwise returns false\n{\nreturn (numElements == 0);\n}\npublic boolean isFull()\n// Returns true if this queue is full, otherwise returns false.\n{\nreturn (numElements == elements.length);\n}\npublic int size()\n// Returns the number of elements in this queue.\n{\nreturn numElements;\n}\nThe ArrayUnboundedQueue\nClass\n• The trick is to create a new, larger array, when\nneeded, and copy the\n<eos>"}
{"text": "<bos>\nqueue into the new array\n– Since enlarging the array is conceptually a separate\noperation from enqueing, we implement it as a\nseparate enlarge method\n– This method instantiates an array with a size equal to\nthe current capacity plus the original capacity\n• We change the isFull method so that it always\nreturns false, since an unbounded queue is\nnever full\n• The dequeue and isEmpty methods are\nunchanged\nThe ArrayUnbndQueue Class\npackage ch04.queues;\npublic class ArrayUnboundedQueue<T> implements QueueInterface<T>\n{\nprotected final int DEFCAP = 100; // default capacity\nprotected T[] elements; // array that holds queue elements\nprotected int origCap; // original capacity\nprotected int numElements = 0; // number of elements in the queue\nprotected int front = 0; // index of front of queue\n<eos>"}
{"text": "<bos>\nprotected int rear; // index of rear of queue\npublic ArrayUnboundedQueue()\n{\nelements = (T[]) new Object[DEFCAP];\nrear = DEFCAP - 1;\norigCap = DEFCAP;\n}\npublic ArrayUnboundedQueue(int origCap)\n{\nelements = (T[]) new Object[origCap];\nrear = origCap - 1;\nthis.origCap = origCap;\n}\nThe enlarge operation\nprivate void enlarge()\n// Increments the capacity of the queue by an amount\n// equal to the original capacity.\n{\n// create the larger array\nT[] larger = (T[]) new Object[elements.length + origCap];\n// copy the contents from the smaller array into the larger array\nint currSmaller = front;\nfor (int currLarger = 0; currLarger < numElements; currLarger++)\n{\nlarger[currLarger] = elements[currSmaller];\ncurrSmaller = (currSmaller + 1) % elements.length;\n}\n// update instance variables\nelements =\n<eos>"}
{"text": "<bos>\nlarger;\nfront = 0;\nrear = numElements - 1;\n}\nThe enqueue operation\npublic void enqueue(T element)\n// Adds element to the rear of this queue.\n{\nif (numElements == elements.length)\nenlarge();\nrear = (rear + 1) % elements.length;\nelements[rear] = element;\nnumElements = numElements + 1;\n}\n4.4 An Interactive Test Driver\n• Act as an example use of the\nArrayBoundedQueue class\n• Can be used by students to experiment and\nlearn about the Queue ADT and the\nrelationships among its exported methods\n• Will use elements of type String to be stored\nand retrieved from the ADT\nThe General Approach\nPrompt for, read, and display test name\nDetermine which constructor to use\nObtain needed parameters\nInstantiate a new instance of the ADT\nwhile (testing continues)\n{\nDisplay a menu of operation choices,\none choice\n<eos>"}
{"text": "<bos>\nfor each method exported by the ADT\nplus a “stop testing” choice\nGet the user’s choice and\nobtain any needed parameters\nPerform the chosen operation\nif an exception is thrown, catch it and\nreport its message\nif a value is returned, report it\n}\n• Instructors can now walk through the code\ncontained in ITDArrayBoundedQueue.java\nfound in the ch04.queues package and\ndemonstrate the running program.\n4.5 Link-Based Queue\nImplementations\n• In this section we develop a link-based\nimplementation of an unbounded queue, and\ndiscuss a second link-based approach.\n• For nodes we use the same LLNode class we\nused for the linked implementation of stacks.\n• After discussing the link-based approaches we\ncompare all of our queue implementation\napproaches.\nThe LinkedQueue Class\npackage ch04.queues;\nimport\n<eos>"}
{"text": "<bos>\nsupport.LLNode;\npublic class LinkedQueue<T> implements QueueInterface<T>\n{\nprotected LLNode<T> front; // reference to the front of this queue\nprotected LLNode<T> rear; // reference to the rear of this queue\nprotected int numElements = 0; // number of elements in this queue\npublic LinkedQueue()\n{\nfront = null; rear = null;\n}\n. . .\nThe enqueue operation\nEnqueue (element)\n1. Create a node for the new element\n2. Add the new node at the rear of the queue\n3. Update the reference to the rear of the queue\n4. Increment the number of elements\nCode for the enqueue method\npublic void enqueue(T element)\n// Adds element to the rear of this queue.\n{\nLLNode<T> newNode = new LLNode<T>(element);\nif (rear == null)\nfront = newNode;\nelse\nrear.setLink(newNode);\nrear = newNode;\nnumElements++;\n}\nThe dequeue\n<eos>"}
{"text": "<bos>\noperation\nDequeue: returns Object\n1. Set element to the information in the front node\n2. Remove the front node from the queue\n3. if the queue is empty\nSet the rear to null\n4. Decrement the number of elements\n5. return element\nCode for the dequeue method\npublic T dequeue()\n// Throws QueueUnderflowException if this queue is empty,\n// otherwise removes front element from this queue and returns it.\n{\nif (isEmpty())\nthrow new QueueUnderflowException(\"Dequeue attempted on empty queue.\");\nelse\n{\nT element;\nelement = front.getInfo();\nfront = front.getLink();\nif (front == null)\nrear = null;\nnumElements--;\nreturn element;\n}\n}\nAn Alternative Approach -\nA Circular Linked Queue\nComparing Queue Implementations\n• Storage Size\n– Array-based: takes the same amount of memory, no matter how\nmany array slots\n<eos>"}
{"text": "<bos>\nare actually used, proportional to current\ncapacity\n– Link-based: takes space proportional to actual size of the queue\n(but each element requires more space than with array\napproach)\n• Operation efficiency\n– All operations, for each approach, are O(1)\n– Except for the Constructors:\n• Array-based: O(N)\n• Link-based: O(1)\n• Special Case – For the ArrayUnboundedQueue the\nsize “penalty” can be minimized but the enlarge\nmethod is O(N)\nComparing Queue Implementations\n4.6 Application: Palindromes\n• Examples\n– A tribute to Teddy Roosevelt, who orchestrated the\ncreation of the Panama Canal:\n• A man, a plan, a canal—Panama!\n– Allegedly muttered by Napoleon Bonaparte upon his\nexile to the island of Elba:\n• Able was I ere, I saw Elba.\n• Our goal is to write a program that identifies\nPalindromic\n<eos>"}
{"text": "<bos>\nstrings\n– we ignore blanks, punctuation and the case of letters\nThe Palindrome Class\n• To help us identify palindromic strings we create\na class called Palindrome, with a single\nexported static method test\n• test takes a candidate string argument and\nreturns a boolean value indicating whether the\nstring is a palindrome\n• Since test is static we invoke it using the name\nof the class rather than instantiating an object of\nthe class\n• The test method uses both the stack and\nqueue data structures\nThe test method approach\n• The test method creates a stack and a queue\n• It then repeatedly pushes each input letter onto the\nstack, and also enqueues the letter onto the queue\n• It discards any non-letter characters\n• To simplify comparison later, we push and enqueue only\nlowercase versions of the\n<eos>"}
{"text": "<bos>\ncharacters\n• After the characters of the candidate string have been\nprocessed, test repeatedly pops a letter from the stack\nand dequeues a letter from the queue\n• As long as these letters match each other the entire way\nthrough this process, we have a palindrome\nTest for Palindrome (String candidate)\nCreate a new stack\nCreate a new queue\nfor each character in candidate\nif the character is a letter\nChange the character to lowercase\nPush the character onto the stack\nEnqueue the character onto the queue\nSet stillPalindrome to true\nwhile (there are still more characters in the structures\n&& stillPalindrome)\nPop fromStack from the stack\nDequeue fromQueue from the queue\nif (fromStack != fromQueue)\nSet stillPalindrome to false\nreturn (stillPalindrome)\nCode and Demo\n• Instructors can now walk\n<eos>"}
{"text": "<bos>\nthrough the code\ncontained in Palindrome.java in the\nch04.palindromes package, and\nPalindromeCLI.java and/or\nPalindrome.GUI both in the ch04.apps\npackage, and demonstrate the application.\nProgram Architecture\n4.7 Queue Variations\n• We consider some alternate ways to define the classic\nqueue operations.\n• We look at additional operations that could be included\nin a Queue ADT, some that allow us to “peek” into the\nqueue and others that expand the access rules\n• We review the Java Standard Library queue support.\nExceptional Situations\n• Our queues throw exceptions in the case of\nunderflow or overflow.\n• Another approach is to prevent the\nover/underflow from occurring by nullifying the\noperation, and returning a value that indicates\nfailure\n– boolean enqueue(T element) adds element to the\nrear\n<eos>"}
{"text": "<bos>\nof this queue; returns true if element is\nsuccessfully added, false otherwise\n– T dequeue()returns null if this queue is empty,\notherwise removes front element from this queue and\nreturns it\nInheritance of Interfaces\n• Java supports inheritance of interfaces.\n• In fact, the language supports multiple\ninheritance of interfaces—a single interface can\nextend any number of other interfaces.\n• Suppose interface B extends interface A. Then a\nclass that implements interface B must provide\nconcrete methods for all of the abstract methods\nlisted in both interface B and interface A.\nThe Glass Queue\n//-------------------------------------------------------------------------\n// GlassQueueInterface.java by Dale/Joyce/Weems Chapter 4\n//\n// Interface for a class that implements a queue of T and includes\n<eos>"}
{"text": "<bos>\n// operations for peeking at the front and rear elements of the queue.\n//-------------------------------------------------------------------------\npackage ch04.queues;\npublic interface GlassQueueInterface<T> extends QueueInterface<T>\n{\npublic T peekFront();\n// If the queue is empty, returns null.\n// Otherwise, returns the element at the front of this queue.\npublic T peekRear();\n// If the queue is empty, returns null.\n// Otherwise, returns the element at the rear of this queue.\n}\npackage ch04.queues;\npublic class LinkedGlassQueue<T> extends LinkedQueue<T>\nimplements GlassQueueInterface<T>\n{\npublic LinkedGlassQueue()\n{\nsuper();\n}\npublic T peekFront()\n{\nif (isEmpty())\nreturn null;\nelse\nreturn front.getInfo();\n}\npublic T peekRear()\n{\nif (isEmpty())\nreturn null;\nelse\nreturn rear.getInfo();\n}\n}\n<eos>"}
{"text": "<bos>\nThe Double-Ended Queue:\nDeque\npackage ch04.queues;\npublic interface DequeInterface<T>\n{\nvoid enqueueFront(T element) throws QueueOverflowException;\n// Throws QueueOverflowException if this queue is full;\n// otherwise, adds element to the front of this queue.\nvoid enqueueRear(T element) throws QueueOverflowException;\n// Throws QueueOverflowException if this queue is full;\n// otherwise, adds element to the rear of this queue.\nT dequeueFront() throws QueueUnderflowException;\n// Throws QueueUnderflowException if this queue is empty;\n// otherwise, removes front element from this queue and returns it.\nT dequeueRear() throws QueueUnderflowException;\n// Throws QueueUnderflowException if this queue is empty;\n// otherwise, removes rear element from this queue and returns it.\nboolean isFull();\n<eos>"}
{"text": "<bos>\nboolean isEmpty();\nint size();\n}\nA good approach for implementing\nDeque\n• Double Linked List:\n• See DLLNode in package support\nQueues in the\nJava Standard Library\n• A Queue interface was added to the Java\nLibrary Collection Framework with Java 5.0 in\n2004.\n• Elements are always removed from the “front” of\nthe queue.\n• Two operations for enqueuing: add, that throws\nan exception if invoked on a full queue, and\noffer, that returns a boolean value of false if\ninvoked on a full queue.\nQueues in the\nJava Standard Library\n• As with the library Stack, the library Queue was\nsupplanted by the Deque with the release of\nJava 6.0 in 2006\n– it requires operations allowing for additions, deletions,\nand inspections at both ends of the queue\n• There are four library classes that implement the\nDeque\n<eos>"}
{"text": "<bos>\ninterface: ArrayDeque,\nConcurrentLinkedDeque, LinkedBlockingDeque,\nand LinkedList.\n4.8 Application:\nAverage Waiting Time\n• We create a program that simulates a series of\ncustomers arriving for service, entering a queue,\nwaiting, being served, and finally leaving the\nqueue.\n• It tracks the time the customers spend waiting in\nqueues and outputs the average waiting time.\nDefinitions\n• Arrival time: the time a customers arrives\n• Service time: time customer needs\n• Departure time: the time customer leaves\n• Turnaround time: Departure time – Arrival\ntime\n• Wait time: Turnaround time – Service\nTime\nSimple Example\nAnd so on\nSimple Example Results\nProgram Architecture\nSample Run of SimulationCLI\nEnter minimum interarrival time: 0\nEnter maximum interarrival time: 10\nEnter minimum service time: 5\n<eos>"}
{"text": "<bos>\nEnter maximum service time: 20\nEnter number of queues: 2\nEnter number of customers: 2000\nAverage waiting time is 1185.632\nEvaluate another simulation instance? (Y=Yes): y\nEnter number of queues: 3\nEnter number of customers: 2000\nAverage waiting time is 5.7245\nEvaluate another simulation instance? (Y=Yes): n\nProgram completed.\n4.9 Concurrency, Interference, and\nSynchronization\n• Multitask: Perform more than one task at a time\n• Concurrency: Several interacting code\nsequences are executing simultaneously\n– through interleaving of statements by a single\nprocessor\n– through execution on several processors\nCounter\n//-------------------------------------------------------------------------\n// Counter.java by Dale/Joyce/Weems Chapter 4\nClass\n//\n// Tracks the current value of a counter.\n<eos>"}
{"text": "<bos>\n//-------------------------------------------------------------------------\npackage ch04.threads;\npublic class Counter\n{\nprivate int count;\npublic Counter()\n{\ncount = 0;\n}\npublic void increment()\n{\ncount++;\n}\npublic int getCount()\n{\nreturn count;\n}\n}\nDemo One - Basic\npackage ch04.concurrency;\nimport ch04.threads.*;\npublic class Demo01\n{\npublic static void main(String[] args)\n{\nCounter c = new Counter();\nc.increment();\nc.increment();\nc.increment();\nSystem.out.println(\"Count is: \" + c.getCount());\n}\n}\nThe output of the program: Count is: 3\nDemo Two - Threads\npackage ch04.threads; package ch04.concurrency;\npublic class Increase import ch04.threads.*;\nimplements Runnable public class Demo02\n{ {\nprivate Counter c; public static void main(String[] args) throws\nInterruptedException\nprivate int\n<eos>"}
{"text": "<bos>\namount;\n{\npublic Increase (Counter c, int amount)\nCounter c = new Counter();\n{\nRunnable r = new Increase(c, 10000);\nthis.c = c; this.amount = amount;\nThread t = new Thread(r);\n}\nt.start();\nSystem.out.println(\"Count is: \" + c.getCount());\npublic void run()\n}\n{\n}\nfor (int i = 1; i <= amount; i++)\nc.increment();\nOutput Varies: 86, 3024, 457 ????\n}\n}\nDemo Two - Threads\nDemo Three - Join\npackage ch04.threads; package ch04.concurrency;\npublic class Increase import ch04.threads.*;\nimplements Runnable public class Demo03\n{ {\nprivate Counter c; public static void main(String[] args) throws\nInterruptedException\nprivate int amount;\n{\npublic Increase (Counter c, int amount)\nCounter c = new Counter();\n{\nRunnable r = new Increase(c, 10000);\nthis.c = c; this.amount = amount;\nThread t = new Thread(r);\n}\n<eos>"}
{"text": "<bos>\nt.start();\nt.join();\npublic void run()\nSystem.out.println(\"Count is: \" + c.getCount());\n{\n}\nfor (int i = 1; i <= amount; i++)\n} Output is 10000\nc.increment();\n}\n}\nDemo Four - Interference\npackage ch04.threads; package ch04.concurrency;\nimport ch04.threads.*;\npublic class Increase\npublic class Demo04\nimplements Runnable\n{\n{\npublic static void main(String[] args)\nprivate Counter c;\nthrows InterruptedException\nprivate int amount;\n{\npublic Increase (Counter c, int amount) Counter c = new Counter();\n{ Runnable r1 = new Increase(c, 5000);\nRunnable r2 = new Increase(c, 5000);\nthis.c = c; this.amount = amount;\nThread t1 = new Thread(r1);\n}\nThread t2 = new Thread(r2);\nt1.start(); t2.start();\npublic void run()\nt1.join(); t2.join();\n{\nSystem.out.println(\"Count is: \" + c.getCount());\nfor (int i = 1; i\n<eos>"}
{"text": "<bos>\n<= amount; i++) }\nc.increment(); }\nOutput Varies: 9861, 9478 ????\n}\n}\nDemo Four - Interference\nThread t1 Thread t2\nStep 1: obtains value 12\nStep 2: obtains value 12\nStep 3: increments value to 13\nStep 4: stores the value 13\nStep 5: increments value to 13\nStep 6: stores the value 13\nDemo Five - Synchronization\n// SyncCounter.java // The IncreaseSync class is identical to Increase\n// Tracks the current value of a counter.\n// cass except that it accepts a SyncCounter instead\n// Provides synchronized access\n// of Counter as its first parameter\npackage ch04.concurrency;\npackage ch04.threads;\nimport ch04.threads.*;\npublic class SyncCounter\n{ public class Demo05\nprivate int count; {\npublic SyncCounter()\npublic static void main(String[] args) throws\n{\nInterruptedException\ncount = 0;\n{\n}\n<eos>"}
{"text": "<bos>\nSyncCounter sc = new SyncCounter();\nRunnable r1 = new IncreaseSync(sc, 5000);\npublic synchronized void increment()\n{ Runnable r2 = new IncreaseSunc(sc, 5000);\ncount++; Thread t1 = new Thread(r1);\n}\nThread t2 = new Thread(r2);\nt1.start(); t2.start();\nOutput is 10000\npublic int getCount()\nt1.join(); t2.join();\n{\nSystem.out.println(\"Count is: \" + sc.getCount());\nreturn count;\n} }\n} }\nA Synchronized Queue\n• Similarly the synchronized keyword can be\nused to control access to an entire or\nselected parts of a data structure\n• See the subsection “A Synchronized\nQueue”\nOur Queue Architecture\n<eos>"}
{"text": "<bos>\nChapter 5\nThe\nCollection\nADT\nChapter 5: The Collection ADT\n5.1 – The Collection Interface\n5.2 – Array-Based Collections Implementation\n5.3 – Application: Vocabulary Density\n5.4 – Comparing Object Revisited\n5.5 – Sorted Array-Based Collection Implementation\n5.6 – Link-Based Collection Implementation\n5.7 – Collection Variations\n5.1 The Collection Interface\n• Stacks and queues restrict access to data based\non the order in which the data was stored\n• Sometimes we need to retrieve information\nregardless of the order in which it is stored—\ncontent based access—for example obtaining\nstudent information based on an ID number\n• the Collection ADT is the most basic ADT that\nprovides the required functionality\nAssumptions for our Collections\n• Support addition, removal, and retrieval of\nelements\n•\n<eos>"}
{"text": "<bos>\nContent based access is based on equality of\nobjects (using the equals method)\n• Allow duplicate elements, do not allow null\nelements\n• add and remove operations return a boolean\nindicating success\npackage ch05.collections;\npublic interface CollectionInterface<T>\n{\nboolean add(T element);\n// Attempts to add element to this collection. Returns true if successful, false otherwise.\nT get(T target);\n// Returns an element e from this collection such that e.equals(target).\n// If no such element exists, returns null.\nboolean contains(T target);\n// Returns true if this collection contains an element e such that\n// e.equals(target); otherwise returns false.\nboolean remove (T target);\n// Removes an element e from this collection such that e.equals(target)\n// and returns true. If no such element\n<eos>"}
{"text": "<bos>\nexists, returns false.\nboolean isFull();\nboolean isEmpty();\nint size();\n}\n5.2 Array-Based Collection\nImplementation\n• Basic Approach - a collection of N elements is\nheld in the first N locations of an array, locations\n0 to N−1\n• Maintain an instance variable, numElements\nBeginning of class\npackage ch05.collections;\npublic class ArrayCollection<T> implements CollectionInterface<T>\n{\nprotected final int DEFCAP = 100; // default capacity\nprotected T[] elements; // array to hold collection's elements\nprotected int numElements = 0; // number of elements\n// set by find method\nprotected boolean found; // true if target found, otherwise false\nprotected int location; // indicates location of target if found\npublic ArrayCollection()\n{\nelements = (T[]) new Object[DEFCAP];\n}\npublic ArrayCollection(int\n<eos>"}
{"text": "<bos>\ncapacity)\n{\nelements = (T[]) new Object[capacity];\n}\n. . .\nAdding an element\nAdd “COL”\nThe add method\npublic boolean add(T element)\n// Attempts to add element to this collection.\n// Returns true if successful, false otherwise.\n{\nif (isFull())\nreturn false;\nelse\n{\nelements[numElements] = element;\nnumElements++;\nreturn true;\n}\n}\nThe helper find method\n• protected access\n• uses Sequential Search … O(N)\n• sets instance variables found and location\n• simplifies\n– remove\n– contains\n– get\nThe helper find method\nprotected void find(T target)\n{\nlocation = 0;\nfound = false;\nwhile (location < numElements)\n{\nif (elements[location].equals(target))\n{\nfound = true;\nreturn;\n}\nelse\nlocation++;\n}\n}\nRemoving an element\nRemove “MEX”\nThe remove method\npublic boolean remove (T target)\n// Removes an element e\n<eos>"}
{"text": "<bos>\nfrom this collection\n// such that e.equals(target) and returns true;\n// if no such element exists, returns false.\n{\nfind(target);\nif (found)\n{\nelements[location] = elements[numElements - 1];\nelements[numElements - 1] = null;\nnumElements--;\n}\nreturn found;\n}\nThe contains and get methods\npublic boolean contains (T target)\n{\nfind(target);\nreturn found;\n}\npublic T get(T target)\n{\nfind(target);\nif (found)\nreturn elements[location];\nelse\nreturn null;\n}\n5.3 Application: Vocabulary Density\n• The vocabulary density of a text is the total\nnumber of words in the text divided by the\nnumber of unique words in the text.\n• Used by computational linguists to help analyze\ntexts.\n• We define a word to be a sequence of letter\ncharacters (A through Z) plus the apostrophe\ncharacter ( ’ ).\nVocabulary Density\n<eos>"}
{"text": "<bos>\nCalculation\nInitialize variables and objects\nwhile there are more words to process\nGet the next word\nif the collection does not contain the word\nAdd the word to the collection\nIncrement total number of words\nDisplay (total number words/size of the collection)\nThe application\n• Instructors can now review the application,\nVocabularyDensity, found in the ch05.apps\npackage, plus the notes on pages 307-308.\n• The code is short and simple—this is because\nso much of the complexity is handled by the\nArrayCollection class. This is a good\nexample of the power and utility of abstraction.\n5.4 Comparing Objects Revisited\n• Collection operations require comparing\nobjects for equality\n• Section 5.5 “Sorted Array-Based\nCollection Implementation” requires\ncomparing objects for order\n• This section reviews\n<eos>"}
{"text": "<bos>\nthe equals and\ncompareTo operations\nUsing the comparison (==) operator\nUsing the equals method\n• Since equals is exported from the Object\nclass it can be used with objects of any Java\nclass.\n• For example, If c1 and c2 are objects of the\nclass Circle, then we can compare them using\nc1.equals(c2)\n• But this method, as defined in the Object class,\nacts much the same as the comparison\noperator. It returns true if and only if the two\nvariables reference the same object.\n• However, we can redefine the equals method\nto fit the goals of the class.\nDefining an equals method\n• A reasonable definition for equality of Circle objects is that they are equal if\nthey have equal radii.\n• To realize this approach we define the equals method of our Circle class\nto use the radius attribute:\n@Override\npublic\n<eos>"}
{"text": "<bos>\nboolean equals(Object obj)\n{\nif (obj == this)\nreturn true;\nelse\nif (obj == null || obj.getClass() != this.getClass())\nreturn false;\nelse\n{\nCircle c = (Circle) obj;\nreturn (this.radius == c.radius);\n}\n}\nThe FamousPerson class\n• A famous person object has attributes\nrepresenting name (first name and last name),\nthe year they were born, and some short\ninteresting fact about the person\n• The class is in the support package\n• It exports getters plus equals, compareTo, and\ntoString methods.\nThe equals method\n@Override\npublic boolean equals(Object obj)\n{\nif (obj == this)\nreturn true;\nelse\nif (obj == null || obj.getClass() != this.getClass())\nreturn false;\nelse\n{\nFamousPerson fp = (FamousPerson) obj;\nreturn (this.firstName.equals(fp.firstName) &&\nthis.lastName.equals(fp.lastName));\n}\n}\nIdentifying\n<eos>"}
{"text": "<bos>\nobjects\n• Objects are identified by their “key”.\n• The key of a class, from the point of view of an\napplication, is the set of attributes that are used\nto determine the identity of an object of the\nclass, for that application.\n• For example\n– the key of a Circle object is its radius attribute\n– the key of a FamousPerson object is the combination\nof its firstName and lastName attributes\nRetrieving objects based on their key\n• Note that two objects can be equal although they\nare not identical\n• Keys form the basis of retrieval\n• Stored: Requested:\nfirstName: Ada firstName: Ada\nlastName: Lovelace lastName: Lovelace\nyearOfBirth: 1815 yearOfBirth: 0\nfact: first programmer fact:\n• Instructors can review and demonstrate the\nCSInfo application found in the\nch05.applications package\nOrdering\n<eos>"}
{"text": "<bos>\nobjects\n• In addition to checking objects for equality, there\nis another type of comparison we need.\n• To support a sorted collection we need to be\nable to tell when one object is less than, equal\nto, or greater than another object.\n• The Java library provides an interface, called\nComparable, which can be used to ensure that\na class provides this functionality.\nThe Comparable Interface\n• The Comparable interface consists of exactly one\nabstract method:\npublic int compareTo(T o);\n// Returns a negative integer, zero, or a positive\n// integer as this object is less than, equal to,\n// or greater than the specified object.\n• The compareTo method returns an integer value that\nindicates the relative \"size\" relationship between the\nobject upon which the method is invoked and the object\npassed to\n<eos>"}
{"text": "<bos>\nthe method as an argument.\nA compareTo Example\npublic int compareTo(FamousPerson other)\n// Precondition: 'other' is not null\n//\n// Compares this FamousPerson with 'other' for order. Returns a\n// negative integer, zero, or a positive integer as this object\n// is less than, equal to, or greater than 'other'.\n{\nif (!this.lastName.equals(other.lastName))\nreturn this.lastName.compareTo(other.lastName);\nelse\nreturn this.firstName.compareTo(other.firstName);\n}\n• This compareTo method uses the compareTo method of the String class.\n• Note that the equals method and the compareTo method of our Circle\nclass are compatible with each other.\n• By convention the compareTo method of a class should support the standard\norder of a class. We call the order established by a class compareTo method\nthe natural\n<eos>"}
{"text": "<bos>\norder of the class.\n5.5 Sorted Array-Based Collection\nImplementation\n• The ArrayCollection class features fast add\n(O(1)) but slow get, contains, and remove\n(O(N))\n• Many applications require fast retrieval (get and\ncontains) as they access the collection\nrepeatedly to obtain information\n• A sorted array approach permits use of the\nBinary Search for find, therefore speeding up\nboth get and contains\nComparable Elements\n• We will use the compareTo method of the\nelement class to keep underlying array sorted\n• We specify as a precondition of the add method\nthat its argument is comparable to the previous\nobjects added to the collection.\nThe SortedArrayCollection\nclass\n• Similar to ArrayCollection class but …\n• Unbounded (uses a protected enlarge method)\n• the find method uses the Binary Search\n<eos>"}
{"text": "<bos>\nalgorithm\n– cast elements as Comparable (some compilers may\ngenerate a warning)\n• add and remove must preserve the underlying\norder of the array (see next slide)\nThe add and remove operations\nadd “BOL”\nremove “BOL”\nSample\nApplication\nResults\nImplementing ADTs “by Copy” or\n“by Reference”\n• When designing an ADT we have a choice about\nhow to handle the elements—“by copy” or “by\nreference.”\n– By Copy: The ADT manipulates copies of the data\nused in the client program. Making a valid copy of an\nobject can be a complicated process.\n– By Reference: The ADT manipulates references to\nthe actual elements passed to it by the client\nprogram. This is the most commonly used approach\nand is the approach we use throughout this textbook.\n“By Copy” Notes\n• Valid copies of an object are typically created\n<eos>"}
{"text": "<bos>\nusing the object's clone method.\n• Classes that provide a clone method must\nindicate this to the runtime system by\nimplementing the Cloneable interface.\n• Drawbacks:\n– Copy of object might not reflect up-to-date status of\noriginal object\n– Copying objects takes time, especially if the objects\nare large and require complicated deep-copying\nmethods.\n– Storing extra copies of objects also requires extra\nmemory.\n“By Reference” Notes\n• Because the client program retains a reference to the\nelement, we say we have exposed the contents of the\ncollection ADT to the client program.\n• The ADT allows direct access to the individual elements\nof the collection by the client program through the client\nprogram’s own references.\n• Drawbacks:\n– We create aliases of our elements, therefore we must deal with\n<eos>"}
{"text": "<bos>\nthe potential problems associated with aliases.\n– This situation is especially dangerous if the client program can\nuse an alias to change an attribute of an element that is used by\nthe ADT to determine the underlying organization of the\nelements – for example if it changes the key value for an\nelement stored in a sorted list.\nAn Example\n• The next three slides show the results of a\nsequence of operations when each of the two\napproaches is used to store a sorted list:\n– We have three objects that hold a person’s name and\nweight (Slide 1)\n– We add the three objects onto a list that sorts objects\nby the variable weight\n– We transform one of the original objects with a diet\nmethod, that changes the weight of the object\nExample Step 1: The Three Objects\nBy Copy Approach By Reference Approach\n<eos>"}
{"text": "<bos>\nExample Step 2: Add Objects to List\nBy Copy Approach By Reference Approach\nExample Step 3: S1.diet(-105)\nBy Copy Approach By Reference Approach\nProblem: List copy is out of date Problem: List is no longer sorted\nWhich approach is better?\n• That depends.\n• If processing time and space are issues, and if we are\ncomfortable counting on the application programs to\nbehave properly, then the “by reference” approach is\nprobably best.\n• If we are not too concerned about time and space\n(maybe our list objects are not too large), but we are\nconcerned with maintaining careful control over the\naccess to and integrity of our lists, then the “by copy”\napproach is probably best.\n• The suitability of either approach depends on what the\nlist is used for.\n5.6 Link-Based Collection\nImplementation\n• Internal\n<eos>"}
{"text": "<bos>\nrepresentation: unsorted linked list\n• Reuses design/code from previous classes\n• Code is in the ch05.collections package\n• The find method sets the boolean found plus\ntwo “pointers” if element is found: previous\nand location\n• The next slide lists array-based and link-based\nfind side-by-side for comparison\nArray-Based Link-Based\nprotected void find(T target) protected void find(T target)\n{ {\nlocation = 0; location = head;\nfound = false; found = false;\nwhile (location < numElements) while (location != null)\n{ {\nif elements[location].equals(target)) if (location.getInfo().equals(target))\n{ {\nfound = true; found = true;\nreturn; return;\n} }\nelse else\nlocation++; {\n} previous = location;\n} location = location.getLink();\n}\n}\n}\nRemoving an element\npublic boolean remove (T target)\n{\nfind(target);\n<eos>"}
{"text": "<bos>\nif (found)\n{\nif (head == location)\nhead = head.getLink(); // remove first node\nelse\nprevious.setLink(location.getLink()); // remove node at location\nnumElements--;\n}\nreturn found;\n}\nOur Collection Architecture\nComparing Collection\nImplementations\n5.7 Collection Variations\n• The Collection ADT offers simple but crucial\nfunctionality–the ability to store and retrieve information.\n• This functionality sits at the heart of information\nprocessing.\n• Data structures, file systems, memory/storage,\ndatabases, the Cloud, the Internet all involve, at their\ncore, storing and retrieving information.\n• There are many variations of collections, including the\nlists, search trees, maps, hash tables, and priority\nqueues we study in the upcoming chapters\nThe Java Collections Framework\n• The Java library\n<eos>"}
{"text": "<bos>\nprovides a robust collections\nframework\n• At the center of the framework is the\nCollection interface, found in the java.util\npackage of the library. This interface supports 11\nsubinterfaces including Deque, List, and Set\nand has 33 implementing classes\n• If you are interested in learning more about the\nJava Collections Framework, reference the\nextensive documentation available at Oracle’s\nwebsite.\nThe Bag ADT\n• On pages 332 and 333 we define a\nBagInterface that extends\nCollectionInterface with the additional\nmethods grab, count, removeAll and clear\n• Implementation is left as an exercise\nThe BagInterface\npackage ch05.collections;\npublic interface BagInterface<T> extends CollectionInterface\n{\nT grab();\n// If this bag is not empty, removes and returns a random\n// element of the bag;\n<eos>"}
{"text": "<bos>\notherwise returns null.\nint count(T target);\n// Returns a count of all elements e in this collection\n// such that e.equals(target).\nint removeAll(T target);\n// Removes all elements e from this collection such that\n// e.equals(target) and returns the number of elements removed.\nvoid clear();\n// Empties this bag so that it contains zero elements.\n}\nThe Set ADT\n• Our collection ADTs allow duplicate elements. If\nwe disallow duplicate elements, we have a\ncollection commonly known as a Set.\n• The Set ADT models the mathematical set that\nis typically defined as a collection of distinct\nobjects.\nSet ADT Implementations\n• We can implement a Set class by copying and\nchanging the code from one of our collection\nimplementations—the only method we need to\nchange is the add method.\n• The new add method\n<eos>"}
{"text": "<bos>\ncould be designed to\ncheck if the element argument is not already in\nthe collection, and if not it would add the element\nand return true.\n• Otherwise, of course, it returns false.\nSet ADT Implementations\n• We can also implement a Set class by\nextending a previous class and overwriting add\n– See BasicSet1 of the ch05.collections\npackage, which extends the LinkedCollection\nclass\n• We can also implement a Set class by wrapping\na previous class and re-writing add\n– See BasicSet2 of the ch05.collections\npackage, which wraps an object of the\nLinkedCollection class.\n<eos>"}
{"text": "<bos>\nChapter 6\nThe List\nADT\nChapter 6: The List ADT\n6.1 – The List Interface\n6.2 – List Implementations\n6.3 – Applications: Card Deck and Games\n6.4 – Sorted Array-Based List Implementation\n6.5 – List Variations\n6.6 – Application: Large Integers\n6.1 – The List Interface\n• A list is a collection of elements, with a linear\nrelationship existing among its elements.\n• Each element on the list has a position on the\nlist, its index.\n• In addition to our lists supporting the standard\ncollection operations add, get, contains, remove,\nisFull, isEmpty, and size, they support index-\nrelated operations and iteration.\nIndexes\n• The elements of a list are indexed sequentially,\nfrom zero to one less than the size of the list\n• We define methods for adding, retrieving,\nchanging, and removing an element at an\n<eos>"}
{"text": "<bos>\nindicated index, as well as a method for\ndetermining the index of an element.\n• Each method that accepts an index as an\nargument throws an exception\n(IndexOutOfBoundsException) if the index\nis invalid\nFor example\nvoid add(int index, T element);\n// Throws IndexOutOfBoundsException if passed an index argument\n// such that index < 0 or index > size().\n// Otherwise, adds element to this list at position index; all current\n// elements at that position or higher have 1 added to their index.\n// Optional. Throws UnsupportedOperationException if not supported.\nT set(int index, T newElement);\n// Throws IndexOutOfBoundsException if passed an index argument\n// such that index < 0 or index >= size().\n// Otherwise, replaces element on this list at position index with\n// newElement and returns the\n<eos>"}
{"text": "<bos>\nreplaced element.\n// Optional. Throws UnsupportedOperationException if not supported.\nOptional Operations\n• The add and set operations are optional.\n• These operations allow the client to insert an\nelement into a list at a specified index and for\nsome list implementations, notably a sorted list\nimplementation, this could invalidate the internal\nrepresentation of the list.\n• Our implementations will throw the Java library\nsupplied UnsupportedOperationException\nin cases where an implementation does not\nsupport an operation.\nIteration\n• Our lists implement the library’s Iterable\ninterface.\n• Iterable requires a single method, iterator,\nthat creates and returns an Iterator object.\n• Methods that create and return objects are\nsometimes called Factory methods.\n• Iterator objects provide three\n<eos>"}
{"text": "<bos>\noperations:\nhasNext, next, and remove.\nExample use of an Iterator\nSuppose strings is a List ADT object that contains the four strings “alpha,”\n“gamma,” “beta,” and “delta.” The following code would delete “gamma”\nfrom the list and display the other three strings.\nIterator<String> iter = strings.iterator();\nString hold;\nwhile (iter.hasNext())\n{\nhold = iter.next();\nif (hold.equals(\"gamma\"))\niter.remove();\nelse\nSystem.out.println(hold);\n}\nListInterface\n(comments removed)\npackage ch06.lists;\nimport java.util.*;\nimport ch05.collections.CollectionInterface;\npublic interface ListInterface<T> extends CollectionInterface<T>,\nIterable<T>\n{\nvoid add(int index, T element);\nT set(int index, T newElement);\nT get(int index);\nint indexOf(T target);\nT remove(int index);\n}\n6.2 List Implementations\n• In this\n<eos>"}
{"text": "<bos>\nsection we develop an array-based and a\nlink-based implementation of the List ADT.\n• Because a list is a collection the mplementations\nshare some design and code with their\nCollection ADT counterparts.\n• Here we emphasize the new functionality—the\nindexing and the iteration\nArray-Based Implementation\n• Same approach for our array-based list:\n• … except must maintain index “order” of\nelements during operations:\nIndex Related Operations\n• The methods each follow the same pattern:\n– check the index argument\n– if it is outside the allowable range for that operation\nthrow an exception\n– otherwise carry out the operation.\n• Because of the close logical relationship\nbetween the internal representation, an array,\nand the ADT, an indexed list, the implementation\nof these operations is very\n<eos>"}
{"text": "<bos>\nstraightforward.\nFor example, the set method\npublic T set(int index, T newElement)\n// Throws IndexOutOfBoundsException if passed an index argument\n// such that index < 0 or index >= size().\n// Otherwise, replaces element on this list at position index with\n// newElement and returns the replaced element.\n{\nif ((index < 0) || (index >= size()))\nthrow new IndexOutOfBoundsException(\"Illegal index of \" + index +\n\" passed to ABList set method.\\n\");\nT hold = elements[index];\nelements[index] = newElement;\nreturn hold;\n}\nIteration\n• We use an anonymous inner class approach\n• Anonymous class has no name .. it is just\ninstantiated where needed\n• The behavior of an iterator is unspecified if the\nunderlying representation is modified while the\niteration is in progress in any way other than by\ncalling\n<eos>"}
{"text": "<bos>\nthe iterator’s remove method\npublic Iterator<T> iterator()\n{\nreturn new Iterator<T>()\n{\nprivate int previousPos = -1;\npublic boolean hasNext()\n{\nreturn (previousPos < (size() - 1)) ;\n}\npublic T next()\n{\nif (!hasNext())\nthrow new IndexOutOfBoundsException(\"Illegal invocation of next \" +\n\" in LBList iterator.\\n\");\npreviousPos++;\nreturn elements[previousPos];\n}\npublic void remove()\n{\nfor (int i = previousPos; i <= numElements - 2; i++)\nelements [i] = elements[i+1];\nelements [numElements - 1] = null;\nnumElements--;\npreviousPos--;\n}\n};\n}\nLink-Based Implementation\n• Some of the link-based collection implementation\ndesign and code can be reused for the link-based\nlist.\n• To support the add method, which adds elements\nto the end of the list, we maintain a new\nreference rear to the end of the list.\n<eos>"}
{"text": "<bos>\n• To support the indexOf method we include a\nnew targetIndex variable, which the find\nmethod sets, in addition to setting found,\nlocation, and previous.\nExample Index Related Operation\npublic T set(int index, T newElement\n// Throws IndexOutOfBoundsException if passed an index argument\n// such that index < 0 or index >= size().\n// Otherwise, replaces element on this list at position index with\n// newElement and returns the replaced element.\n{\nif ((index < 0) || (index >= size()))\nthrow new IndexOutOfBoundsException(\"Illegal index of \" + index +\n\" passed to LBList set method.\\n\");\nLLNode<T> node = front;\nfor (int i = 0; i < index; i++)\nnode = node.getLink();\nT hold = node.getInfo();\nnode.setInfo(newElement);\nreturn hold;\n}\nIteration\n• Again use an anonymous inner class within the\niterator\n<eos>"}
{"text": "<bos>\nmethod.\n• The instantiated Iterator object keeps track of\nthree instance variables to provide the iteration\nand to support the required remove operation:\n• The next method returns the element\nreferenced by nextPos and updates the three\nreferences\nIteration\n• If remove invoked in the middle of an iteration it\nremoves the element that was just returned, the\nelement referenced by currPos:\n6.3 Applications:\nCard Deck and Games\nThe Card class\n• Found in the support.cards package\n• A card object has three attributes:\n– rank: the rank of the card e.g. Five or King\n– suit: the suit of the card e.g. Heart or Spade\n– image: an image icon associated with the card\n• rank and suit are both represented by public\nenum classes provided by the Card class\n• The image files used for the image icons are\nalso\n<eos>"}
{"text": "<bos>\nlocated in the support.cards package\n• Attribute getter methods are provided plus an\nequals, a compareTo and a toString\nThe CardDeck class\n• Uses an ABList of Card objects named deck as\nits internal representation\n• Another instance variable, deal, which holds an\nIterator<Card> object, is used to deal cards\n• deal is set to deck.iterator()\n• Exports methods for shuffling the deck and\niterating through the deck\nApplications\n• CardHandCLI – command line interface\nprogram which deals a 5 card hand from a card\ndeck, allowing the user to arrange the cards\n• CardHandGUI – graphical user interface\nprogram which deals a 5 card hand from a card\ndeck, allowing the user to arrange the cards\n• HigherLower – Predict whether the next card\nwill be higher or lower\n• Pairs – Analyzes the probability of\n<eos>"}
{"text": "<bos>\nbeing dealt\na pair in a 5 card hand\n6.4 Sorted Array-Based List\nImplementation\n• Class SortedABList implements\nListInterface and is found in the\nch06.lists package\n• Much of the design and code of the\nSortedArrayCollection from the\nch05.collections package can be reused.\n• We state as a general precondition of the class\nthat the index-based add and set operations\nare not supported.\nCode for the two unsupported\nmethods\npublic void add(int index, T element)\n// Throws UnsupportedOperationException.\n{\nthrow new UnsupportedOperationException(\"Unsupported index-based add …\n}\npublic T set(int index, T newElement)\n// Throws UnsupportedOperationException.\n{\nthrow new UnsupportedOperationException(\"Unsupported index-based set …\n}\nComparator Interface\n• We want to allow clients of our SortedABList\nto\n<eos>"}
{"text": "<bos>\nbe able to specify for themselves how the\nelements should be sorted\n• The Java Comparator interface defines two\nabstract methods:\npublic abstract int compare(T o1, T o2);\n// Returns a negative integer, zero, or a positive integer to indicate that\n// o1 is less than, equal to, or greater than o2\npublic abstract boolean equals(Object obj);\n// Returns true if this Comparator equals obj; otherwise, false\n• Using an approach based on the Comparator\nclass allows for multiple sorting orders\nComparator Interface\n• Using an approach based on the Comparator\nclass allows for multiple sorting orders\n• For example our FamousPerson class typically\nbases comparison on last name, first name but it\ncould also define other approaches:\npublic static Comparator<FamousPerson> yearOfBirthComparator()\n{\nreturn\n<eos>"}
{"text": "<bos>\nnew Comparator<FamousPerson>()\n{\npublic int compare(FamousPerson element1, FamousPerson element2)\n{\nreturn (element1.yearOfBirth - element2.yearOfBirth);\n}\n};\n}\nSortedABList Constructors\n• There are two constructors\n• One uses the “natural order” of the elements\n• The other uses an order provided by the client\nwho passes an appropriate Comparator object\nas an argument to the method\n• A private variable comp of class\nComparator<T> is used to make comparisons\ninternally and is set by the invoked constructor\nSortedABList Constructors\nprotected Comparator<T> comp;\npublic SortedABList()\n// Precondition: T implements Comparable\n{\nlist = (T[]) new Object[DEFCAP];\ncomp = new Comparator<T>()\n{\npublic int compare(T element1, T element2)\n{\nreturn ((Comparable)element1).compareTo(element2);\n}\n};\n}\n<eos>"}
{"text": "<bos>\npublic SortedABList(Comparator<T> comp)\n{\nlist = (T[]) new Object[DEFCAP];\nthis.comp = comp;\n}\nOur List\nADT\nArchitecture\n6.5 List Variations\n• Java Library\n– The library provides a List interface that inherits\nfrom both the Collection and Iterable interfaces\nof the library.\n– The library’s list interface is significantly more\ncomplex than ours, defining 28 abstract methods.\n– It is implemented by the following classes:\nAbstractList, AbstractSequentialList,\nArrayList, AttributeList,\nCopyOnWriteArrayList, LinkedList,\nRoleList, RoleUnresolvedList, Stack, and\nVector.\nLinked List Variations\nA Linked List as an Array of Nodes\nWhy Use an Array?\n• Sometimes managing the free space\nourselves gives us greater flexibility\n• There are programming languages that do\nnot support dynamic allocation or\n<eos>"}
{"text": "<bos>\nreference types\n• There are times when dynamic allocation\nof each node, one at a time, is too costly in\nterms of time\nBoundedness\n• A desire for static allocation is one of the primary\nmotivations for the array-based linked approach\n• We drop our assumption that our lists are of\nunlimited size in this section - our lists will not\ngrow as needed.\n• Applications should not add elements to a full\nlist.\nA\nsorted\nlist\nImplementation Issues\n• We mark the end of the list with a “null” value\n– the “null” value must be an invalid address for a real list element\n– we use the value –1\n– we suggest using the identifier NUL and defining it to be -1\nprivate static final int NUL = –1;\n• One must directly manage the free space available for\nnew list elements.\n– Link the collection of unused array elements\n<eos>"}
{"text": "<bos>\ntogether into a\nlinked list of free nodes.\n– Write your own method to allocate nodes from the free space.\nWe suggest calling this method getNode.\n– Write your own method, we suggest calling it freeNode, to put a\nnode back into the pool of free space when it is de-allocated.\nA linked\nlist and\nfree\nspace\n6.6 Application: Large Integers\n• The largest Java integer type, long, can\nrepresent values between\n−9,223,372,036,854,775,808 and\n9,223,372,036,854,775,807\n• Believe it or not, for some applications that may\nnot be sufficient\n• A linked list of digits can grow to be any size,\nand thus can be used to represent integers of\nany size\nRepresenting large integers with\nlinked lists\nThe LargeInt class\n• Constructors – one that creates an “empty” integer and\none that creates an integer based on a\n<eos>"}
{"text": "<bos>\nString\nargument\n• setNegative – makes the large integer negative\n• toString – returns string representation\n• add – returns the sum of two large integers\n• subtract – returns the difference of two large integers\n• To support the creation and arithmetic manipulation of\nlarge integers we define a special list class …\nThe LargeIntList class\n• a list of byte (to hold digits)\n• provide operations size, addFront, addEnd,\nand both forward and reverse iterators\n• To support these requirements we use a\nreference-based doubly linked structure\nApplications\n• LargeIntCLI - in the ch06.apps package,\nallows the user to enter two large integers,\nperforms the addition and subtraction of the two\nintegers, and reports the results.\n• LargeIntGUI - in the ch06.apps package:\nCode and Demo\n• Instructors can now\n<eos>"}
{"text": "<bos>\nreview the algorithms,\nwalk through the code for the classes, and\ndemonstrate the running applications.\nImportant Concept Revisited:\nAbstraction Hierarchy\n• Here we saw another example of an abstraction\nhierarchy.\n• Applications use the LargeInt class, which uses the\nLargeIntList class, which uses the DLLNode class.\n• When working at any level in this hierarchy as a\nprogrammer we need to know only how to use the next\nlower level – we do not need to know how it is\nimplemented nor need we worry about the details of\nlower levels.\n• Abstraction is indeed the key to conquering complexity.\n<eos>"}
{"text": "<bos>\nChapter 7\nThe Binary\nSearch\nTree ADT\nChapter 7: The Binary Search\nTree ADT\n7.1 – Trees\n7.2 – Binary Search Trees\n7.3 – The Binary Search Tree Interface\n7.4 – The Implementation Level: Basics\n7.5 – Iterative Versus Recursive Method Implementations\n7.6 – The Implementation Level: Remaining Observers\n7.7 – The Implementation Level: Transformers\n7.8 – Binary Search Tree Performance\n7.9 – Application: Word Frequency Counter\n7.10 – Tree Variations\nBinary Search Tree\n• When maintaining a sorted list\n– Linked List requires O(N) find location, O(1) insertion\n– Array requires O(log N) find location, O(N) insertion\n2\n– Binary Search Tree, in general allows O(log N) find\n2\nlocation , O(1) insertion\n7.1 Trees\n• A tree is a nonlinear\nstructure in which\neach node is capable\nof having many\nsuccessor\n<eos>"}
{"text": "<bos>\nnodes,\ncalled children.\n• Trees are useful for\nrepresenting lots of\nvaried relationships\namong data items.\nDefinitions\n• Tree A structure with a unique starting node\n(the root), in which each node is capable of\nhaving multiple successor nodes (its children),\nand in which a unique path exists from the root\nto every other node.\n• Root The top node of a tree structure; a node\nwith no parent\n• Parent node The predecessor node of a node\nis its parent\n• Subtree A node and all of its descendants form\na subtree rooted at the node\nExamples\n• The root is A\n• The children of A are B,\nF, and X\n• The parent of Q is X\n• The leftmost subtree of\nX contains H and P\nRequired\n• A tree’s subtrees\nmust be disjoint\n• There is a unique\npath from the root\nof a tree to any\nother node of the\ntree\nNot a Tree →\n<eos>"}
{"text": "<bos>\nDefinitions\n• Ancestor A parent of a node, or a parent of an\nancestor\n• Descendant A child of a node, or a child of a\ndescendant\n• Leaf A node that has no children\n• Interior node A node that is not a leaf\n• Siblings Nodes with the same parent\nExamples\n• The ancestors of P are\nH, X, and A\n• The descendants of X\nare H, Q, Z, and P\n• The leaf nodes are C,\nT, F, P, Q, and Z\n• The interior nodes are\nA, B, X\n• The siblings of B are F\nand X\nDefinitions\n• Level The level of a node is its distance from the\nroot (the number of connections between itself\nand the root)\n• Height The maximum level of the tree\nExamples\n• The level of A is 0\n• The level of P is 3\n• The height of the\ntree is 3\nBreadth-First Traversal\n• Also called “level-order traversal”\n• A B F X C T H Q Z P\nBreadth-First Traversal(root)\n<eos>"}
{"text": "<bos>\nInstantiate a queue of nodes\nif (root is not null)\n{\nqueue.enqueue(root)\nwhile (!queue.isEmpty())\n{\nnode = queue.dequeue()\nTry It!\nVisit node\nEnqueue the children of node\n(from left to right) into queue\n}\n}\nDepth-First Traversal\n• A B C T F X H P Q Z\nDepth-First Traversal(root)\nInstantiate a stack of nodes\nif (root is not null)\n{\nstack.push(root)\nwhile (!stack.isEmpty())\n{\nnode = stack.top()\nTry It!\nstack.pop()\nVisit node\nPush the children of node\n(from right to left) onto queue\n}\n}\n7.2 Binary Search Trees\n• Binary tree A\ntree in which\neach node is\ncapable of having\ntwo child nodes,\na left child node\nand a right child\nnode\nA Binary Tree\nA Binary\nSearch\nTree\nThese trees facilitate\nsearching for an\nelement.\nBinary search tree\n• A binary tree in which the key\nvalue in any node\n– is greater\n<eos>"}
{"text": "<bos>\nthan or equal to the\nkey value in its left child and any\nof its descendants (the nodes in\nthe left subtree)\n– is less than the key value in its\nright child and any of its\ndescendants (the nodes in the\nright subtree)\n• We call this the “binary\nsearch tree” property\nBinary Tree Traversals\n• Preorder traversal: Visit the\nroot, visit the left subtree, visit\nthe right subtree:\n– D B A C F G\n• Inorder traversal: Visit the left\nsubtree, visit the root, visit the\nright subtree:\n– A B C D F G\n• Postorder traversal: Visit the\nleft subtree, visit the right\nsubtree, visit the root:\n– A C B G F D\nVisualizing Binary Tree Traversals\nThree\nBinary Tree\nTraversals\n7.3 – The Binary Search Tree\nInterface\n• Our binary search trees\n– are similar to the sorted lists of Chapter 6\n– implement this text’s\n<eos>"}
{"text": "<bos>\nCollectionInterface\n– implement the Java Library’s Iterable interface\n– are unbounded, allow duplicate elements, and\ndisallow null elements\n– support max and min operations\n– support preorder, inorder, and postorder traversals\npackage ch07.trees;\nimport ch05.collections.CollectionInterface;\nimport java.util.Iterator;\npublic interface BSTInterface<T> extends CollectionInterface<T>,\nIterable<T>\n{\n// Used to specify traversal order.\npublic enum Traversal {Inorder, Preorder, Postorder};\nT min();\n// If this BST is empty, returns null;\n// otherwise returns the smallest element of the tree.\nT max();\n// If this BST is empty, returns null;\n// otherwise returns the largest element of the tree.\npublic Iterator<T> getIterator(Traversal orderType);\n// Creates and returns an Iterator providing a\n<eos>"}
{"text": "<bos>\ntraversal of a \"snapshot“\n// of the current tree in the order indicated by the argument.\n}\nIteration\n• In addition to the getIterator method, a class that\nimplements the BSTInterface must provide a\nseparate iterator method, because\nBSTInterface extends Iterable.\n• This method should return an Iterator that\nprovides iteration in the “natural” order of the\ntree elements.\n• For most applications this would be an inorder\ntraversal, and we make that assumption in our\nimplementation.\nIteration\n• We intend the iterators created and returned by\ngetIterator and iterator to provide a\nsnapshot of the tree as it exists at the time the\niterator is requested.\n• They represent the state of the tree at that time\nand subsequent changes to the tree should not\naffect the results returned by the iterator’s\n<eos>"}
{"text": "<bos>\nhasNext and next methods.\n• Our iterators will throw an\nUnsupportedOperationException if\nremove is invoked.\nExample Application\n• Instructors can review and demonstrate the\napplication BSTExample found in the\nch07.apps package\n• This application demonstrates the use of\niterators with our binary search tree\n7.4 The Implementation Level:\nBasics\n• We define BSTNode.java in our support\npackage to provide nodes for our binary search\ntrees\n• Visually, a BSTNode object is:\nBSTNode.java\ninstance variables:\nprivate T info; // The info in a BST node\nprivate BSTNode<T> left; // A link to the left child node\nprivate BSTNode<T> right; // A link to the right child node\nConstructor:\npublic BSTNode(T info)\n{\nthis.info = info;\nleft = null;\nright = null;\n}\nPlus it includes the standard setters and getters\n<eos>"}
{"text": "<bos>\nBeginning of\nBinarySearchTree.java\npackage ch07.trees;\nimport java.util.*; // Iterator, Comparator\nimport ch04.queues.*;\nimport ch02.stacks.*;\nimport support.BSTNode;\npublic class BinarySearchTree<T> implements BSTInterface<T>\n{\nprotected BSTNode<T> root; // reference to the root of this BST\nprotected Comparator<T> comp; // used for all comparisons\nprotected boolean found; // used by remove\n. . .\nThe Constructors\npublic BinarySearchTree()\n// Precondition: T implements Comparable\n// Creates an empty BST object - uses the natural order of elements.\n{\nroot = null;\ncomp = new Comparator<T>()\n{\npublic int compare(T element1, T element2)\n{\nreturn ((Comparable)element1).compareTo(element2);\n}\n};\n}\npublic BinarySearchTree(Comparator<T> comp)\n// Creates an empty BST object - uses Comparator comp\n<eos>"}
{"text": "<bos>\nfor order of elements.\n{\nroot = null;\nthis.comp = comp;\n}\n. . .\nExample Observer methods\npublic boolean isFull()\n// Returns false; this link-based BST is never full.\n{\nreturn false;\n}\npublic boolean isEmpty()\n// Returns true if this BST is empty; otherwise, returns false.\n{\nreturn (root == null);\n}\npublic T min()\n// If this BST is empty, returns null;\n// otherwise returns the smallest element of the tree.\n{\nif (isEmpty())\nreturn null;\nelse\n{\nBSTNode<T> node = root;\nwhile (node.getLeft() != null)\nnode = node.getLeft();\nreturn node.getInfo();\n}\n}\n7.5 Iterative versus Recursive\nMethod Invocations\n• Trees are inherently recursive; a tree consists of\nsubtrees\n• In this section we look at recursive and iterative\napproaches to the size method\n• We then discuss the benefits of recursion versus\n<eos>"}
{"text": "<bos>\niteration for this problem\nRecursive Approach\n• We create a public method, size, that calls a private recursive\nmethod, recSize and passes it a reference to the root of the tree.\npublic int size()\n// Returns the number of elements in this BST.\n{\nreturn recSize(root);\n}\n• We design the recSize method to return the number of nodes in\nthe subtree referenced by the argument passed to it.\n• Note that the number of nodes in a tree is:\n1 + number of nodes in left subtree + number of nodes in right subtree\nrecSize Algorithm\nVersion 1\nrecSize(node): returns int\nif (node.getLeft( ) is null) AND (node.getRight( ) is null)\nreturn 1\nelse\nreturn 1 + recSize(node.getLeft( )) + recSize(node.getRight( ))\n• The corresponding method would crash when we try\nto access node.getLeft when node is null.\nrecSize\n<eos>"}
{"text": "<bos>\nAlgorithm\nVersion 2\nrecSize(node): returns int Version 2\nif (node is null)\nreturn 0\nelse\nif (node.getLeft() is null) AND (node.getRight() is null)\nreturn 1\nelse\nreturn 1 + recSize(node.getLeft()) + recSize(node.getRight())\n• Works, but can be simplified. There is no need to\nmake the leaf node a special case – it would also be\nhandled properly by the final else clause\nrecSize Algorithm\nVersion 3\nrecSize(node): returns int Version 3\nif node is null\nreturn 0\nelse\nreturn 1 + recSize(node.getLeft( )) + recSize(node.getRight( ))\n• Works and is “simple”.\n• This example illustrates two important points about\nrecursion with trees:\n– always check for the empty tree first\n– leaf nodes do not need to be treated as separate cases.\nThe recSize Code\nprivate int recSize(BSTNode<T> node)\n// Returns the\n<eos>"}
{"text": "<bos>\nnumber of elements in subtree rooted at node.\n{\nif (node == null)\nreturn 0;\nelse\nreturn 1 + recSize(node.getLeft()) + recSize(node.getRight());\n}\nIterative Version\n• We use a stack to hold nodes we have\nencountered but not yet processed\n• We must be careful that we process each node\nin the tree exactly once. We follow these rules:\n– Process a node immediately after removing it from\nthe stack.\n– Do not process nodes at any other time.\n– Once a node is removed from the stack, do not push\nit back onto the stack.\nCode for the iterative approach\npublic int size()\n// Returns the number of elements in this BST.\n{\nint count = 0;\nif (root != null)\n{\nLinkedStack<BSTNode<T>> nodeStack = new LinkedStack<BSTNode<T>> ();\nBSTNode<T> currNode;\nnodeStack.push(root);\nwhile (!nodeStack.isEmpty())\n{\ncurrNode\n<eos>"}
{"text": "<bos>\n= nodeStack.top();\nnodeStack.pop();\ncount++;\nif (currNode.getLeft() != null)\nnodeStack.push(currNode.getLeft());\nif (currNode.getRight() != null)\nnodeStack.push(currNode.getRight());\n}\n}\nreturn count;\n}\nRecursion or Iteration?\n• Is the depth of recursion relatively shallow? Yes\n• Is the recursive solution shorter or clearer than\nthe nonrecursive version? Yes\n• Is the recursive version much less efficient than\nthe nonrecursive version? No\n• This is a good use of recursion.\n7.6 The Implementation Level:\nRemaining Operations\n• In this section, we use recursion to implement\nthe remaining Binary Search Tree operations\n– contains\n– get\n– add\n– remove\n– iterator\n– getIterator\nThe contains operation\n• We implement contains using a private\nrecursive method called recContains which\n– is passed the\n<eos>"}
{"text": "<bos>\ntarget we are searching for and a\nnode representing the root of the subtree in which to\nsearch\n– has two base cases\n• if node is null returns false\n• if node contains target returns true\n– has two recursive cases\n• one searches the left subtree of node\n• one searches the right subtree of node\nThe contains method\npublic boolean contains (T target)\n// Returns true if this BST contains a node with info i such that\n// comp.compare(target, i) == 0; otherwise, returns false.\n{\nreturn recContains(target, root);\n}\nprivate boolean recContains(T target, BSTNode<T> node)\n// Returns true if the subtree rooted at node contains info i such that\n// comp.compare(target, i) == 0; otherwise, returns false.\n{\nif (node == null)\nreturn false; // target is not found\nelse if (comp.compare(target, node.getInfo())\n<eos>"}
{"text": "<bos>\n< 0)\nreturn recContains(target, node.getLeft()); // Search left subtree\nelse if (comp.compare(target, node.getInfo()) > 0)\nreturn recContains(target, node.getRight()); // Search right subtree\nelse\nreturn true; // target is found\n}\nThe get method is similar\npublic T get(T target)\n// Returns info i from node of this BST where comp.compare(target, i) == 0;\n// if no such node exists, returns null.\n{\nreturn recGet(target, root);\n}\nprivate T recGet(T target, BSTNode<T> node)\n// Returns info i from the subtree rooted at node such that\n// comp.compare(target, i) == 0; if no such info exists, returns null.\n{\nif (node == null)\nreturn null; // target is not found\nelse if (comp.compare(target, node.getInfo()) < 0)\nreturn recGet(target, node.getLeft()); // get from left subtree\nelse\nif\n<eos>"}
{"text": "<bos>\n(comp.compare(target, node.getInfo()) > 0)\nreturn recGet(target, node.getRight()); // get from right subtree\nelse\nreturn node.getInfo(); // target is found\n}\nIteration: Review of Traversal\nDefinitions\n• Preorder traversal: Visit the root, visit the\nleft subtree, visit the right subtree\n• Inorder traversal: Visit the left subtree,\nvisit the root, visit the right subtree\n• Postorder traversal: Visit the left subtree,\nvisit the right subtree, visit the root\nthe getIterator method\n• client passes getIterator an argument\nindicating one of the three traversal orders\n• getIterator creates the appropriate\niterator and returns it by traversing the tree in\nthe desired order and building a queue of T\n• It then creates an iterator using the\nanonymous inner class approach\n• returned iterator represents\n<eos>"}
{"text": "<bos>\na snapshot of\nthe tree at the time getIterator is invoked\nand does not support remove\npublic Iterator<T> getIterator(BSTInterface.Traversal orderType)\n{\nfinal LinkedQueue<T> infoQueue = new LinkedQueue<T>();\nif (orderType == BSTInterface.Traversal.Preorder)\npreOrder(root, infoQueue);\nelse if (orderType == BSTInterface.Traversal.Inorder)\ninOrder(root, infoQueue);\nelse if (orderType == BSTInterface.Traversal.Postorder)\npostOrder(root, infoQueue);\nreturn new Iterator<T>()\n{\npublic boolean hasNext()\n{\nreturn !infoQueue.isEmpty();\n}\npublic T next()\n{\nif (!hasNext())\nthrow new IndexOutOfBoundsException(\"illegal invocation of next …\nreturn infoQueue.dequeue();\n}\npublic void remove()\n{\nthrow new UnsupportedOperationException(\"Unsupported remove attempted …\n}\n};\n}\nInOrder traversal\nprivate void\n<eos>"}
{"text": "<bos>\ninOrder(BSTNode<T> node, LinkedQueue<T> q)\n// Enqueues the elements from the subtree rooted at node into q in inOrder.\n{ if (node != null)\n{\ninOrder(node.getLeft(), q);\nq.enqueue(node.getInfo());\ninOrder(node.getRight(), q);\n} }\npreOrder and postorder traversals\nprivate void preOrder(BSTNode<T> node, LinkedQueue<T> q)\n{\nif (node != null)\n{\nq.enqueue(node.getInfo());\npreOrder(node.getLeft(), q);\npreOrder(node.getRight(), q);\n}\n}\nprivate void postOrder(BSTNode<T> node, LinkedQueue<T> q)\n{\nif (node != null)\n{\npostOrder(node.getLeft(), q);\npostOrder(node.getRight(), q);\nq.enqueue(node.getInfo());\n}\n}\n7.7 The Implementation Level:\nTransformers\n• To complete our implementation of the Binary\nSearch Tree ADT we need to create the\ntransformer methods add and remove.\n• These are the most complex\n<eos>"}
{"text": "<bos>\noperations.\n• We use a similar approach as used in the\nsubsection “Transforming a Linked List” in\nSection 3.4, “Recursive Processing of Linked\nLists”\nThe add operation\n• A new node is always inserted into its appropriate position in\nthe tree as a leaf\nThe add operation\n• The add method invokes the recursive method, recAdd, and\npasses it the element to be added plus a reference to the root of the\ntree.\npublic boolean add (T element)\n// Adds element to this BST. The tree retains its BST property.\n{\nroot = recAdd(element, root);\nreturn true;\n}\n• The call to recAdd returns a BSTNode. It returns a reference to the\nnew tree, that is, to the tree that includes element. The statement\nroot = recAdd(element, root);\ncan be interpreted as “Set the reference of the root of this tree to the\nroot of the\n<eos>"}
{"text": "<bos>\ntree that is generated when element is added to this tree.”\nThe add method\nprivate BSTNode<T> recAdd(T element, BSTNode<T> node)\n// Adds element to tree rooted at node; tree retains its BST property.\n{\nif (node == null)\n// Addition place found\nnode = new BSTNode<T>(element);\nelse if (element.compareTo(node.getInfo()) <= 0)\nnode.setLeft(recAdd(element, node.getLeft())); // Add in left subtree\nelse\nnode.setRight(recAdd(element, node.getRight())); // Add in right subtree\nreturn tree;\n}\npublic boolean add (T element)\n// Adds element to this BST. The tree retains its BST property.\n{\nroot = recAdd(element, root);\nreturn true;\n}\nThe remove Operation\n• The most complicated of the binary search\ntree operations.\n• We must ensure when we remove an\nelement we maintain the binary search\ntree property.\n<eos>"}
{"text": "<bos>\nThe code for remove:\n• The set up for the remove operation is the same as that for the add\noperation.\n• The private recRemove method is invoked from the public remove\nmethod with arguments equal to the target element to be removed\nand the root of the tree to remove it from.\n• The recursive method returns a reference to the revised tree\n• The remove method returns the boolean value stored in found,\nindicating the result of the remove operation.\npublic boolean remove (T target)\n// Removes a node with info i from tree such that\n// comp.compare(target,i) == 0 and returns true;\n// if no such node exists, returns false.\n{\nroot = recRemove(target, root);\nreturn found;\n}\nThe recRemove method\nprivate BSTNode<T> recRemove(T target, BSTNode<T> node)\n// Removes element with info i from tree rooted at\n<eos>"}
{"text": "<bos>\nnode such that\n// comp.compare(target, i) == 0 and returns true;\n// if no such node exists, returns false.\n{\nif (node == null)\nfound = false;\nelse if (comp.compare(target, node.getInfo()) < 0)\nnode.setLeft(recRemove(target, node.getLeft()));\nelse if (comp.compare(target, node.getInfo()) > 0)\nnode.setRight(recRemove(target, node.getRight()));\nelse\n{\nnode = removeNode(node);\nfound = true;\n}\nreturn node;\n}\nThree cases for the removeNode\noperation\n• Removing a leaf (no children): removing a leaf is\nsimply a matter of setting the appropriate link of\nits parent to null.\n• Removing a node with only one child: make the\nreference from the parent skip over the removed\nnode and point instead to the child of the node\nwe intend to remove\n• Removing a node with two children: replaces the\nnode’s info\n<eos>"}
{"text": "<bos>\nwith the info from another node in\nthe tree so that the search property is retained -\nthen remove this other node\nRemoving a Leaf Node\nRemoving a node with one child\nRemoving a Node With Two Children\nThe Remove Node Algorithm\nremoveNode (node): returns BSTNode\nif (node.getLeft( ) is null) AND (node.getRight( ) is null)\nreturn null\nelse if node.getLeft( ) is null\nreturn node.getRight( )\nelse if node.getRight( ) is null\nreturn node.getLeft( )\nelse\nFind predecessor\nnode.setInfo(predecessor.getInfo( ))\nnode.setLeft(recRemove(predecessor.getInfo( ), node.getLeft( )))\nreturn node\nNote: We can remove one of the tests if we notice that the action taken when the\nleft child reference is null also takes care of the case in which both child references\nare null. When the left child reference is null,\n<eos>"}
{"text": "<bos>\nthe right child reference is returned. If\nthe right child reference is also null, then null is returned, which is what we want if\nthey are both null.\nThe removeNode method\nprivate BSTNode<T> removeNode(BSTNode<T> node)\n// Removes the information at node from the tree.\n{\nT data;\nif (node.getLeft() == null)\nreturn node.getRight();\nelse if (node.getRight() == null)\nreturn node.getLeft();\nelse\n{\ndata = getPredecessor(node.getLeft());\nnode.setInfo(data);\nnode.setLeft(recRemove(data, node.getLeft()));\nreturn node;\n}\n}\nThe getPredecessor method\n• The logical predecessor is the maximum value in node’s\nleft subtree.\n• The maximum value in a binary search tree is in its\nrightmost node.\n• Therefore, given node’s left subtree, we just keep\nmoving right until the right child is null.\n• When this\n<eos>"}
{"text": "<bos>\noccurs, we return the info reference of the\nnode.\nprivate T getPredecessor(BSTNode<T> subtree)\n// Returns the information held in the rightmost node of subtree\n{\nBSTNode temp = subtree;\nwhile (temp.getRight() != null)\ntemp = temp.getRight();\nreturn temp.getInfo();\n}\nOur Binary\nSearch Tree\nArchitecture\n7.8 Binary Search Tree\nPerformance\n• A binary search tree is an appropriate structure for many\nof the same applications discussed previously in\nconjunction with sorted lists.\n• Similar to a sorted array-based list, it can be searched\nquickly, using a binary search.\n• Similar to a linked list, it allows insertions and removals\nwithout having to move large amounts of data.\n• There is a space cost - the binary search tree, with its\nextra reference in each node, takes up more memory\nspace than a\n<eos>"}
{"text": "<bos>\nsingly linked list.\nText Analysis Experiment Revisited\nText Analysis Experiment Revisited\n• Due to operation complexity, performance gains\nfrom the binary search tree are only clearly\nevident as the size of the file increases.\n• The table also reveals a serious issue when the\nbinary search tree structure is used for the Linux\nWord file. The application bombs—it stops\nexecuting and reports a “Stack overflow error.”\n• The problem is that the underlying tree is\ncompletely skewed.\nInsertion\nOrder and\nTree Shape\nLinux Word\nFile is like this →\nBalancing a Binary Search Tree\n• A beneficial addition to our Binary Search Tree\nADT operations is a balance operation\n• The specification of the operation is:\npublic balance();\n// Restructures this BST to be optimally balanced\n• It is up to the client\n<eos>"}
{"text": "<bos>\nprogram to use the\nbalance method appropriately\nOur Approach\n• Basic algorithm:\nSave the tree information in an array\nInsert the information from the array back into the tree\n• The structure of the new tree depends on the\norder that we save the information into the\narray, or the order in which we insert the\ninformation back into the tree, or both\n• We save the information “in order” so that the\narray is sorted\nTo Ensure a Balanced Tree\n• Even out as much as possible, the number\nof descendants in each node’s left and\nright subtrees\n• First insert the “middle” item of the inOrder\narray\n– Then insert the left half of the array using the\nsame approach\n– Then insert the right half of the array using the\nsame approach\nBalance\nOur Balance Tree\nIterator iter = tree.getIterator(Inorder )\nint index\n<eos>"}
{"text": "<bos>\n= 0 Algorithm\nwhile (iter.hasnext())\narray[index] = iter.next( )\nindex++\ntree = new BinarySearchTree()\ntree.InsertTree(0, index - 1)\nInsertTree(low, high)\nif (low == high) // Base case 1\ntree.add(array[low])\nelse if ((low + 1) == high) // Base case 2\ntree.add(array[low])\ntree.add(array[high])\nelse\nmid = (low + high) / 2\ntree.add(array[mid])\ntree.InsertTree(low, mid – 1)\ntree.InsertTree(mid + 1, high)\nUsing\nrecursive\ninsertTree\n7.9 Application: Word Frequency\nCounter\n• In this section we develop a word frequency\ncounter that uses our binary search tree\n• Read a text file and generate an alphabetical\nlisting of the unique words, along with a count of\nhow many times each word occurs\n• We allow users to specify a minimum word size\nand a minimum frequency count\n• Present a few summary\n<eos>"}
{"text": "<bos>\nstatistics\npackage support;\nimport java.text.DecimalFormat;\npublic class WordFreq implements Comparable<WordFreq>\n{\nprivate String word; private int freq;\nDecimalFormat fmt = new DecimalFormat(\"00000\");\npublic WordFreq(String newWord)\n{\nThe WordFreq\nword = newWord; freq = 0;\n}\nClass\npublic String getWordIs(){return word;}\npublic int getFreq(){return freq;}\npublic void inc() { freq++; }\npublic int compareTo(WordFreq other)\n{\nreturn this.word.compareTo(other.word);\n}\npublic String toString()\n{\nreturn(fmt.format(freq) + \" \" + word);\n}\n}\nThe Application\n• Scans the input file for words, and after reading\na word, it checks to see if a match is already in\nthe tree, and if not it inserts a WordFreq object\nthat holds the word and a frequency count of 1\n• If the word is already in the tree,\n<eos>"}
{"text": "<bos>\nincrement the\nfrequency associated with the word\nAlgorithm to process a word\nwordToTry = new WordFreq(word)\nwordInTree = tree.get(wordToTry)\nif (wordInTree != null)\nwordInTree.inc()\nelse\nwordToTry.inc() // to set its frequency to 1\ntree.add(wordToTry);\nProcessing\na word\nThe Application\n• Instructors can now review the code and\ndemonstrate/discuss the application.\n7.10 Tree Variations\n• Trees can be binary, trinary (up to three children per\nnode), n-ary (up to n children per node), alternating ary,\nbalanced, not balanced, partially balanced, self-\nadjusting, and store information in their nodes or their\nedges or both.\n• The Java Library does not include a general tree\nstructure and neither do most textbooks.\n• Often with trees we let the specific target application\ndictate the definition,\n<eos>"}
{"text": "<bos>\nassumptions, rules, and operations\nassociated with a specific implementation.\nApplication-Specific Variations\n• Decision Trees:\nApplication-Specific Variations\n• Expression/Parse Trees:\nApplication-\nSpecific\nVariations\n• R Trees:\nApplication-Specific Variations\n• Tries/Prefix\nTrees:\nBalanced Search Trees\n• The Binary Search Tree ADT presented in this\nchapter is an excellent collection structure for\nholding “random” data, but suffers from one\nmajor weakness—it can become unbalanced.\n• Many search tree variations have been invented\nto address this weakness, each in turn with their\nown strengths and weaknesses.\nBalanced Search Trees\n• B-Trees: a search tree that allows internal nodes\nto hold multiple values and have multiple\nchildren\nBalanced Search Trees\n• B-Tree Variants: A popular variant\n<eos>"}
{"text": "<bos>\nof the B-Tree\nis the 2-3-4 tree, where nodes are constrained to\nhold 1, 2, or 3 values and therefore have 2, 3, or\n4 subtrees (thus the name of the tree)\n• Searching, insertion, and removal of information\nis always O(log N) and the amount of work\n2\nrequired to process the information within any\nnode is constant.\nBalanced Search Trees\n• A 2-3-4 tree can be implemented using a binary tree\nstructure called a red-black tree. In this structure nodes\nare “colored” either red or black (each node must hold an\nextra boolean value that indicates this information). The\ncolor of a node indicates how its value fits into the\ncorresponding 2-3-4 tree.\n• The Java Library includes two important classes that use\ntree implementations. The Java TreeMap class supports\nmaps (see Chapter 8) and the Java TreeSet\n<eos>"}
{"text": "<bos>\nclass\nsupports sets (see Section 5.7, “Collection Variations”).\nIn both cases the internal representation is a red-black\ntree.\nBalanced Search Trees\n• AVL Trees: the\ndifference in height\nbetween a node’s\ntwo subtrees can be\nat most 1.\n• During addition and\nremoval of nodes\nextra work is\nrequired to ensure\nthe tree remains\nbalanced.\n<eos>"}
{"text": "<bos>\nChapter 8\nThe Map\nADT\nChapter 8: The Map ADT\n8.1 – The Map Interface\n8.2 – Map Implementations\n8.3 – Application: String-to-String Map\n8.4 – Hashing\n8.5 – Hash Functions\n8.6 – A Hash-Based Map\n8.7 – Map Variations\n8.1 The Map Interface\n• Maps associate a\nkey with exactly\none value\n• In other words\n– a map structure\ndoes not permit\nduplicate keys\n– but two distinct\nkeys can map onto\nthe same value\nLegal mapping variations\nMapInterface\n//------------------------------------------------------------------------\n// MapInterface.java by Dale/Joyce/Weems Chapter 8\n//\n// A map provides (K = key, V = value) pairs, mapping the key onto\n// the value.\n// Keys are unique. Keys cannot be null.\n//\n// Methods throw IllegalArgumentException if passed a null key argument.\n//\n// Values can be null, so a null\n<eos>"}
{"text": "<bos>\nvalue returned by put, get, or remove does\n// not necessarily mean that an entry did not exist.\n//------------------------------------------------------------------------\n//\n// . . . continued on next slide\npackage ch08.maps;\nimport java.util.Iterator;\npublic interface MapInterface<K, V> extends Iterable<MapEntry<K,V>>\n{\nV put(K k, V v);\n// If an entry in this map with key k already exists then the value\n// associated with that entry is replaced by value v and the original\n// value is returned; otherwise, adds the (k, v) pair to the map and\n// returns null.\nV get(K k);\n// If an entry in this map with a key k exists then the value associated\n// with that entry is returned; otherwise null is returned.\nV remove(K k);\n// If an entry in this map with key k exists then the entry is removed\n//\n<eos>"}
{"text": "<bos>\nfrom the map and the value associated with that entry is returned;\n// otherwise null is returned.\n//\n// Optional. Throws UnsupportedOperationException if not supported.\n// Also requires contains(K key), isFull(), isEmpty() and size()\n}\nIteration\n• We require an iteration that returns key-value\npairs\n• The class MapEntry represents the key-value\npairs\n– requires the key and value to be passed as\nconstructor arguments\n– provides getter operations for both key and value\n– provides a setter operation for the value\n– provides a toString\nMapExample\n• Instructors can now discuss and demonstrate\nthe MapExample application found in the\nch08.apps package … it uses the\nArrayListMap class presented in the next\nsection\n8.2 Map Implementations\n• Unsorted Array\n– The put operation creates a new MapEntry\n<eos>"}
{"text": "<bos>\nobject\nand performs a brute force search (O(N)) of all the\ncurrent keys in the array to prevent key duplication\n– If a duplicate key is found, then the associated\nMapEntry object is replaced by the new object and\nits value attribute is returned, for example\nmap.put(cow)\nMap Implementations\n• Unsorted Array\n– Like put, the get, remove, and contains\noperations would all require brute force searches of\nthe current array contents, so they are all O(N)\n• Sorted Array\n– The binary search algorithm can be used, greatly\nimproving the efficiency of the important get and\ncontains operations.\n– Although it is not a requirement, in general it is\nexpected that a map will provide fast implementation\nof these two operations.\nMap Implementations\n• Unsorted Linked List\n– Similar to an unsorted array, most\n<eos>"}
{"text": "<bos>\noperations require\nbrute force search\n– In terms of space, a linked list grows and shrinks as\nneeded so it is possible that some advantage can be\nfound in terms of memory management, as compared\nto an array.\nMap Implementations\n• Sorted Linked List\n– Even though a linked list is kept sorted, it does not\npermit use of the binary search algorithm as there is\nno efficient way to inspect the “middle” element.\n– So there is not much advantage to using a sorted\nlinked list to implement a map, as compared to an\nunsorted linked list\nMap Implementations\n• Binary Search Tree\n– If a map can be implemented as a balanced binary\nsearch tree, then all of the primary operations (put,\nget, remove, and contains) can exhibit efficiency\nO(log N).\n2\nArrayListMap\n• Instructors can now discuss the ArrayListMap\n<eos>"}
{"text": "<bos>\nclass found in the ch08.maps package and\nreview the associated notes found on pages 511\nand 512\n8.3 Application:\nString-to-String Map\n• The StringPairApp found in the ch08.apps\npackage reads # separated pairs of strings (key\n# value) from specified input file and then allows\nthe user to enter keys and reports back to them\nthe associated value if there is one.\n• It is a short yet versatile application that\ndemonstrates the use of our Map ADT\n8.4 Hashing\n• An efficient approach to implementing a Map\n• Typically provides O(1) operation\nimplementation\n• Uses an array (typically called a hash table) to\nhold the key/value pairs\n• Hashing involves determining array indices\ndirectly from the key of the entry being\nstored/accessed.\nCompression function\n• If we have a positive\nintegral key, such as\n<eos>"}
{"text": "<bos>\nan\nID number, we can just\nuse the key as the index\ninto the array\n• If the range of key\nvalues is larger than the\narray we must\n“compress” the key into\na usable index\nCollisions\n• If two keys compress to the same array location\nwe call it a “collision”\n• minimizing such collisions is the biggest\nchallenge in designing a good hashing system\n– we cover this in Section 8.5, “Hash Functions.”\n• In our discussion of collision resolution policies,\nwe will assume\n– use of an array info to hold the information\n– the int variable location to indicate an array/hash-\ntable slot.\nCollision resolution policies\n• Linear probing: store the colliding entry into the\nnext available space:\nItem Removal\n• Complicates searching: can not terminate search\nupon finding a null entry therefore:\n– use a special\n<eos>"}
{"text": "<bos>\nvalue for a removed entry\n– use a boolean value associated with each hash table slot:\n– disallow removal\nCollision resolution policies\n• Linear probing approach can lead to inefficient\nclusters of entries\n• Quadratic probing: the value added at each\nstep is dependent on how many locations have\nalready been inspected.\n– The first time it looks for a new location it adds 1 to\nthe original location\n– the second time it adds 4 to the original location\n– the third time it adds 9 to the original location\n– and so on—the ith time it adds i2:\nComparison\nCollision resolution policies\nBuckets and Chaining\n8.5 Hash Functions\n• To get the most benefit from a hashing system\nwe need for the eventual locations used in the\nunderlying array to be as spread out as possible.\n• Two factors affect this spread\n<eos>"}
{"text": "<bos>\n– the size of the underlying array\n– the set of integral values presented to the\ncompression function\nArray Size\n• space versus time trade-off\n• hash systems will often monitor their own load—\nthe percentage of array indices being used\n• Once the load reaches a certain level, for\nexample 75%, the system is rebuilt using a\nlarger array\n• This approach is often called “rehashing”\nbecause after the array is enlarged all of the\nprevious entries have to be reinserted into the\nnew array\nThe Hash Function\n• Keys might not be integral\n• Even if integral, keys might not provide a good\n“spread”\n• So, we add another step, the hash function:\n• Synonyms for “hash code” include “hash value,”\nand sometimes we just use the word “hash.”\nCreating a hash function\n• Selecting: Identify selected parts of the\n<eos>"}
{"text": "<bos>\nkey – try\nto use parts that will provide a good variety of\nresults\n• Digitizing: the selected parts must be\ntransformed to integers\n• Combining: combine the resultant integers using\na mathematical function\nConsiderations\n• A hash code is not unique. Do not use a hash code as a\nkey.\n• If two entries are considered to be equal, then they\nshould hash to the same value.\n• When defining a hash function, consider the work\nrequired to calculate it.\n• A precise analysis of the complexity of hashing depends\non the domain and distribution of keys, the hash\nfunction, the size of the table, and the collision resolution\npolicy. In practice it is usually not difficult to achieve\nclose to O(1) efficiency using hashing.\nJava’s Support for Hashing\n• The Java Library includes a HashMap class (discussed\nin\n<eos>"}
{"text": "<bos>\nSection 8.7) and a HashSet class that use hash\ntechniques to support storing objects\n• The Java Object class exports a hashCode method\nthat returns an int hash code.\n– The standard Java hash code for an object is a function of the object’s memory\nlocation.\n• For most applications, hash codes based on memory\nlocations are not usable. Many of the Java classes that\ndefine commonly used objects (such as String and\nInteger), override the Object class’s hashCode\nmethod.\n• If you plan to use hash tables in your programs, you\nshould do likewise.\n8.6 A Hash-Based Map\nHmap.java\n• is implemented with an internal hash table that\nuses the hashCode method of the key class\n• is unbounded\n• has a default capacity of 1,000 and a default\nload factor of 75%\n• does not support the remove operation\n• is\n<eos>"}
{"text": "<bos>\nlocated in the ch08.maps package\n• is used by the VocDensMeasureHMap\napplication located in the ch08.apps package\n8.7 Map Variations\n• Some programming languages, (e.g., Awk,\nHaskell, JavaScript, Lisp, MUMPS, Perl, PHP,\nPython, and Ruby), directly support\n• Many other languages, including Java, C++,\nObjective-C, and Smalltalk provide map\nfunctionality through their standard code libraries\nMaps are known by many names:\n• Symbol table - one of the first carefully studied and\ndesigned data structures, and were related to compiler\ndesign\n• Dictionary - the idea of looking up a word (the key) in a\ndictionary to find its definition (the value) makes the\nconcept of a dictionary a good fit for maps\n• Hashes - because a hash system is a very efficient and\ncommon way to implement a map, you will\n<eos>"}
{"text": "<bos>\nsometimes\nsee the two terms used interchangeably\n• Associative Arrays - You can view a map as an array—\none that associates keys with values rather than indices\nwith values.\n<eos>"}
{"text": "<bos>\nChapter 9\nThe\nPriority\nQueue\nADT\nChapter 9: The\nPriority Queue ADT\n9.1 – The Priority Queue Interface\n9.2 – Priority Queue Implementations\n9.3 – The Heap\n9.4 – The Heap Implementation\n9.1 The Priority Queue Interface\n• A priority queue is an abstract data type with an\ninteresting accessing protocol - only the highest-\npriority element can be accessed\n• Priority queues are useful for any application\nthat involves processing items by priority\nThe Interface\npackage ch09.priorityQueues;\npublic interface PriQueueInterface<T>\n{\nvoid enqueue(T element);\n// Throws PriQOverflowException if this priority queue is full;\n// otherwise, adds element to this priority queue.\nT dequeue();\n// Throws PriQUnderflowException if this priority queue is empty;\n// otherwise, removes element with highest priority\n<eos>"}
{"text": "<bos>\nfrom this\n// priority queue and returns it.\nboolean isEmpty();\n// Returns true if this priority queue is empty; otherwise, returns false.\nboolean isFull();\n// Returns true if this priority queue is full; otherwise, returns false.\nint size();\n// Returns the number of elements in this priority queue. }\n9.2 Priority Queue Implementations\n• There are many ways to implement a priority queue\n– An Unsorted List - dequeuing would require searching\nthrough the entire list\n– An Array-Based Sorted List - Enqueuing is expensive\n– A Sorted Linked List - Enqueuing again is 0(N)\n– A Binary Search Tree - On average, 0(log N) steps for\n2\nboth enqueue and dequeue\n– A Heap - (next section) guarantees 0(log N) steps, even\n2\nin the worst case\n9.3 The Heap\n• Heap An implementation of a Priority Queue\nbased on a\n<eos>"}
{"text": "<bos>\ncomplete binary tree, each of whose\nelements contains a value that is greater than or\nequal to the value of each of its children\n• In other words, a heap is an implementation of a\nPriority Queue that uses a binary tree that\nsatisfies two properties\n– the shape property: the tree must be a complete\nbinary tree\n– the order property: for every node in the tree, the\nvalue stored in that node is greater than or equal to\nthe value in each of its children.\nTree Terminology\n• A full binary tree\n• A complete binary tree\nExamples\nTwo\nHeaps\nContaining\nthe Letters\n‘A’ through\n‘J’\nThe\ndequeue\noperation\nSteps d,e,f\nrepresent the\n“reheap\ndown”\noperation\nThe enqueue operation\nsteps b, c represent the “reheap up” operation\n9.4 The Heap Implementation\nA Non-linked Representation of\nBinary Trees\n• A binary\n<eos>"}
{"text": "<bos>\ntree can be stored in an array in such a way\nthat the relationships in the tree are not physically\nrepresented by link members, but are implicit in the\nalgorithms that manipulate the tree stored in the array.\n• We store the tree elements in the array, level by level,\nleft-to-right. We call the array elements and store the\nindex of the last tree element in a variable lastIndex.\n• The tree elements are stored with the root in\nelements[0] and the last node in\nelements[lastIndex].\nA Binary Tree and Its Array\nRepresentation\nA Binary Search Tree Stored in\nan Array with Dummy Values\nArray Representation continued\n• To implement the algorithms that manipulate the\ntree, we must be able to find the left and right child\nof a node in the tree:\n– elements[index] left child is in elements[index*2 + 1]\n–\n<eos>"}
{"text": "<bos>\nelements[index] right child is in elements[index*2 + 2]\n• We can also can determine the location of its parent\nnode:\n– elements[index]’s parent is in elements[(index – 1)/2].\n• This representation works best, space wise, if the\ntree is complete (which it is for a heap)\nBeginning of HeapPriQ.java\n//-------------------------------------------------------------------------\n// HeapPriQ.java by Dale/Joyce/Weems Chapter\n9 // Priority Queue using Heap (implemented with an ArrayList)\n//\n// Two constructors are provided: one that use the natural order of the\n// elements as defined by their compareTo method and one that uses an\n// ordering based on a comparator argument.\n//-------------------------------------------------------------------------\npackage ch09.priorityQueues;\nimport java.util.*; //\n<eos>"}
{"text": "<bos>\nArrayList, Comparator\npublic class HeapPriQ<T> implements PriQueueInterface<T>\n{\nprotected ArrayList<T> elements; // priority queue elements\nprotected int lastIndex; // index of last element in priority queue\nprotected int maxIndex; // index of last position in ArrayList\nprotected Comparator<T> comp;\n. . .\nThe enqueue method\npublic void enqueue(T element) throws PriQOverflowException\n// Throws PriQOverflowException if this priority queue is full;\n// otherwise, adds element to this priority queue.\n{\nif (lastIndex == maxIndex)\nthrow new PriQOverflowException(\"Priority queue is full\");\nelse\n{\nlastIndex++;\nelements.add(lastIndex, element);\nreheapUp(element);\n}\n}\nThe reheapUp algorithm is pictured on the next slide\nreheapUp operation\nprivate void reheapUp(T element)\n// Current lastIndex\n<eos>"}
{"text": "<bos>\nposition is empty.\n// Inserts element into the tree and ensures shape and order properties.\n{\nint hole = lastIndex;\nwhile ((hole > 0) // hole is not root and element > hole's parent\n&&\n(comp.compare(element, elements.get((hole - 1) / 2)) > 0))\n{\nelements.set(hole,elements.get((hole - 1) / 2)); // move hole's parent down\nhole = (hole - 1) / 2; // move hole up\n}\nelements.set(hole, element); // place element into final hole\n}\nThe dequeue method\npublic T dequeue() throws PriQUnderflowException\n// Throws PriQUnderflowException if this priority queue is empty;\n// otherwise, removes element with highest priority from this\n// priority queue and returns it.\n{\nT hold; // element to be dequeued and returned\nT toMove; // element to move down heap\nif (lastIndex == -1)\nthrow new\n<eos>"}
{"text": "<bos>\nPriQUnderflowException(\"Priority queue is empty\");\nelse\n{\nhold = elements.get(0); // remember element to be returned\ntoMove = elements.remove(lastIndex); // element to reheap down\nlastIndex--; // decrease priority queue size\nif (lastIndex != -1)\nreheapDown(toMove); // restore heap properties\nreturn hold; // return largest element\n}\n}\nThe reheapDown algorithm is pictured on the next slide\nreheapDown operation\nprivate void reheapDown(T element)\n// Current root position is \"empty\";\n// Inserts element into the tree and ensures shape and order properties.\n{\nint hole = 0; // current index of hole\nint next; // next index where hole should move to\nnext = newHole(hole, element); // find next hole\nwhile (next != hole)\n{\nelements.set(hole,elements.get(next)); // move element up\nhole = next; // move\n<eos>"}
{"text": "<bos>\nhole down\nnext = newHole(hole, element); // find next hole\n}\nelements.set(hole, element); // fill in the final hole\n}\nprivate int newHole(int hole, T element)\n// If either child of hole is larger than element return the index\n// of the larger child; otherwise return the index of hole.\n{\nThe\nint left = (hole * 2) + 1;\nint right = (hole * 2) + 2;\nif (left > lastIndex)\nnewHole\n// hole has no children\nreturn hole;\nelse\nif (left == lastIndex) method\n// hole has left child only\nif (comp.compare(element, elements.get(left)) < 0)\n// element < left child\nreturn left;\nelse\n// element >= left child\nreturn hole;\nelse\n// hole has two children\nif (comp.compare(elements.get(left), elements.get(right)) < 0)\n// left child < right child\nif (comp.compare(elements.get(right), element) <= 0)\n// right child <=\n<eos>"}
{"text": "<bos>\nelement\nreturn hole;\nelse\n// element < right child\nreturn right;\nelse\n// left child >= right child\nif (comp.compare(elements.get(left), element) <= 0)\n// left child <= element\nreturn hole;\nelse\n// element < left child\nreturn left;\n}\nHeaps Versus Other\nRepresentations of Priority\nQueues\n<eos>"}
