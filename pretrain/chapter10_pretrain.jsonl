{"text": "<bos>\nChapter 10\nThe Graph\nADT\nChapter 10:\nThe Graph ADT\n10.1 – Introduction to Graphs\n10.2 – The Graph Interface\n10.3 – Implementations of Graphs\n10.4 – Application: Graph Traversals\n10.5 – Application: The Single-Source Shortest-Paths\nProblem\n10.1 Introduction to Graphs\nDefinitions\n• Graph: A data structure that consists of a set of\nvertices and a set of edges that relate the\nvertices to each other\n• Vertex: A node in a graph\n• Edge (arc): A pair of vertices representing a\nconnection between the two vertices in a graph\n• Undirected graph: A graph in which the edges\nhave no direction\n• Directed graph (digraph): A graph in which\neach edge is directed from one vertex to another\n(or the same) vertex\nFormally\n• a graph G is defined as follows:\nG = (V,E)\nwhere\nV(G) is a finite, nonempty set of\n<eos>"}
{"text": "<bos>\nvertices\nE(G) is a set of edges (written as pairs\nof vertices)\nMore Definitions\n• Adjacent vertices: Two vertices in a graph that\nare connected by an edge\n• Path: A sequence of vertices that connects two\nvertices in a graph\n• Complete graph: A graph in which every vertex\nis directly connected to every other vertex\n• Weighted graph: A graph in which each edge\ncarries a value\nTwo complete graphs\nA weighted graph\n10.2 The Graph Interface\n• What kind of questions might we ask\nabout a graph?\n– Does a path exist between vertex A and\nvertex D? Can we fly from Atlanta to\nDetroit?\n– What is the total weight along this path\nfrom A to D? How much does it cost to fly\nfrom Atlanta to Detroit? What is the total\ndistance?\n– What is the shortest path from A to D?\nWhat is the cheapest way to get from\n<eos>"}
{"text": "<bos>\nAtlanta to Detroit?\n– If I start at vertex A, where can I go?\nWhat cities are accessible if I start in\nAtlanta?\n– How many connected components are in\nthe graph? What groups of cities are\nconnected to each other?\nGraph Operations\n• What kind of operations are defined on a\ngraph?\n– We specify and implement a small set of\nuseful graph operations\n– Many other operations on graphs can be\ndefined; we have chosen operations that are\nuseful when building applications to answer\ntypical questions, such as those found on the\nprevious slide\nWeightedGraphInterface.java part I\n//----------------------------------------------------------------------------\n// WeightedGraphInterface.java by Dale/Joyce/Weems Chapter 10\n//\n// Interface for classes that implement a directed graph with weighted edges.\n//\n<eos>"}
{"text": "<bos>\nVertices are objects of class T and can be marked as having been visited.\n// Edge weights are integers.\n// Equivalence of vertices is determined by the vertices' equals method.\n//\n// General precondition: except for the addVertex and hasVertex methods,\n// any vertex passed as an argument to a method is in this graph.\n//----------------------------------------------------------------------------\npackage ch10.graphs;\nimport ch04.queues.*;\npublic interface WeightedGraphInterface<T>\n{\nboolean isEmpty();\n// Returns true if this graph is empty; otherwise, returns false.\nboolean isFull();\n// Returns true if this graph is full; otherwise, returns false.\nWeightedGraphInterface.java\npart II\nvoid addVertex(T vertex);\n// Preconditions: This graph is not full.\n// vertex is not already in this graph.\n//\n<eos>"}
{"text": "<bos>\nvertex is not null.\n//\n// Adds vertex to this graph.\nboolean hasVertex(T vertex);\n// Returns true if this graph contains vertex; otherwise, returns false.\nvoid addEdge(T fromVertex, T toVertex, int weight);\n// Adds an edge with the specified weight from fromVertex to toVertex.\nint weightIs(T fromVertex, T toVertex);\n// If edge from fromVertex to toVertex exists, returns the weight of edge;\n// otherwise, returns a special “null-edge” value.\nWeightedGraphInterface.java\npart III\nUnboundedQueueInterface<T> getToVertices(T vertex);\n// Returns a queue of the vertices that vertex is adjacent to.\nvoid clearMarks();\n// Unmarks all vertices.\nvoid markVertex(T vertex);\n// Marks vertex.\nboolean isMarked(T vertex);\n// Returns true if vertex is marked; otherwise, returns false.\nT getUnmarked();\n//\n<eos>"}
{"text": "<bos>\nReturns an unmarked vertex if any exist; otherwise, returns null.\n}\n10.3 Implementations of Graphs\n• In this section we introduce two graph\nimplementation approaches\n– an array based approach\n– a linked approach\nArray-Based Implementation\n• Adjacency matrix For a graph with N nodes,\nan N by N table that shows the existence (and\nweights) of all edges in the graph\n• With this approach a graph consists of\n– an integer variable numVertices\n– a one-dimensional array vertices\n– a two-dimensional array edges (the adjacency\nmatrix)\nA repeat of the abstract model\nThe array-based implementation\nWeightedGraph.java\ninstance variables\npackage ch10.graphs;\nimport ch04.queues.*;\npublic class WeightedGraph<T> implements WeightedGraphInterface<T>\n{\npublic static final int NULL_EDGE = 0;\nprivate static\n<eos>"}
{"text": "<bos>\nfinal int DEFCAP = 50; // default capacity\nprivate int numVertices;\nprivate int maxVertices;\nprivate T[] vertices;\nprivate int[][] edges;\nprivate boolean[] marks; // marks[i] is mark for vertices[i]\n. . .\nWeightedGraph.java\nConstructors\npublic WeightedGraph()\n// Instantiates a graph with capacity DEFCAP vertices.\n{\nnumVertices = 0;\nmaxVertices = DEFCAP;\nvertices = (T[ ]) new Object[DEFCAP];\nmarks = new boolean[DEFCAP];\nedges = new int[DEFCAP][DEFCAP];\n}\npublic WeightedGraph(int maxV)\n// Instantiates a graph with capacity maxV.\n{\nnumVertices = 0;\nmaxVertices = maxV;\nvertices = (T[ ]) new Object[maxV];\nmarks = new boolean[maxV];\nedges = new int[maxV][maxV];\n}\n...\nAdding a vertex\npublic void addVertex(T vertex)\n// Preconditions: This graph is not full.\n// Vertex is not already in this graph.\n<eos>"}
{"text": "<bos>\n// Vertex is not null.\n//\n// Adds vertex to this graph.\n{\nvertices[numVertices] = vertex;\nfor (int index = 0; index < numVertices; index++)\n{\nedges[numVertices][index] = NULL_EDGE;\nedges[index][numVertices] = NULL_EDGE;\n}\nnumVertices++;\n}\nTextbook also includes code for indexIs, addEdge,\nweightIs, and getToVertices.\nCoding the remaining methods is left as an exercise.\nLinked Implementation\n• Adjacency list A linked list that identifies all the\nvertices to which a particular vertex is\nconnected; each vertex has its own adjacency\nlist\n• We look at two alternate approaches:\n– use an array of vertices that each contain a reference\nto a linked list of nodes\n– use a linked list of vertices that each contain a\nreference to a linked list of nodes\nA repeat of the abstract model\nThe first link-based\n<eos>"}
{"text": "<bos>\nimplementation\nThe second link-based implementation\n10.4 Application: Graph Traversals\n• Our graph specification does not include\ntraversal operations.\n• We treat traversal as a graph application rather\nthan an innate operation.\n• The basic operations given in our specification\nallow us to implement different traversals\nindependent of how the graph itself is actually\nimplemented.\n• The application UseGraph in the ch10.apps\npackage contains the code for all the algorithms\npresented in Sections 10.4 and 10.5\nGraph Traversal\n• As we did for general trees, we look at two types\nof graph traversal:\n– The strategy of going as far as we can and then\nbacktracking is called a depth-first strategy.\n– The strategy of fanning out “level by level” is called a\nbreadth-first strategy.\n• We discuss\n<eos>"}
{"text": "<bos>\nalgorithms for employing both\nstrategies within the context of determining if two\ncities are connected in our airline example.\nCan we get from Austin to\nWashington?\nAlgorithm:\nIsPathDF (startVertex, endVertex): returns boolean\nSet found to false\nClear all marks\nMark the startVertex\nPush the startVertex onto the stack\ndo\nSet current vertex = stack.top()\nstack.pop()\nif current vertex equals endVertex\nSet found to true\nelse\nfor each adjacent vertex\nif adjacent vertex is not marked\nMark the adjacent vertex and\nPush it onto the stack\nwhile !stack.isEmpty() AND !found\nreturn found\nSet found to false\nClear all marks\nMark the startVertex\nPush the startVertex onto the stack\ndo\nSet current vertex = stack.top()\nstack.pop()\nif current vertex equals endVertex\nSet found to true\nelse\nfor each adjacent\n<eos>"}
{"text": "<bos>\nvertex\nif adjacent vertex is not marked\nMark the adjacent vertex and\nPush it onto the stack\nwhile !stack.isEmpty() AND !found\nreturn found\nBreadth first search – use queue\nIsPathBF (startVertex, endVertex): returns boolean\nSet found to false\nClear all marks\nMark the startVertex\nEnqueue the startVertex into the queue\ndo\nSet current vertex = queue.dequeue()\nif current vertex equals endVertex\nSet found to true\nelse\nfor each adjacent vertex\nif adjacent vertex is not marked\nMark the adjacent vertex and\nEnqueue it into the queue\nwhile !queue.isEmpty() AND !found\nreturn found\nExamples of\nsearch paths\n10.5 Application: The Single-Source\nShortest-Paths Problem\n• An algorithm that displays the shortest path from a\ndesignated starting city to every other city in the graph\n• In our example graph if\n<eos>"}
{"text": "<bos>\nthe starting point is Washington\nwe should get\nLast Vertex Destination Distance\n------------------------------------\nWashington Washington 0\nWashington Atlanta 600\nWashington Dallas 1300\nAtlanta Houston 1400\nDallas Austin 1500\nDallas Denver 2080\nDallas Chicago 2200\nAn erroneous approach\nshortestPaths(graph, startVertex)\ngraph.ClearMarks( )\nCreate flight(startVertex, startVertex, 0)\npq.enqueue(flight) // pq is a priority queue\ndo\nflight = pq.dequeue( )\nif flight.getToVertex() is not marked\nMark flight.getToVertex()\nWrite flight.getFromVertex, flight.getToVertex, flight.getDistance\nflight.setFromVertex(flight.getToVertex())\nSet minDistance to flight.getDistance()\nGet queue vertexQueue of vertices adjacent from flight.getFromVertex()\nwhile more vertices in vertexQueue\nGet next vertex from\n<eos>"}
{"text": "<bos>\nvertexQueue\nif vertex not marked\nflight.setToVertex(vertex)\nflight.setDistance(minDistance + graph.weightIs(flight.getFromVertex(), vertex))\npq.enqueue(flight)\nwhile !pq.isEmpty( )\nNotes\n• The algorithm for the shortest-path traversal is\nsimilar to those we used for the depth-first and\nbreadth-first searches, but there are three major\ndifferences:\n– We use a priority queue rather than a FIFO queue or\nstack\n– We stop only when there are no more cities to\nprocess; there is no destination\n– It is incorrect if we use a reference-based priority\nqueue improperly!\nThe Incorrect Part of the Algorithm\nwhile more vertices in vertexQueue\nGet next vertex from vertexQueue\nif vertex not marked\nflight.setToVertex(vertex)\nflight.setDistance(minDistance + graph.weightIs(flight.getFromVertex(), vertex))\n<eos>"}
{"text": "<bos>\npq.enqueue(flight)\n• This part of the algorithm walks through the queue of vertices adjacent to\nthe current vertex, and enqueues Flight objects onto the priority queue\npq based on the information.\n• The flight variable is actually a reference to a Flight object.\n• Suppose the queue of adjacent vertices has information in it related to the\ncities Atlanta and Houston.\n• The first time through this loop we insert information related to Atlanta in\nflight and enqueue it in pq.\n• But the next time through the loop we make changes to the Flight\nobject referenced by flight. We are inadvertently reaching into the\npriority queue and changing one of its entries.\nCorrecting the Algorithm\nwhile more vertices in vertexQueue\nGet next vertex from vertexQueue\nif vertex not marked\nSet newDistance to\n<eos>"}
{"text": "<bos>\nminDistance + graph.weightIs(flight.getFromVertex(), vertex)\nCreate newFlight(flight.getFromVertex(), vertex, newDistance)\npq.enqueue(newFlight)\nThe application UseGraph in the ch10.apps package\ncontains the code for all the algorithms presented in\nSections 10.4 and 10.5\nUnreachable Vertices\nWith this new graph we cannot fly from Washington to\nAustin, Chicago, Dallas, or Denver\nTo print unreachable vertices\n• Append the following to the\nshortestPaths method:\nSystem.out.println(\"The unreachable vertices are:\");\nvertex = graph.getUnmarked();\nwhile (vertex != null)\n{\nSystem.out.println(vertex);\ngraph.markVertex(vertex);\nvertex = graph.getUnmarked();\n}\n<eos>"}
