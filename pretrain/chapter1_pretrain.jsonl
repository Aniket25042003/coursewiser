{"text": "<bos>\nChapter 1\nGetting\nOrganized\nChapter 1: Getting Organized\n1.1 – Classes, Objects, and Applications\n1.2 – Organizing Classes\n1.3 – Exceptional Situations\n1.4 – Data Structures\n1.5 – Basic Structuring Mechanisms\n1.6 – Comparing Algorithms: Order of Growth\nAnalysis\n1.1 Classes, Objects,\nand Applications\n• Objects represent\n– information: we say the objects have attributes.\n– behavior: we say the objects have responsibilities.\n• Objects can represent “real-world” entities such\nas bank accounts.\n• Objects are self-contained and therefore easy to\nimplement, modify, test for correctness, and\nreuse.\nClasses and Objects\n• An object is an instantiation of a class.\n• Alternately, a class defines the structure of its\nobjects.\n• A class definition includes variables (data) and\nmethods (actions) that\n<eos>"}
{"text": "<bos>\ndetermine the behavior of\nan object.\n• Example: the Date class (next slide)\npackage ch01.dates; public int getMonth()\npublic class Date {\n{ return month;\nprotected int year, month, day; }\npublic static final\nint MINYEAR = 1583; public int getDay()\n{\n// Constructor return day;\npublic Date(int newMonth, }\nint newDay,\nint newYear) public int lilian()\n{ {\nmonth = newMonth; // Returns the Lilian Day Number\nday = newDay; // of this date.\nyear = newYear; // Algorithm goes here.\n} }\n// Observers @Override\npublic int getYear() public String toString()\n{ // Returns this date as a String.\nreturn year; {\n} return(month + \"/\" + day\n+ \"/\" + year);\n}\n}\nJava Access Control Modifiers\nWithin Within\nWithin the Subclasses Subclasses\nEverywhere\nClass in the Same in Other\nPackage Packages\npublic X X X X\n<eos>"}
{"text": "<bos>\nprotected X X X\npackage X X\nprivate X\nThe Unified Method\n• Use-case driven: a description of a sequence of\nactions performed by a user within the system to\naccomplish some task\n• Iterative and incremental: involves a series of\ndevelopment cycles\n• Architecture-centric: diagrams indicate the\noverall structure of the system, the way in which\nits components interact\nClass Diagram for Date Class\nObjects\nDate myDate = new Date(6, 24, 1951);\nDate yourDate = new Date(10, 11, 1953);\nDate ourDate = new Date(6, 15, 1985);\nApplications\n• An object-oriented application is a set of objects\nworking together, by sending each other\nmessages, to solve a problem.\n• In object-oriented programming a key step is\nidentifying classes that can be used to help\nsolve a problem.\n• An example – using our Date class\n<eos>"}
{"text": "<bos>\nto solve the\nproblem of calculating the number of days\nbetween two dates (next 3 slides)\nDaysBetween Design\ndisplay instructions\nprompt for and read in info about the first date\ncreate the date1 object\nprompt for and read in info about the second date\ncreate the date2 object\nif dates entered are too early\nprint an error message\nelse\nuse the date.lilian method to obtain the\nLilian Day Numbers\ncompute and print the number of days\nbetween the dates\n//----------------------------------------------------------------------\n// DaysBetween.java by Dale/Joyce/Weems Chapter 1\n//\n// Asks the user to enter two \"modern\" dates and then reports\n// the number of days between the two dates.\n//----------------------------------------------------------------------\npackage ch01.apps;\nimport java.util.Scanner;\n<eos>"}
{"text": "<bos>\npublic class DaysBetween\n{\npublic static void main(String[] args)\n{\nScanner scan = new Scanner(System.in);\nint day, month, year;\nSystem.out.println(\"Enter two 'modern' dates: month day year\");\nSystem.out.println(\"For example January 12, 1954 would be: 1 12 1954\");\nSystem.out.println();\nSystem.out.println(\"Modern dates occur after \" + Date.MINYEAR + \".\");\nSystem.out.println();\nSystem.out.println(\"Enter the first date:\");\nmonth = scan.nextInt();\nday = scan.nextInt();\nyear = scan.nextInt();\nDate d1 = new Date(month, day, year);\nSystem.out.println(\"Enter the second date:\");\nmonth = scan.nextInt();\nday = scan.nextInt();\nyear = scan.nextInt();\nDate d2 = new Date(month, day, year);\nif ((d1.getYear() <= Date.MINYEAR)\n||\n(d2.getYear() <= Date.MINYEAR))\nSystem.out.println(\"You entered a 'pre-modern'\n<eos>"}
{"text": "<bos>\ndate.\");\nelse\n{\nSystem.out.println(\"The number of days between\");\nSystem.out.print(d1);\nSystem.out.print(\" and \");\nSystem.out.print(d2);\nSystem.out.print(\" is \");\nSystem.out.println(Math.abs(d1.lilian() - d2.lilian()));\n}\n}\n}\n1.2 Organizing Classes\n• During object-oriented development hundreds of\nclasses can be generated or reused to help build\na system.\n• The task of keeping track of these classes would\nbe impossible without organizational structure.\n• Two of the most important ways of organizing\nJava classes are\n– inheritance: classes are organized in an “is-a”\nhierarchy\n– packages: let us group related classes together into a\nsingle named unit\nInheritance\n• Allows programmers\nto create a new class\nthat is a specialization\nof an existing class.\n• We say that the new\nclass is a subclass\n<eos>"}
{"text": "<bos>\nof\nthe existing class,\nwhich in turn is the\nsuperclass of the new\nclass.\nExample of Inheritance\npackage ch01.dates;\npublic class IncDate extends Date\n{\npublic IncDate(int newMonth, int newDay, int newYear)\n{\nsuper(newMonth, newDay, newYear);\n}\npublic void increment()\n// Increments this IncDate to represent the next day.\n// For example if this = 6/30/2005 then this becomes 7/1/2005.\n{\n// increment algorithm goes here\n}\n}\nDeclaring and Using\nDate and IncDate Objects\nDate myDate = new Date(6, 24, 1951);\nIncDate aDate = new IncDate(1, 11, 2001);\nSystem.out.println(\"mydate day is: \" + myDate.getDay());\nSystem.out.println(\"aDate day is: \" + aDate.getDay());\naDate.increment();\nSystem.out.println(\"the day after is: \" + aDate.getDay());\nSee Extended Class Diagram next slide.\nJava’s Inheritance Tree\n<eos>"}
{"text": "<bos>\n• Java supports single inheritance only.\n• Method calls are resolved by searching up the\ninheritance tree.\n• All Java classes can be traced up to the Object\nclass.\n• We use the @Override notation to indicate the\nredefinition of an inherited method.\nInheritance-Based Polymorphism\n• Polymorphism – an object variable can\nreference objects of different classes at different\ntimes.\n• A variable declared to be of “type” T can hold a\nreference to an object of type T or of any\ndescendant of T.\n• See example, next slide.\n// cutoff is random int between 1 and 100\nObject obj;\nif (cutoff <= 50)\nobj = new String(\"Hello\");\nelse\nobj = new Date(1,1,2015);\nSystem.out.println(obj.toString());\nWhat does the above code print?\nWe cannot predict. The binding of the obj variable to\na class (String or Date) occurs\n<eos>"}
{"text": "<bos>\ndynamically, at run time.\nobj is a polymorphic object.\nPackages\n• Java lets us group related classes together into\na unit called a package. Packages provide\nseveral advantages. They\n– let us organize our files.\n– can be compiled separately and imported into our\nprograms.\n– make it easier for programs to use common class\nfiles.\n– help us avoid naming conflicts (two classes can have\nthe same name if they are in different packages).\nUsing Packages\n• A Java compilation unit can consist of a file with\n– the keyword package followed by an identifier indicating the\nname of the package:\npackage someName;\n– import declarations, to make the contents of other packages\navailable:\nimport java.util.Scanner;\n– one or more declarations of classes; exactly one of these\nclasses must be public\n• The classes\n<eos>"}
{"text": "<bos>\ndefined in the file are members of the\npackage.\n• The imported classes are not members of the package.\n• The name of the file containing the compilation unit must\nmatch the name of the public class within the unit.\nUsing Packages\n• Each Java compilation unit is stored in its own\nfile.\n• The Java system identifies the file using a\ncombination of the package name and the name\nof the public class in the compilation unit.\n• Java restricts us to having a single public class\nin a file so that it can use file names to locate all\npublic classes.\n• Thus, a package with multiple public classes\nmust be implemented with multiple compilation\nunits, each in a separate file.\nUsing Packages\n• In order to access the contents of a package\nfrom within a program, you must import it into\nyour program:\nimport\n<eos>"}
{"text": "<bos>\npackagename.*;\nimport packagename.Classname;\n• The Java package rules are defined to work\nseamlessly with hierarchical file systems:\nimport ch02.stacks.*;\n1.3 Exceptional Situations\n• Exceptional situation Associated with an\nunusual, sometimes unpredictable event,\ndetectable by software or hardware, which\nrequires special processing. The event may or\nmay not be erroneous.\n• For example:\n– a user enters an input value of the wrong type\n– while reading information from a file, the end of the\nfile is reached\n– an impossible operation is requested of an object,\nsuch as an attempt to access information that is not\nyet available\nExceptions with Java\n• The Java exception mechanism has three major\nparts:\n– Defining the exception – usually as a subclass of\nJava's Exception class\n– Generating\n<eos>"}
{"text": "<bos>\n(raising) the exception – by recognizing\nthe exceptional situation and then using Java's throw\nstatement to \"announce\" that the exception has\noccurred\n– Handling the exception – using Java's try – catch\nstatement to discover that an exception has been\nthrown and then take the appropriate action\nExceptions and ADTs\nAn Example\n• We create a new date related class called\nSafeDate that includes a constructor which\nthrows an exception if it is passed an illegal date\n• First, we create our own exception class:\npublic class DateOutOfBoundsException extends Exception\n{\npublic DateOutOfBoundsException()\n{\nsuper();\n}\npublic DateOutOfBoundsException(String message)\n{\nsuper(message);\n}\n}\nHere is an example of a constructor that\nthrows the exception:\npublic SafeDate(int newMonth, int newDay, int\n<eos>"}
{"text": "<bos>\nnewYear)\nthrows DateOutOfBoundsException\n{\nif ((newMonth <= 0) || (newMonth > 12))\nthrow new DateOutOfBoundsException(\"month \" + newMonth + \"out of range\");\nelse\nmonth = newMonth;\nday = newDay;\nif (newYear < MINYEAR)\nthrow new DateOutOfBoundsException(\"year \" + newYear +\n\" is too early\");\nelse\nyear = newYear;\n}\nExample of a program that throws the exception out to interpreter:\npublic class UseSafeDate\n{\npublic static void main(String[] args)\nthrows DateOutOfBoundsException\n{\nSafeDate theDate;\n// Program prompts user for a date\n// M is set equal to user’s month\n// D is set equal to user’s day\n// Y is set equal to user’s year\ntheDate = new SafeDate(M, D, Y);\n// Program continues ...\n}\n}\nThe interpreter will stop the program and\nprint an “exception” message, for example\nException in thread\n<eos>"}
{"text": "<bos>\n\"main\" DateOutOfBoundsException: year 1051 is too early\nat SafeDate.<init>(SafeDate.java:18)\nat UseSafeDate.main(UseSafeDate.java:57)\nAn example of a program that catches and handles the exception:\npublic class UseSafeDate\n{\npublic static void main(String[] args)\n{\nSafeDate theDate;\nboolean DateOK = false;\nwhile (!DateOK)\n{\n// Program prompts user for a date\n// M is set equal to user’s month,\n// D is set equal to user’s day\n// Y is set equal to user’s year\ntry\n{\ntheDate = new SafeDate(M, D, Y);\nDateOK = true;\n}\ncatch(DateOutOfBoundsException DateOBExcept)\n{\noutput.println(DateOBExcept.getMessage());\n}\n}\n// Program continues ...\n}\n}\nGeneral guidelines for using\nexceptions\n• An exception may be handled any place in the software\nhierarchy—from the place in the program module where\nit is first\n<eos>"}
{"text": "<bos>\ndetected through the top level of the program.\n• Unhandled built-in exceptions carry the penalty of\nprogram termination.\n• Where in an application an exception is handled is a\ndesign decision; however, exceptions should always be\nhandled at a level that knows what the exception means.\n• An exception need not be fatal.\n• For non-fatal exceptions, the thread of execution can\ncontinue from various points in the program, but\nexecution should continue from the lowest level that can\nrecover from the exception.\nJava RunTimeException class\n• Exceptions of this class are thrown when a\nstandard run-time program error occurs.\n• Examples of run-time errors are division-by-zero\nand array-index-out-of-bounds.\n• These exceptions can happen in virtually any\nmethod or segment of code, so we are not\n<eos>"}
{"text": "<bos>\nrequired to explicitly handle these exceptions.\n• These exceptions are classified as unchecked\nexceptions.\nError Situations and ADTs\n• When dealing with error situations within our\nADT methods, we have several options:\n– Detect and handle the error within the method itself.\nBest approach if the error can be handled internally.\n– Detect the error within the method, throw an\nexception related to the error and force the calling\nmethod to deal with the exception. If not clear how to\nhandle an error situation, this approach might be best\n… throw it out to a level where it can be handled.\n– Ignore the error situation. With this approach, if the\npreconditions of a method are not met, the method is\nnot responsible for the consequences.\n1.4 Data Structures\n• The way you view and structure the data\n<eos>"}
{"text": "<bos>\nthat\nyour programs manipulate greatly influences\nyour success.\n• A language's set of primitive types (Java's are\nbyte, char, short, int, long, float, double, and\nboolean) are not sufficient, by themselves, for\ndealing with data that have many parts and\ncomplex interrelationships among those parts.\n• Data structures provide this ability.\nImplementation Dependent\nStructures\nArray Linked List\nImplementation Independent\nStructures\nStack\nQueue\nSorted List\nMap\nTree Graph\n1.5 Basic Structuring Mechanisms\n• All programs and data are held in memory.\n• Memory consists of a contiguous sequence of\naddressable words:\n• A variable in our program corresponds to a\nmemory location.\nDirect Addressing …\n• … is when the memory location associated with\nthe variable holds the value of the variable.\n• This\n<eos>"}
{"text": "<bos>\ncorresponds to how primitive variables are\nused in Java:\nIndirect Addressing …\n• … is when the\nmemory location\nassociated with the\nvariable holds the\naddress of the\nlocation that holds\nthe value of the\nvariable.\n• This corresponds to\nhow reference\nvariables (objects)\nare used in Java\nThe Two Basic Structuring\nMechanisms\nThere are two basic structuring mechanisms\nprovided in Java (and many other high level\nlanguages)\nArrays\nReferences\nReferences\n• Are memory addresses (use indirect addressing)\n• Sometimes referred to as links, addresses, or\npointers\n• Java uses the reserved word null to indicate\nan “absence of reference”\n• A variable of a reference (non-primitive) type\nholds the address of the memory location that\nholds the value of the variable, rather than the\nvalue itself.\n• This has\n<eos>"}
{"text": "<bos>\nseveral ramifications …\nStatements\nAssignment\nBe of aliases\naware\nStatements\nComparison\nManagement\nGarbage\n• Garbage The set of currently unreachable\nobjects\n• Garbage collection The process of finding all\nunreachable objects and deallocating their\nstorage space\n• Deallocate To return the storage space for an\nobject to the pool of free memory so that it can\nbe reallocated to new objects\n• Dynamic memory management The\nallocation and deallocation of storage space as\nneeded while an application is executing\nArrays\n• We assume students are already familiar with\narrays. The subsection on pages 38 to 43\nreviews some of the subtle aspects of using\narrays in Java:\n– they are handled “by reference”\n– they must be instantiated\n– initialization lists are supported\n– you can use arrays of objects\n–\n<eos>"}
{"text": "<bos>\nyou can use multi-dimensional arrays\n1.6 Comparing Algorithms:\nOrder of Growth Analysis\n• Alice: “I’m thinking of a number between 1 and\n1,000.”\n• Bob: “Is it 1?”\n• Alice: “No . . . it’s higher.”\n• Bob: “Is it 2?”\n• Alice: “No . . . it’s higher.”\n• Bob: “Is it 3?”\n• Alice: rolls her eyes . . .\nAlgorithms\n• A sequence of unambiguous instructions that\nsolve a problem, within a finite amount of time,\ngiven a set of valid input\n• Analysis of algorithms is important area of\ncomputer science\n• The efficiency of algorithms and the code that\nimplements them can be studied in terms of both\ntime (how fast it runs) and space (the amount of\nmemory required).\ntime and space can be\ninter-related\nCounting Operations\n• To measure the complexity of an algorithm we\nattempt to count the number of basic\n<eos>"}
{"text": "<bos>\noperations\nrequired to complete the algorithm\n• Rather than count all operations, select a\nfundamental operation, an operation that is\nperformed “the most”, and count it.\nCounting Operations Example\nProblem: guess secret • Number of operations:\nnumber between 1 and\n– Depends on how “lucky” you\n1,000 (the Hi-Lo game) are\nHi-Lo Sequential Search:\nSet guess to 0\ndo\nIncrement guess by 1\nAnnounce guess\nwhile (guess is not\ncorrect)\nThree Complexity Cases\n• Best case complexity Related to the minimum number\nof steps required by an algorithm, given an ideal set of\ninput values in terms of efficiency\n• Average case complexity Related to the average\nnumber of steps required by an algorithm, calculated\nacross all possible sets of input values\n• Worst case complexity Related to the maximum\nnumber of\n<eos>"}
{"text": "<bos>\nsteps required by an algorithm, given the\nworst possible set of input values in terms of efficiency\n• To simplify analysis yet still provide a useful approach,\nwe usually use worst case complexity\nCounting Operations Example\nProblem: guess secret • Number of operations\nnumber between 1 and worst case is:\n1,000 (the Hi-Lo game)\n– 1 to set guess\n– 1000 increments\nHi-Lo Sequential Search: – 1000 announces\nSet guess to 0 – 1000 tests for correctness\ndo – Total: 3001 ….. but\nIncrement guess by 1\n• This is too dependent on\nAnnounce guess\n– counting approach\nwhile (guess is not\n– language\ncorrect)\n– language level\n– compiler\n• and is difficult for more\ncomplex algorithms\nIsolate a fundamental operation\n• Rather than count all operations, select a\nfundamental operation, an operation that is\n<eos>"}
{"text": "<bos>\nperformed “the most”, and count it.\n• For the “guess the number” problem a basic\noperation might be “announce guess” …\n– count is 1,000\n• But what if problem size changes:\n– “I’m thinking of a number between 1 and 1 million!”\nSize of Input\n• To make our count generally useable we\nexpress it as a function of the size of the\nproblem\n• “I’m thinking of number between 1 and N”\n– Sequential Search: N “announces”\n– Binary Search (cut search area in half at each step):\nlog N “announces”\n2\nA further simplification:\nOrder of Growth Notation\n• We measure the complexity of an algorithm as the\nnumber of times a fundamental operation is performed,\nrepresented as a function of the size of the problem.\n• For example, an algorithm performed on an N element\narray may require 2N2 + 4N + 3 comparisons.\n•\n<eos>"}
{"text": "<bos>\nOrder of growth notation expresses computing time\n(complexity) as the term in the function that increases\nmost rapidly relative to the size of a problem.\n• In our example, rather than saying the complexity is 2N2\n+ 4N + 3 we say it is O(N2).\n• This works just as well for most purposes and simplifies\nthe analysis and use of the complexity measure.\nSelection Sort\n• If we were handed a list of names on a sheet of\npaper and asked to put them in alphabetical\norder, we might use this general approach:\n– Select the name that comes first in alphabetical order,\nand write it on a second sheet of paper.\n– Cross the name out on the original sheet.\n– Repeat steps 1 and 2 for the second name, the third\nname, and so on until all the names on the original\nsheet have been crossed out and written onto the\n<eos>"}
{"text": "<bos>\nsecond sheet, at which point the list on the second\nsheet is sorted.\nAn improvement\n• Our algorithm is simple but it has one drawback:\nIt requires space to store two complete lists.\n• Instead of writing the “first” name onto a\nseparate sheet of paper, exchange it with the\nname in the first location on the original sheet.\nAnd so on.\nSelection Sort Algorithm\nSelectionSort\nfor current going from 0 to SIZE - 2\nFind the index in the array of the smallest unsorted element\nSwap the current element with the smallest unsorted one\nAn example is depicted on the following slide …\nSelection Sort Snapshot\nSelection Sort Code\nstatic int minIndex(int startIndex, int endIndex)\n// Returns the index of the smallest value in\n// values[startIndex]..values[endIndex].\n{\nint indexOfMin = startIndex;\nfor (int\n<eos>"}
{"text": "<bos>\nindex = startIndex + 1; index <= endIndex; index++)\nif (values[index] < values[indexOfMin])\nindexOfMin = index;\nreturn indexOfMin;\n}\nstatic void selectionSort()\n// Sorts the values array using the selection sort algorithm.\n{\nint endIndex = SIZE – 1;\nfor (int current = 0; current < endIndex; current++)\nswap(current, minIndex(current, endIndex));\n}\nSelection Sort Analysis\n• We describe the number of comparisons as a function of\nthe number of elements in the array, i.e., SIZE. To be\nconcise, in this discussion we refer to SIZE as N\n• The minIndex method is called N - 1 times\n• Within minIndex, the number of comparisons varies:\n– in the first call there are N - 1 comparisons\n– in the next call there are N - 2 comparisons\n– and so on, until in the last call, when there is only 1 comparison\n•\n<eos>"}
{"text": "<bos>\nThe total number of comparisons is\n(N – 1) + (N – 2) + (N – 3) + ... + 1\n= N(N – 1)/2 = 1/2N2 – 1/2N\n• The Selection Sort algorithm is O(N2)\nCommon Orders of Magnitude\n• O(1) is called bounded time. The amount of work is not\ndependent on the size of the problem.\n• O(log N) is called logarithmic time. Algorithms that\n2\nsuccessively cut the amount of data to be processed in\nhalf at each step typically fall into this category.\n• O(N) is called linear time. Adding together the elements\nof an array is O(N).\n• O(N log N) is called N log N time. Good sorting\n2\nalgorithms, such as Quicksort, Heapsort, and Mergesort\npresented in Chapter 11, have N log N complexity.\n• O(N2) is called quadratic time. Some simple sorting\nalgorithms such as Selection Sort are O(N2) algorithms.\n• O(2N) is called\n<eos>"}
{"text": "<bos>\nexponential time. These algorithms are\nextremely costly.\nComparison of Growth Rates\nN log N Nlog N N2 N3 2N\n2 2\n1 0 1 1 1 2\n2 1 2 4 8 4\n4 2 8 16 64 16\n16 4 64 256 4,096 65,536\n64 6 384 4,096 262,144 requires\n20 digits\n128 7 896 16,384 2,097,152 requires\n39 digits\n256 8 2,048 65,536 16,777,216 requires\n78 digits\nWays to simplify analysis of\nalgorithms\n• Consider worst case only\n– but average case can also be important\n• Count a fundamental operation\n– careful; make sure it is the most used operation within\nthe algorithm\n• Use Order of Growth complexity\n– especially when interested in “large” problems\n<eos>"}
