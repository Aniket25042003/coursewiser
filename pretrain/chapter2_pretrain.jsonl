{"text": "<bos>\nChapter 2\nThe Stack\nADT\nChapter 2: The Stack ADT\n2.1 – Abstraction\n2.2 – The Stack\n2.3 – Collection Elements\n2.4 – The Stack Interface\n2.5 – Array-Based Stack Implementations\n2.6 – Application: Balanced Expressions\n2.7 – Introduction to Linked Lists\n2.8 – A Link-Based Stack\n2.9 – Application: Postfix Expression Evaluator\n2.10 – Stack Variations\n2.1 Abstraction\n• Abstraction A model of a system that includes\nonly the details essential to the perspective of\nthe viewer of the system\n• Information hiding The practice of hiding\ndetails within a module with the goal of\ncontrolling access to the details from the rest of\nthe system\n• Data abstraction The separation of a data\ntype’s logical properties from its implementation\n• Abstract data type (ADT) A data type whose\nproperties (domain and\n<eos>"}
{"text": "<bos>\noperations) are specified\nindependently of any particular implementation\nADT Perspectives or Levels\n• Application (or user or client or external) level: We use\nthe ADT to solve a problem. When working at this level\nwe only need to know how to create instances of the\nADT and invoke its operations.\n• Abstract (or logical) level: Provides an abstract view of\nthe data values (the domain) and the set of operations to\nmanipulate them. At this level, we deal with the “what”\nquestions. What is the ADT? What does it model? What\nare its responsibilities? What is its interface?\n• Implementation (or concrete or internal) level: Provides a\nspecific representation of the structure to hold the data\nand the implementation of the operations. Here we deal\nwith the “how” questions.\nPreconditions and\n<eos>"}
{"text": "<bos>\nPostconditions\n• Preconditions Assumptions that must be true\non entry into a method for it to work correctly\n• Postconditions or Effects The results\nexpected at the exit of a method, assuming that\nthe preconditions are true\n• We specify pre- and postconditions for a method\nin a comment at the beginning of the method\nJava: Abstract Method\n• Only includes a description of its parameters\n• No method bodies or implementations are\nallowed.\n• In other words, only the interface of the method\nis included.\nJava Interfaces\n• Similar to a Java class\n– can include variable declarations\n– can include methods\n• However\n– Variables must be constants\n– Methods must be abstract.\n– A Java interface cannot be instantiated.\n• We can use an interface to formally specify the logical\nlevel of an ADT:\n– It\n<eos>"}
{"text": "<bos>\nprovides a template for classes to fill.\n– A separate class then \"implements\" it.\n• For example, see the FigureInterface interface and\nthe Circle class (next slide) and Rectangle class\n(following slide) that implement it\nFigureInterface Circle Class\npackage ch02.figures; package ch02.figures;\npublic interface FigureInterface public class Circle implements\n{ FigureInterface\nfinal double PI = 3.14; {\nprotected double radius;\ndouble perimeter();\n// Returns perimeter of this figure. public Circle(double radius)\n{\ndouble area(); this.radius = radius;\n// Returns area of this figure. }\n}\npublic double perimeter()\n{\nreturn(2 * PI * radius);\n}\npublic double area()\n{\nreturn(PI * radius * radius);\n}\n}\nFigureInterface Rectangle Class\npackage ch02.figures; package ch02.figures;\npublic interface\n<eos>"}
{"text": "<bos>\nFigureInterface public class Rectangle implements\n{ FigureInterface\nfinal double PI = 3.14; {\nprotected double length, width;\ndouble perimeter();\n// Returns perimeter of this figure. public Rectangle(double length,\ndouble width)\ndouble area(); {\n// Returns area of this figure. this.length = length;\n} this.width = width;\n}\npublic double perimeter()\n{\nreturn(2 * (length + width));\n}\npublic double area()\n{\nreturn(length * width);\n}\n}\nUML Class Diagram\nBenefits from Using Interfaces\n• We can formally check the syntax of our specification.\nWhen we compile the interface, the compiler uncovers\nany syntactical errors in the method interface definitions.\n• We can formally verify that the interface “contract” is met\nby the implementation. When we compile the\nimplementation, the compiler ensures that\n<eos>"}
{"text": "<bos>\nthe method\nnames, parameters, and return types match what was\ndefined in the interface.\n• We can provide a consistent interface to applications\nfrom among alternate implementations of the ADT.\nInterface-Based Polymorphism\n• Polymorphism – an object variable can\nreference objects of different classes at different\ntimes.\n• A variable declared to be of an interface\n“type” T can hold a reference to any object of\nclass that implements that interface.\n• See example, next slide.\nFigureInterface[] figures = new FigureInterface[COUNT];\nfinal int COUNT = 5;\n// generate figures\nfor (int i = 0; i < COUNT; i++)\n{\nswitch (rand.nextInt(2))\n{\ncase 0: figures[i] = new Circle(1.0);\nbreak;\ncase 1: figures[i] = new Rectangle(1.0, 2.0);\nbreak;\n}\n}\nWhat is held in figures[3]?\nWe cannot predict. The binding of\n<eos>"}
{"text": "<bos>\nfigures[3] to a class\n(Circle or Rectangle) occurs dynamically, at run time.\nfigures[3] is a polymorphic object.\n2.2 The Stack\n• Stack A structure in which elements are added\nand removed from only one end; a “last in, first\nout” (LIFO) structure\nOperations on Stacks\n• Constructor\n– new - creates an empty stack\n• Transformers\n– push - adds an element to the top of a stack\n– pop - removes the top element off the stack\n• Observer\n– top - returns the top element of a stack\nEffects of\nStack\nOperations\nUsing Stacks\n• Stacks are often used for “system”\nprogramming:\n– Programming language systems use a stack to keep\ntrack of sequences of operation calls\n– Compilers use stacks to analyze nested language\nstatements\n– Operating systems save information about the current\nprocess on a stack, so that it\n<eos>"}
{"text": "<bos>\ncan work on a higher-\npriority, interrupting process\n• Stacks are good for storing “postponed\nobligations”\n2.3 Collection Elements\n• Collection An object that holds other objects.\nTypically we are interested in inserting,\nremoving, and obtaining the elements of a\ncollection.\n• A stack is an example of a Collection ADT. It\ncollects together elements for future use, while\nmaintaining a first in – last out ordering among\nthe elements.\nHow can we implement stacks that\nhold different types of elements?\nOne approach is to implement a separate stack\nclass for each element type:\nThis approach is too redundant and not\ngenerally useful.\nHow can we implement stacks that\nhold different types of elements?\nAnother approach is to implement a stack class\nthat can hold elements of class Object:\nThis\n<eos>"}
{"text": "<bos>\napproach requires extra effort to keep track\nof, and indicate, exactly what is in the stack.\nCollections of Class Object\n• Note: whenever an element is removed from the\ncollection it can only be referenced as an\nObject. If you intend to use it as something\nelse you must cast it into the type that you\nintend to use.\n• For example:\ncollection.push(“E. E. Cummings”); // push string on a stack\nString poet = (String) collection.top(); // cast top to String\nSystem.out.println(poet.toLowerCase()); // use the string\nHow can we implement stacks that\nhold different types of elements?\nAnother approach is to implement a stack class\nthat can hold elements of a particular interface:\nThis approach could work in certain specific situations\nbut it is not a general solution.\nHow can we implement stacks that\n<eos>"}
{"text": "<bos>\nhold different types of elements?\nGeneric stack – implement once and indicate the type\nof element to be held on instantiation\nThis is the approach we will use:\n• Parameterized types\n• Declared as <T>\n• Actual type provided upon instantiation\nGeneric Collections\n• Example of beginning of Stack class definition:\npublic class Stack<T>\n{\nprotected T[ ] elements ;\nprotected int topIndex = -1;\n...\n• Example of application declaring various stacks:\nStack<Integer> numbers;\nStack<BankAccount> investments;\nStack<String> answers;\n2.4 The Stack Interface\n• Recall from Section 2.1 that a stack is a \"last-in\nfirst-out\" structure, with primary operations\n– push - adds an element to the top of the stack\n– pop - removes the top element off the stack\n– top - returns the top element of a stack\n• In addition\n<eos>"}
{"text": "<bos>\nwe need a constructor that creates an\nempty stack\n• Our Stack ADT will be a generic stack.\n– The class of elements that a stack stores will be\nspecified by the client code at the time the stack is\ninstantiated.\nExceptional Situations\n• pop and top – what if the stack is empty?\n– throw a StackUnderflowException\n– plus define an isEmpty method for use by the\napplication\n• push – what if the stack is full?\n– throw a StackOverflowException\n– plus define an isFull method for use by the\napplication\nStackInterface\npackage ch02.stacks;\npublic interface StackInterface<T>\n{\nvoid push(T element) throws StackOverflowException;\n// Throws StackOverflowException if this stack is full,\n// otherwise places element at the top of this stack.\nvoid pop() throws StackUnderflowException;\n// Throws\n<eos>"}
{"text": "<bos>\nStackUnderflowException if this stack is empty,\n// otherwise removes top element from this stack.\nT top() throws StackUnderflowException;\n// Throws StackUnderflowException if this stack is empty,\n// otherwise returns top element of this stack.\nboolean isFull();\n// Returns true if this stack is full, otherwise returns false.\nboolean isEmpty();\n// Returns true if this stack is empty, otherwise returns false.\n}\nExample Use of a Stack\n• Instructors can now review and demonstrate the\nReverseStrings application found in package\nch02.apps.\n2.5 Array-Based Implementations\n• In this section we study an array-based\nimplementation of a bounded Stack ADT.\n• Additionally, we look at an alternate unbounded\nimplementation that uses the Java Library\nArrayList class.\nThe beginning of the\nArrayBoundedStack\n<eos>"}
{"text": "<bos>\nClass\n//---------------------------------------------------------------------\n// ArrayBoundedStack.java Dale/Joyce/Weems Chapter 2\n//\n// Implements StackInterface using an array to hold stack elements.\n//\n// Two constructors are provided: one that creates an array of a default\n// size and one that allows the calling program to specify the size.\n//---------------------------------------------------------------------------\npackage ch02.stacks;\npublic class ArrayBoundedStack<T> implements StackInterface<T>\n{\nprotected final int DEFCAP = 100; // default capacity\nprotected T[] elements; // holds stack elements\nprotected int topIndex = -1; // index of top element in stack\npublic ArrayBoundedStack()\n{\nelements = (T[]) new Object[DEFCAP];\n}\npublic ArrayBoundedStack(int maxSize)\n{\nelements = (T[])\n<eos>"}
{"text": "<bos>\nnew Object[maxSize];\n}\nVisualizing the stack\n• The empty stack: • After pushing “A”, “B”\nand “C”:\nDefinitions of Stack Operations\npublic boolean isEmpty()\n// Returns true if this stack is empty, otherwise returns false.\n{\nreturn (topIndex == -1);\n}\npublic boolean isFull()\n// Returns true if this stack is full, otherwise returns false.\n{\nreturn (topIndex == (elements.length - 1));\n}\nDefinitions of Stack Operations\npublic void push(T element)\n{\nif (isFull())\nthrow new StackOverflowException(\"Push attempted on a full stack.\");\nelse\n{\ntopIndex++;\nelements[topIndex] = element;\n}\n}\npublic void pop()\n{\nif (isEmpty())\nthrow new StackUnderflowException(\"Pop attempted on empty stack.\");\nelse\n{\nelements[topIndex] = null;\ntopIndex--;\n}\n}\nDefinitions of Stack Operations\npublic T top()\n{\nT topOfStack =\n<eos>"}
{"text": "<bos>\nnull;\nif (isEmpty())\nthrow new StackUnderflowException(\"Top attempted on empty stack.\");\nelse\ntopOfStack = elements[topIndex];\nreturn topOfStack;\n}\nFigure depicts Application,\nImplementation and Abstract\nviews of the code sequence:\nStackInterface<String> myStack;\nmyStack = new\nArrayBoundedStack<String>(3);\nmyStack.push(A);\nmyStack.push(B);\nThe beginning of the\nArrayListStack Class\n//---------------------------------------------------------------------------\n// ArrayListStack.java by Dale/Joyce/Weems Chapter 2\n//\n// Implements an unbounded stack using an ArrayList.\n//---------------------------------------------------------------------------\npackage ch02.stacks;\nimport java.util.*;\npublic class ArrayListStack<T> implements StackInterface<T>\n{\nprotected ArrayList<T> elements; // ArrayList\n<eos>"}
{"text": "<bos>\nthat holds stack elements\npublic ArrayListStack()\n{\nelements = new ArrayList<T>();\n}\nDefinitions of Stack Operations\npublic boolean isEmpty()\n// Returns true if this stack is empty, otherwise returns false.\n{\nreturn (elements.size() == 0);\n}\npublic boolean isFull()\n// Returns false – an ArrayListStack is never full.\n{\nreturn false;\n}\nDefinitions of Stack Operations\npublic void push(T element)\n{\nelements.add(element);\n}\npublic void pop()\n{\nif (isEmpty())\nthrow new StackUnderflowException(\"Pop attempted on empty stack.\");\nelse\nelements.remove(elements.size() - 1);\n}\npublic T top()\n{\nT topOfStack = null;\nif (isEmpty())\nthrow new StackUnderflowException(\"Top attempted on empty stack.\");\nelse\ntopOfStack = elements.get(elements.size() - 1);\nreturn topOfStack;\n}\n2.6 Application: Balanced\n<eos>"}
{"text": "<bos>\nExpressions\n• Given a set of grouping symbols, determine if the open\nand close versions of each symbol are matched\ncorrectly.\n• We’ll focus on the normal pairs, (), [], and {}, but in theory\nwe could define any pair of symbols (e.g., < > or / \\) as\ngrouping symbols.\n• Any number of other characters may appear in the input\nexpression, before, between, or after a grouping pair,\nand an expression may contain nested groupings.\n• Each close symbol must match the last unmatched\nopening symbol and each open grouping symbol must\nhave a matching close symbol.\nExamples\nThe Balanced Class\n• To help solve our problem we create a class\ncalled Balanced, with two instance variables of\ntype String (openSet and closeSet) and a\nsingle exported method test\n• The Constructor is:\npublic Balanced(String\n<eos>"}
{"text": "<bos>\nopenSet, String closeSet)\n// Preconditions: No character is contained more than once in the\n// combined openSet and closeSet strings.\n// The size of openSet == the size of closeSet.\n{\nthis.openSet = openSet;\nthis.closeSet = closeSet;\n}\nThe test method\n• Takes an expression as a string argument and\nchecks to see if the grouping symbols in the\nexpression are balanced.\n• We use an integer to indicate the result:\n– 0 means the symbols are balanced, such as (([xx])xx)\n– 1 means the expression has unbalanced symbols,\nsuch as (([xx}xx))\n– 2 means the expression came to an end prematurely,\nsuch as (([xxx])xx\nThe test method\n• For each input character, it does one of three\ntasks:\n– If the character is an open symbol, it is pushed on a\nstack.\n– If the character is a close symbol, it must be checked\n<eos>"}
{"text": "<bos>\nagainst the last open symbol, which is obtained from\nthe top of the stack. If they match, processing\ncontinues with the next character. If the close symbol\ndoes not match the top of the stack, or if the stack is\nempty, then the expression is ill-formed.\n– If the character is not a special symbol, it is skipped.\nTest for Well-Formed Expression\nAlgorithm (String expression)\nCreate a new stack of size equal to the length of subject\nSet stillBalanced to true\nGet the first character from expression\nwhile (the expression is still balanced\nAND\nthere are still more characters to process)\nProcess the current character\nGet the next character from expression\nif (!stillBalanced)\nreturn 1\nelse if (stack is not empty)\nreturn 2\nelse\nreturn 0\nExpansion of\n“Process the current character”\nif (the character\n<eos>"}
{"text": "<bos>\nis an open symbol)\nPush the open symbol character onto the stack\nelse if (the character is a close symbol)\nif (the stack is empty)\nSet stillBalanced to false\nelse\nSet open symbol character to the value at the top of the stack\nPop the stack\nif the close symbol character does not “match” the open symbol character\nSet stillBalanced to false\nelse\nSkip the character\nCode and Demo\n• Instructors can now walk through the code contained in\nBalanced.java found in the ch02.balanced\npackage and BalancedCLI.java and/or\nBalancedGUI.java found in the ch02.apps package,\nreview the notes on pages 104 and 105, and\ndemonstrate the running program.\nProgram Architecture\n2.7 Introduction to Linked Lists\n• Arrays and Linked Lists are both basic building\nblocks for implementing data structures.\n• They differ in\n<eos>"}
{"text": "<bos>\nterms of\n– use of memory\n– manner of access\n– efficiency for various operations\n– language support\nNodes of a Linked-List\n• A node in a linked list is an object that holds\nsome important information, such as a string,\nplus a link to the exact same type of object, i.e.\nto an object of the same class.\n• Self-referential class A class that includes an\ninstance variable or variables that can hold a\nreference to an object of the same class.\n• To support our linked implementations of our\nADTs we create the self-referential LLNode\nclass …\n//---------------------------------------------------\nLLNode\n// LLNode.java by Dale/Joyce/Weems Chapter 2\n//\n// Implements <T> nodes for a Linked List.\n//---------------------------------------------------\nClass\npackage support;\npublic class LLNode<T>\n{\n<eos>"}
{"text": "<bos>\nprotected T info;\nprotected LLNode<T> link;\npublic LLNode(T info)\n{\nthis.info = info;\nlink = null;\n}\npublic void setInfo(T info){ this.info = info;}\npublic T getInfo(){ return info; }\npublic void setLink(LLNode<T> link){ this.link = link;}\npublic LLNode<T> getLink(){ return link;}\n}\nUsing the LLNode class\n1: LLNode<String> sNode1 = new LLNode<String>(\"basketball\");\n2: suppose that in addition to sNode1\nwe have sNode2 with info “baseball”\nand perform\nsNode1.setLink(sNode2);\nTraversal of a Linked List\nLLNode<String> currNode = letters;\nwhile (currNode != null)\n{\nSystem.out.println(currNode.getInfo());\ncurrNode = currNode.getLink();\n}\nTracing a Traversal (part 1)\nLLNode<String> currNode = letters;\nwhile (currNode != null)\n{\nSystem.out.println(currNode.getInfo());\ncurrNode =\n<eos>"}
{"text": "<bos>\ncurrNode.getLink();\n}\nInternal View\nOutput\nTracing a Traversal (part 2)\nLLNode<String> currNode = letters;\nwhile (currNode != null)\n{\nSystem.out.println(currNode.getInfo());\ncurrNode = currNode.getLink();\n}\nInternal View\nOutput\nB\nTracing a Traversal (part 3)\nLLNode<String> currNode = letters;\nwhile (currNode != null)\n{\nSystem.out.println(currNode.getInfo());\ncurrNode = currNode.getLink();\n}\nInternal View\nOutput\nB\nC\nTracing a Traversal (part 4)\nLLNode<String> currNode = letters;\nwhile (currNode != null)\n{\nSystem.out.println(currNode.getInfo());\ncurrNode = currNode.getLink();\n}\nInternal View\nOutput\nB\nC\nD\nThree general cases of insertion\nInsertion at the front (part 1)\nSuppose we have the node newNode to insert into the\nbeginning of the letters linked list:\nInsertion at the front (part 2)\nOur\n<eos>"}
{"text": "<bos>\nfirst step is to set the link variable of the newNode\nnode to point to the beginning of the list :\nnewNode.setLink(letters);\nInsertion at the front (part 3)\nTo finish the insertion we set the letters variable to point\nto the newNode, making it the new beginning of the list:\nletters = newNode;\nInsertion at front of an empty list\nThe insertion at the front code is\nnewNode.setLink(letters);\nletters = newNode;\nWhat happens if our insertion code\nis called when the linked list is\nempty?\nAs can be seen at the right the\ncode still works, with the new node\nbecoming the first and only node on\nthe linked list.\n2.8 A Link-Based Stack\n• In this section we study a link-based\nimplementation of the Stack ADT.\n• After discussing the link-based approach we\ncompare our stack implementation approaches.\nThe\n<eos>"}
{"text": "<bos>\nLinkedStack Class\nWe only need a single instance variable, the “pointer” to\nthe ‘top’ of the stack:\npackage ch02.stacks;\nimport support.LLNode;\npublic class LinkedStack<T> implements StackInterface<T>\n{\nprotected LLNode<T> top; // reference to the top of this stack\npublic LinkedStack()\n{\ntop = null;\n}\n. . .\nVisualizing\nthe push\noperation\n(insertion at front of a linked-list)\nStackInterface<String> myStack;\nmyStack = new LinkedStack<String>();\nmyStack.push(A);\nmyStack.push(B);\nmyStack.push(C);\nThe push(C) operation (step 1)\n• Allocate space for the next stack node\nand set the node info to element\n• Set the node link to the previous top of stack\n• Set the top of stack to the new stack node\nThe push(C) operation (step 2)\n• Allocate space for the next stack node\nand set the node info to\n<eos>"}
{"text": "<bos>\nelement\n• Set the node link to the previous top of stack\n• Set the top of stack to the new stack node\nThe push(C) operation (step 3)\n• Allocate space for the next stack node\nand set the node info to element\n• Set the node link to the previous top of stack\n• Set the top of stack to the new stack node\nCode for the push method\npublic void push(T element)\n// Places element at the top of this stack.\n{\nLLNode<T> newNode = new LLNode<T>(element);\nnewNode.setLink(top);\ntop = newNode;\n}\nResult\nof push\nonto\nempty\nstack\nCode for the pop method\npublic void pop()\n// Throws StackUnderflowException if this stack is empty,\n// otherwise removes top element from this stack.\n{\nif (isEmpty())\nthrow new StackUnderflowException(\"Pop attempted on an empty stack.\");\nelse\ntop = top.getLink();\n}\nPop from\na stack\n<eos>"}
{"text": "<bos>\nwith three\nelements\nThe remaining operations\npublic T top()\n{\nif (isEmpty())\nthrow new StackUnderflowException(\"Top attempted on an empty stack.\");\nelse\nreturn top.getInfo();\n}\npublic boolean isEmpty()\n{\nreturn (top == null);\n}\npublic boolean isFull()\n// Returns false – a linked stack is never full.\n{\nreturn false;\n}\nComparing Stack Implementations\n• Storage Size\n– Array-based: takes the same amount of memory, no\nmatter how many array slots are actually used,\nproportional to maximum size\n– Link-based: takes space proportional to actual size of\nthe stack (but each element requires more space than\nwith array approach)\n• Operation efficiency\n– All operations, for each approach, are O(1)\n– Except for the Constructors:\n• Array-based: O(N)\n• Link-based: O(1)\nWhich is better?\n• The linked\n<eos>"}
{"text": "<bos>\nimplementation does not have space\nlimitations, and in applications where the\nnumber of stack elements can vary greatly, it\nwastes less space when the stack is small.\n• The array-based implementation is short,\nsimple, and efficient. Its operations have less\noverhead. When the maximum size is small and\nwe know the maximum size with certainty, the\narray-based implementation is a good choice.\nOur\nStack\nClasses\nand\nInterfaces\n2.9 Application: Postfix Expression\nEvaluator\n• Postfix notation is a notation for writing\narithmetic expressions in which the operators\nappear after their operands.\n• For example, instead of writing\n(2 + 14) × 23\nwe write\n2 14 + 23 ×\nExamples\nPostfix Expression Evaluation\nAlgorithm\nwhile more items exist\nGet an item\nif item is an operand\nstack.push(item)\nelse\noperand2 =\n<eos>"}
{"text": "<bos>\nstack.top()\nstack.pop()\noperand1 = stack.top()\nstack.pop()\nSet result to (apply operation corresponding to item\nto operand1 and operand2)\nstack.push(result)\nresult = stack.top()\nstack.pop()\nreturn result\nExample\nExample\nExample\nExample\nExample\nExample\nExample\nCode and Demo\n• Instructors can now walk through and\ndemonstrate the code contained in\nPostFixEvaluator.java from the\nch02.postfix package and PFixCLI.java\nand/or PFixGUI.java from the ch02.apps\npackage.\n2.10 Stack Variations\n• Changes we could make to our Stack\n– Use stacks of class Object instead of\ngeneric stacks\n– Implement the classic pop operation (both\nremove and return top element) instead of the\ncombination of pop and top operations\n– Instead of throwing exceptions we could\n• for example, state as a precondition that pop will\n<eos>"}
{"text": "<bos>\nnot be called on an empty stack\n• for example, state that pop returns a boolean\nindicating success\nThe Java Collections Framework\nStack\n• extends the Vector class which extends the\nObject class\n– inherits several useful operations such as\ncapacity, clear, clone, contains, isEmpty,\ntoArray, and toString.\n• in addition to our push and top methods,\nimplements\n– the classic pop operation (both remove and return top\nelement)\n– a search operation that returns the position of a\nspecified object in the stack\n<eos>"}
