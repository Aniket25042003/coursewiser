{"text": "<bos>\nChapter 3\nRecursion\nChapter 3: Recursion\n3.1 – Recursive Definitions, Algorithms\nand Programs\n3.2 – The Three Questions\n3.3 – Recursive Processing of Arrays\n3.4 – Recursive Processing of Linked Lists\n3.5 – Towers of Hanoi\n3.6 – Fractals\n3.7 – Removing Recursion\n3.8 – Deciding Whether to Use a Recursive Solution\n3.1 Recursive Definitions,\nAlgorithms and Programs\nRecursive Definitions\n• Recursive definition A definition in which\nsomething is defined in terms of smaller versions\nof itself. For example:\n– A folder is an entity in a file system which contains a\ngroup of files and other folders.\n– A compound sentence is a sentence that consists of\ntwo sentences joined together by a coordinating\nconjunction.\n– n! = 1 if n = 0\n= n X (n – 1)! if n > 0\nrecursive part of definition\nExample: Calculate\n<eos>"}
{"text": "<bos>\n4!\nExample: Calculate 4!\n. . .\nExample: Calculate 4!\n. . .\nRecursive Algorithms\n• Recursive algorithm A solution that is\nexpressed in terms of\n– smaller instances of itself and\n– a base case\n• Base case The case for which the solution can\nbe stated non-recursively\n• General (recursive) case The case for which\nthe solution is expressed in terms of a smaller\nversion of itself\nExamples of a Recursive Algorithm\nand a Recursive Program\nFactorial (int n)\n// Assume n >= 0\nif (n == 0)\nreturn (1)\nelse\nreturn ( n * Factorial ( n – 1 ) )\npublic static int factorial(int n)\n// Precondition: n is non-negative\n//\n// Returns the value of \"n!\".\n{\nif (n == 0)\nreturn 1; // Base case\nelse\nreturn (n * factorial(n – 1)); // General case\n}\nRecursion Terms\n• Recursive call A method call in which the method being\n<eos>"}
{"text": "<bos>\ncalled is the same as the one making the call\n• Direct recursion Recursion in which a method directly\ncalls itself, like the factorial method.\n• Indirect recursion Recursion in which a chain of two or\nmore method calls returns to the method that originated\nthe chain, for example method A calls method B which in\nturn calls method A\nIterative Solution for Factorial\n• We have used the factorial algorithm to demonstrate\nrecursion because it is familiar and easy to visualize. In\npractice, one would never want to solve this problem\nusing recursion, since a straightforward, more efficient\niterative solution exists:\npublic static int factorial(int n)\n{\nint retValue = 1;\nwhile (n != 0)\n{\nretValue = retValue * n;\nn = n - 1;\n}\nreturn(retValue);\n}\n3.2 The Three Questions\n• In this section we present\n<eos>"}
{"text": "<bos>\nthree questions to ask\nabout any recursive algorithm or program.\n• Using these questions helps us verify, design,\nand debug recursive solutions to problems.\nVerifying Recursive Algorithms\nTo verify that a recursive solution works, we must be able\nto answer “Yes” to all three of these questions:\n1. The Base-Case Question: Is there a nonrecursive way out of\nthe algorithm, and does the algorithm work correctly for this\nbase case?\n2. The Smaller-Caller Question: Does each recursive call to the\nalgorithm involve a smaller case of the original problem,\nleading inescapably to the base case?\n3. The General-Case Question: Assuming the recursive call(s)\nto the smaller case(s) works correctly, does the algorithm\nwork correctly for the general case?\nWe next apply these three questions to the factorial\n<eos>"}
{"text": "<bos>\nalgorithm.\nThe Base-Case Question\nFactorial (int n) Is there a nonrecursive way out\n// Assume n >= 0 of the algorithm, and does the\nif (n == 0) algorithm work correctly\nreturn (1)\nfor this base case?\nelse\nreturn ( n * Factorial ( n – 1 ) )\nThe base case occurs when n is 0.\nThe Factorial algorithm then returns the value of 1, which is\nthe correct value of 0!, and no further (recursive) calls\nto Factorial are made.\nThe answer is yes.\nThe Smaller-Caller Question\nFactorial (int n) Does each recursive call to the\n// Assume n >= 0 algorithm involve a smaller case\nif (n == 0) of the original problem, leading\nreturn (1)\ninescapably to the base case?\nelse\nreturn ( n * Factorial ( n – 1 ) )\nThe parameter is n and the recursive call passes the\nargument n - 1. Therefore each subsequent recursive call\n<eos>"}
{"text": "<bos>\nsends a smaller value, until the value sent is finally 0.\nAt this point, as we verified with the base-case question,\nwe have reached the smallest case, and no further\nrecursive calls are made. The answer is yes.\nThe General-Case Question\nFactorial (int n) Assuming the recursive call(s) to the\n// Assume n >= 0 smaller case(s) works correctly, does\nif (n == 0) the algorithm work correctly for the\nreturn (1)\ngeneral case?\nelse\nreturn ( n * Factorial ( n – 1 ) )\nAssuming that the recursive call Factorial(n – 1) gives us\nthe correct value of (n - 1)!, the return statement computes\nn * (n - 1)!.\nThis is the definition of a factorial, so we know that the algorithm\nworks in the general case. The answer is yes.\nConstraints on input arguments\n• Constraints often exist on the valid input arguments\n<eos>"}
{"text": "<bos>\nfor a\nrecursive algorithm. For example, for Factorial, n must\nbe >= 0.\n• You can use the three question analysis to determine\nconstraints:\n– Check if there are any starting argument values for which the\nsmaller call does not produce a new argument that is closer to\nthe base case.\n– Such starting values are invalid.\n– Constrain your legal input arguments so that these values are\nnot permitted.\nSteps for Designing Recursive\nSolutions\n1. Get an exact definition of the problem to be solved.\n2. Determine the size of the problem to be solved on this\ncall to the method.\n3. Identify and solve the base case(s) in which the\nproblem can be expressed non-recursively. This\nensures a yes answer to the base-case question.\n4. Identify and solve the general case(s) correctly in terms\nof a smaller case of\n<eos>"}
{"text": "<bos>\nthe same problem—a recursive\ncall. This ensures yes answers to the smaller-caller and\ngeneral-case questions.\n3.3 Recursive Processing of Arrays\n• Many problems related to arrays lend\nthemselves to a recursive solution.\n• A subsection of an array (a “subarray”) can also\nbe viewed as an array.\n• If we can solve an array-related problem by\ncombining solutions to a related problem on\nsubarrays, we may be able to use a recursive\napproach.\nBinary Search\n• Problem: find a target element in a sorted array\n• Approach\n– examine the midpoint of the array and compare the\nelement found there to our target element\n– eliminate half the array from further consideration\n– recursively repeat this approach on the remaining\nhalf of the array until we find the target or determine\nthat it is not in the array\n<eos>"}
{"text": "<bos>\nExample\n• We have a sorted array of int named values\nof size 8\n• Our target is 20\n• Variables first and last indicate the sub-\narray currently under consideration\n• Therefore, the starting configuration is:\nExample\n• The midpoint is the average of first and last\nmidpoint = (first + last) / 2\n• Since values[midpoint] is less than target\nwe eliminate the lower half of the array from\nconsideration\nExample\n• Set first to midpoint + 1 and calculate a\nnew midpoint resulting in\n• Since values[midpoint] is greater than\ntarget we eliminate the upper half of remaining\nportion of the array from consideration.\nExample\n• Set last to midpoint - 1 and calculate a\nnew midpoint resulting in\n• Since values[midpoint]equals target we\nare finished and return true\nExample – target not in array\n• Consider the\n<eos>"}
{"text": "<bos>\nabove example again, but this time\nwith 18 replacing 20 as the fifth element of\nvalues. The same sequence of steps would\noccur until at the very last step we have the\nfollowing:\nExample – target not in array\n• Since values[midpoint] is less than target\nwe set first to midpoint + 1:\n• The entire array has been eliminated (since\nfirst > last) and we return false.\nCode for the Binary Search\nboolean binarySearch(int target, int first, int last)\n// Precondition: first and last are legal indices of values\n//\n// If target is contained in values[first,last] return true\n// otherwise return false.\n{\nint midpoint = (first + last) / 2;\nif (first > last)\nreturn false;\nelse\nif (target == values[midpoint])\nreturn true;\nelse\nrecursive call\nif (target > values[midpoint])\nreturn binarySearch(target,\n<eos>"}
{"text": "<bos>\nmidpoint + 1, last);\nrecursive call\nelse\nreturn binarySearch(target, first, midpoint - 1);\n}\n3.4 Recursive Processing\nof Linked Lists\n• A linked list is a recursive structure\n• The LLNode class, our building block for linked\nlists, is a self-referential (recursive) class:\npublic class LLNode<T>\n{\nprotected T info; // information stored in list\nprotected LLNode<T> link; // reference to a node\n. . .\nrecursive reference\nRecursive nature of Linked Lists\n• A linked list is either empty or consists of a node\ncontaining two parts:\n– information\n– a linked list\ncontains info A plus a linked list (B – C)\nPrinting a Linked List Recursively\nvoid recPrintList(LLNode<String> listRef)\n{\nif (listRef != null)\n{\nSystem.out.println(listRef.getInfo());\nrecPrintList(listRef.getLink());\n}\n}\nComparison\nvoid\n<eos>"}
{"text": "<bos>\nrecPrintList(LLNode<String> listRef)\n{\nif (listRef != null)\n{\nSystem.out.println(listRef.getInfo());\nrecPrintList(listRef.getLink());\n}\nIterative approach is better\n}\nvoid iterPrintList(LLNode<String> listRef)\n{\nwhile (listRef != null)\n{\nSystem.out.println(listRef.getInfo());\nlistRef = listRef.getLink();\n}\nbut what if you want to print the list in reverse???\n}\nReverse Printing a Linked List\nvoid recPrintList(LLNode<String> listRef)\n{\nif (listRef != null)\n{\nrecPrintList(listRef.getLink());\nSystem.out.println(listRef.getInfo());\n}\n}\nTransforming a linked list\nrecursively\n• For example, insert an element at the end of the\nlist\nvoid recInsertEnd(String newInfo, LLNode<String> listRef)\n// Adds newInfo to the end of the listRef linked list\n{\nif (listRef.getLink() != null)\nrecInsertEnd(newInfo,\n<eos>"}
{"text": "<bos>\nlistRef.getLink());\nelse\nlistRef.setLink(new LLNode<String>(newInfo));\n}\nAlthough this works in the general case\nit does not work if the original list is empty\nProblem with the approach\nvoid recInsertEnd(String newInfo, LLNode<String> listRef)\n// Adds newInfo to the end of the listRef linked list\n{\nif (listRef.getLink() != null)\nrecInsertEnd(newInfo, listRef.getLink());\nelse\nlistRef.setLink(new LLNode<String>(newInfo));\n}\nIf we invoke, for example,\nrecInsertEnd(“Z”,myList)\nthe temporary variable listRef will hold a linked\nlist consisting of “Z” but myList will still be null.\nSolution\n• Rather than return void where we invoke as\nrecInsertEnd(“Z”, myList)\n• Need a solution that returns a linked list so we\ncan invoke as\nmyList = recInsertEnd(“Z”, myList)\n• This is the only way we can change\n<eos>"}
{"text": "<bos>\nthe value of\nmyList in the case that the list is empty\nSolution\nLLNode<String> recInsertEnd(String newInfo, LLNode<String> listRef)\n// Adds newInfo to the end of the listRef linked list\n{\nif (listRef != null)\nlistRef.setLink(recInsertEnd(newInfo, listRef.getLink()));\nelse\nlistRef = new LLNode<String>(newInfo);\nreturn listRef;\n}\nThis works in both the general case and\nthe case where the original list is empty.\n3.5 Towers of Hanoi\n• Move the rings, one at a time, to the third peg.\n• A ring cannot be placed on top of one that is smaller in\ndiameter.\n• The middle peg can be used as an auxiliary peg, but it\nmust be empty at the beginning and at the end of the\ngame.\n• The rings can only be moved one at a time.\nSample\nSolution\nGeneral Approach\nTo move the largest ring to peg 3, we must move the\n<eos>"}
{"text": "<bos>\nthree smaller\nrings to peg 2:\nThen the largest ring can be moved to peg 3:\nAnd finally the three smaller rings are moved from peg 2 to peg 3:\nRecursion\n• Can you see that our solution involved solving a smaller\nversion of the problem? We have solved the problem\nusing recursion.\n• The general recursive algorithm for moving n rings from\nthe starting peg to the destination peg 3 is:\nMove n rings from Starting Peg to Destination Peg\nMove n - 1 rings from starting peg to auxiliary peg\nMove the nth ring from starting peg to destination peg\nMove n - 1 rings from auxiliary peg to destination peg\nRecursive Method\npublic static void doTowers(\nint n, // Number of rings to move\nint startPeg, // Peg containing rings to move\nint auxPeg, // Peg holding rings temporarily\nint endPeg ) // Peg receiving\n<eos>"}
{"text": "<bos>\nrings being moved\n{\nif (n == 1) // Base case – Move one ring\nSystem.out.println(\"Move ring \" + n + \" from peg \" + startPeg\n+ \" to peg \" + endPeg);\nelse\n{\n// Move n - 1 rings from starting peg to auxiliary peg\ndoTowers(n - 1, startPeg, endPeg, auxPeg);\n// Move nth ring from starting peg to ending peg\nSystem.out.println(\"Move ring \" + n + \" from peg \" + startPeg\n+ \" to peg \" + endPeg);\n// Move n - 1 rings from auxiliary peg to ending peg\ndoTowers(n - 1, auxPeg, startPeg, endPeg);\n}\n}\nCode and Demo\n• Instructors can now walk through the code\ncontained in Towers.java in the ch03.apps\npackage and demonstrate the running program.\n3.6 Fractals\n• There are many different\nways that people define\nthe term “fractal.”\n• For our purposes we\ndefine a fractal as an\nimage that is composed of\nsmaller\n<eos>"}
{"text": "<bos>\nversions of itself.\nA T-Square Fractal\n• In the center of a square black* canvas we draw\na white* square, one-quarter the size of the\ncanvas:\n*Although our publisher\nsupplied figures are\ntinted blue, our code\ngenerates black and\nwhite images.\nA T-Square Fractal\n• We then draw four more squares, each\ncentered at a corner of the original white square,\neach one-quarter the size of the original white\nsquare:\nA T-Square Fractal\n• For each of these new squares we do the same,\n(recursively) drawing four squares of smaller\nsize at each of their corners :\nA T-Square Fractal\n• And again:\nA T-Square Fractal\n• And again:\nuntil we can no\nlonger draw any\nmore squares\nCode and Demo\n• Instructors can now walk\nthrough the code contained in\nTSquare.java in the\nch03.fractals package\nand demonstrate the\n<eos>"}
{"text": "<bos>\nrunning\nprogram.\n• Be sure to also check out\n– TSquareThreshold.java\nthat allows the user to\nindicate when to start stop\ndrawing squares\n– TSquareGray.java that\nuses different gray scale\nlevels for each set of\ndifferently sized squares\n3.7 Removing Recursion\n• We consider two general techniques that are\noften substituted for recursion\n– iteration\n– stacking.\n• First we take a look at how recursion is\nimplemented.\n– Understanding how recursion works helps us see how\nto develop non-recursive solutions.\nStatic Storage Allocation\n• A compiler that translates a high-level language\nprogram into machine code for execution on a\ncomputer must\n– Reserve space for the program variables.\n– Translate the high level executable statements into\nequivalent machine language statements.\nExample of Static\n<eos>"}
{"text": "<bos>\nAllocation\nConsider the following program:\npublic class Kids\n{\nprivate static int countKids(int girlCount, int boyCount)\n{\nint totalKids;\n. . .\n}\npublic static void main(String[] args)\n{\nint numGirls; int numBoys; int numChildren;\n. . .\n}\n}\nA compiler could create two separate machine code units for this program,\none for the countKids method and one for the main method. Each unit would\ninclude space for its variables plus the sequence of machine language\nstatements that implement its high-level code.\nLimitations of static allocation\n• Static allocation like this is the simplest\napproach possible. But it does not support\nrecursion.\n• The space for the countKids method is\nassigned to it at compile time. This works fine\nwhen the method will be called once and then\nalways return before it is\n<eos>"}
{"text": "<bos>\ncalled again. But a\nrecursive method can be called again and again\nbefore it returns. Where do the second and\nsubsequent calls find space for their parameters\nand local variables?\n• Therefore dynamic storage allocation is needed.\nDynamic Storage Allocation\n• Dynamic storage allocation provides memory\nspace for a method when it is called.\n• When a method is invoked, it needs space to\nkeep its parameters, its local variables, and the\nreturn address (the address in the calling code\nto which the computer returns when the method\ncompletes its execution).\n• This space is called an activation record or\nstack frame.\nDynamic Storage Allocation\nConsider a program whose main method calls proc1,\nwhich then calls proc2. When the program begins executing,\nthe “main” activation record is generated:\nAt\n<eos>"}
{"text": "<bos>\nthe first method call, an activation record is generated for proc1:\nDynamic Storage Allocation\nWhen proc2 is called from within proc1, its activation record is generated.\nBecause proc1 has not finished executing, its activation record is still around:\nWhen proc2 finishes executing, its activation record is released:\nDynamic Storage Allocation\n• The order of activation follows the Last-In-First-Out rule.\n• Run-time or system stack A system data structure that\nkeeps track of activation records during the execution of\na program\n• Each nested level of method invocation adds another\nactivation record to the stack. As each method\ncompletes its execution, its activation record is popped\nfrom the stack. Recursive method calls, like calls to any\nother method, cause a new activation record to be\n<eos>"}
{"text": "<bos>\ngenerated.\n• Depth of recursion The number of activation records\non the system stack, associated with a given a recursive\nmethod\nRemoving Recursion - Iteration\n• Suppose the recursive call is the last action executed in\na recursive method (tail recursion)\n– The recursive call causes an activation record to be put on the\nrun-time stack to contain the invoked method’s arguments and\nlocal variables.\n– When this recursive call finishes executing, the run-time stack is\npopped and the previous values of the variables are restored.\n– Execution continues where it left off before the recursive call was\nmade.\n– But, because the recursive call is the last statement in the\nmethod, there is nothing more to execute and the method\nterminates without using the restored local variable values.\n• In such a\n<eos>"}
{"text": "<bos>\ncase the recursion can easily be replaced with\niteration.\nExample of eliminating tail\nrecursion\npublic static int factorial(int n)\n{\nif (n == 0)\nreturn 1; // Base case\nelse\nreturn (n * factorial(n – 1)); // General case\n}\nDeclare a variable to hold the\nprivate static int factorial(int n)\nintermediate values; initialize it to\n{\nthe value returned in the base case. int retValue = 1; // return value\nUse a while loop so that each time while (n != 0)\n{\nthrough the loop corresponds to one\nretValue = retValue * n;\nrecursive call. The loop should\nn = n - 1;\ncontinue processing until the base }\nreturn(retValue);\ncase is met:\n}\nRemove Recursion - Stacking\n• When the recursive call is not the last action\nexecuted in a recursive method, we cannot\nsimply substitute a loop for the recursion.\n• In such\n<eos>"}
{"text": "<bos>\ncases we can “mimic” recursion by using\nour own stack to save the required information\nwhen needed, as shown in the Reverse Print\nexample on the next slide.\nRemove Recursion - Stacking\nstatic void iterRevPrintList(LLNode<String> listRef)\n// Prints the contents of the listRef linked list to standard output\n// in reverse order\n{\nStackInterface<String> stack = new LinkedStack<String>();\nwhile (listRef != null) // put info onto the stack\n{\nstack.push(listRef.getInfo());\nlistRef = listRef.getLink();\n}\n// Retrieve references in reverse order and print elements\nwhile (!stack.isEmpty())\n{\nSystem.out.println(stack.top());\nstack.pop();\n}\n}\n3.6 Deciding Whether to Use a\nRecursive Solution\n• In this section we consider factors used in\ndeciding whether or not to use a recursive\nsolution to a problem.\n•\n<eos>"}
{"text": "<bos>\nThe main issues are the efficiency and the clarity\nof the solution.\nEfficiency Considerations\n• Recursion Overhead\n– A recursive solution usually has more “overhead” than\na non-recursive solution because of the number of\nmethod calls\n• time: each call involves processing to create and dispose of\nthe activation record, and to manage the run-time stack\n• space: activation records must be stored\n• Inefficient Algorithms\n– Another potential problem is that a particular\nrecursive solution might just be inherently inefficient.\nThis can occur if the recursive approach repeatedly\nsolves the same sub-problem, over and over again\nClarity\n• For many problems, a recursive solution is\nsimpler and more natural for the programmer to\nwrite. The work provided by the system stack is\n“hidden” and therefore a\n<eos>"}
{"text": "<bos>\nsolution may be easier\nto understand.\n• Compare, for example, the recursive and\nnonrecursive approaches to printing a linked list\nin reverse order that were developed previously\nin this chapter. In the recursive version, we let\nthe system take care of the stacking that we had\nto do explicitly in the nonrecursive method.\n<eos>"}
