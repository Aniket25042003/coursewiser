{"text": "<bos>\nChapter 4\nThe Queue\nADT\nChapter 4: The Queue ADT\n4.1 – The Queue\n4.2 – The Queue Interface\n4.3 – Array-Based Queue Implementations\n4.4 – An Interactive Test Driver\n4.5 – Link-Based Queue Implementations\n4.6 – Application: Palindromes\n4.7 – Queue Variations\n4.8 – Application: Average Waiting Time\n4.9 – Concurrency, Interference, and\nSynchronization\n4.1 The Queue\n• Queue A structure in which elements are added\nto the rear and removed from the front; a “first in,\nfirst out” (FIFO) structure\nOperations on Queues\n• Constructor\n– new - creates an empty queue\n• Transformers\n– enqueue - adds an element to the rear of a queue\n– dequeue - removes and returns the front element of\nthe queue\nEffects of\nQueue\nOperations\nUsing Queues\n• Operating systems often maintain a queue of processes\nthat are ready\n<eos>"}
{"text": "<bos>\nto execute or that are waiting for a\nparticular event to occur.\n• Computer systems must often provide a “holding area”\nfor messages between two processes, two programs, or\neven two systems. This holding area is usually called a\n“buffer” and is often implemented as a queue.\n• Our software queues have counterparts in real world\nqueues. We wait in queues to buy pizza, to enter movie\ntheaters, to drive on a turnpike, and to ride on a roller\ncoaster. Another important application of the queue data\nstructure is to help us simulate and analyze such real\nworld queues\n4.2 The Queue Interface\n• We use a similar approach as with the Stack\nADT.\n• Our queues\n– are generic\n– queue related classes are held in\nch04.queues package\n• we define exceptions for both queue underflow\nand queue overflow\n• we\n<eos>"}
{"text": "<bos>\ncreate a QueueInterface\nQueueInterface\npackage ch04.queues;\npublic interface QueueInterface<T>\n{\nvoid enqueue(T element) throws QueueOverflowException1;\n// Throws QueueOverflowException if this queue is full;\n// otherwise, adds element to the rear of this queue.\nT dequeue() throws QueueUnderflowException;\n// Throws QueueUnderflowException if this queue is empty;\n// otherwise, removes front element from this queue and returns it.\nboolean isFull();\n// Returns true if this queue is full;\n// otherwise, returns false.\nboolean isEmpty();\n// Returns true if this queue is empty;\n// otherwise, returns false.\nint size();\n// Returns the number of elements in this queue.\n}\nExample Use of a Queue\n• Instructors can now review and demonstrate the\nRepeatStrings application found in package\nch04.apps.\n4.3\n<eos>"}
{"text": "<bos>\nArray-Based Queue\nImplementations\n• In this section we study two array-based\nimplementations of the Queue ADT\n– a bounded queue version\n– an unbounded queue version\n• We simplify some figures by using a capital letter\nto represent an element’s information\nFixed Front Design\n• After four calls to enqueue\nwith arguments ‘A’, ‘B’, ‘C’,\nand ‘D’:\n• Dequeue the front\nelement:\n• Move every element in the\nqueue up one slot\n• The dequeue operation is\ninefficient, so we do not\nuse this approach\nFloating\nFront\nDesign\nWe use this\napproach\nWrap\nAround\nwith\nFloating\nFront\nDesign\nThe ArrayBoundedQueue Class\npackage ch04.queues;\npublic class ArrayBoundedQueue<T> implements QueueInterface<T>\n{\nprotected final int DEFCAP = 100; // default capacity\nprotected T[] elements; // array that holds queue elements\n<eos>"}
{"text": "<bos>\nprotected int numElements = 0; // number of elements in the queue\nprotected int front = 0; // index of front of queue\nprotected int rear; // index of rear of queue\npublic ArrayBoundedQueue()\n{\nelements = (T[]) new Object[DEFCAP];\nrear = DEFCAP - 1;\n}\npublic ArrayBounddQueue(int maxSize)\n{\nelements = (T[]) new Object[maxSize];\nrear = maxSize - 1;\n}\nThe enqueue operation\npublic void enqueue(T element)\n// Throws QueueOverflowException if this queue is full,\n// otherwise adds element to the rear of this queue.\n{\nif (isFull())\nthrow new QueueOverflowException(\"Enqueue attempted on a full queue.\");\nelse\n{\nrear = (rear + 1) % elements.length;\nelements[rear] = element;\nnumElements = numElements + 1;\n}\n}\nThe dequeue operation\npublic T dequeue()\n// Throws QueueUnderflowException if this queue is\n<eos>"}
{"text": "<bos>\nempty,\n// otherwise removes front element from this queue and returns it.\n{\nif (isEmpty())\nthrow new QueueUnderflowException(“Dequeue attempted on empty queue.”);\nelse\n{\nT toReturn = elements[front];\nelements[front] = null;\nfront = (front + 1) % elements.length;\nnumElements = numElements - 1;\nreturn toReturn;\n}\n}\nRemaining Queue Operations\n(observers)\npublic boolean isEmpty()\n// Returns true if this queue is empty, otherwise returns false\n{\nreturn (numElements == 0);\n}\npublic boolean isFull()\n// Returns true if this queue is full, otherwise returns false.\n{\nreturn (numElements == elements.length);\n}\npublic int size()\n// Returns the number of elements in this queue.\n{\nreturn numElements;\n}\nThe ArrayUnboundedQueue\nClass\n• The trick is to create a new, larger array, when\nneeded, and copy the\n<eos>"}
{"text": "<bos>\nqueue into the new array\n– Since enlarging the array is conceptually a separate\noperation from enqueing, we implement it as a\nseparate enlarge method\n– This method instantiates an array with a size equal to\nthe current capacity plus the original capacity\n• We change the isFull method so that it always\nreturns false, since an unbounded queue is\nnever full\n• The dequeue and isEmpty methods are\nunchanged\nThe ArrayUnbndQueue Class\npackage ch04.queues;\npublic class ArrayUnboundedQueue<T> implements QueueInterface<T>\n{\nprotected final int DEFCAP = 100; // default capacity\nprotected T[] elements; // array that holds queue elements\nprotected int origCap; // original capacity\nprotected int numElements = 0; // number of elements in the queue\nprotected int front = 0; // index of front of queue\n<eos>"}
{"text": "<bos>\nprotected int rear; // index of rear of queue\npublic ArrayUnboundedQueue()\n{\nelements = (T[]) new Object[DEFCAP];\nrear = DEFCAP - 1;\norigCap = DEFCAP;\n}\npublic ArrayUnboundedQueue(int origCap)\n{\nelements = (T[]) new Object[origCap];\nrear = origCap - 1;\nthis.origCap = origCap;\n}\nThe enlarge operation\nprivate void enlarge()\n// Increments the capacity of the queue by an amount\n// equal to the original capacity.\n{\n// create the larger array\nT[] larger = (T[]) new Object[elements.length + origCap];\n// copy the contents from the smaller array into the larger array\nint currSmaller = front;\nfor (int currLarger = 0; currLarger < numElements; currLarger++)\n{\nlarger[currLarger] = elements[currSmaller];\ncurrSmaller = (currSmaller + 1) % elements.length;\n}\n// update instance variables\nelements =\n<eos>"}
{"text": "<bos>\nlarger;\nfront = 0;\nrear = numElements - 1;\n}\nThe enqueue operation\npublic void enqueue(T element)\n// Adds element to the rear of this queue.\n{\nif (numElements == elements.length)\nenlarge();\nrear = (rear + 1) % elements.length;\nelements[rear] = element;\nnumElements = numElements + 1;\n}\n4.4 An Interactive Test Driver\n• Act as an example use of the\nArrayBoundedQueue class\n• Can be used by students to experiment and\nlearn about the Queue ADT and the\nrelationships among its exported methods\n• Will use elements of type String to be stored\nand retrieved from the ADT\nThe General Approach\nPrompt for, read, and display test name\nDetermine which constructor to use\nObtain needed parameters\nInstantiate a new instance of the ADT\nwhile (testing continues)\n{\nDisplay a menu of operation choices,\none choice\n<eos>"}
{"text": "<bos>\nfor each method exported by the ADT\nplus a “stop testing” choice\nGet the user’s choice and\nobtain any needed parameters\nPerform the chosen operation\nif an exception is thrown, catch it and\nreport its message\nif a value is returned, report it\n}\n• Instructors can now walk through the code\ncontained in ITDArrayBoundedQueue.java\nfound in the ch04.queues package and\ndemonstrate the running program.\n4.5 Link-Based Queue\nImplementations\n• In this section we develop a link-based\nimplementation of an unbounded queue, and\ndiscuss a second link-based approach.\n• For nodes we use the same LLNode class we\nused for the linked implementation of stacks.\n• After discussing the link-based approaches we\ncompare all of our queue implementation\napproaches.\nThe LinkedQueue Class\npackage ch04.queues;\nimport\n<eos>"}
{"text": "<bos>\nsupport.LLNode;\npublic class LinkedQueue<T> implements QueueInterface<T>\n{\nprotected LLNode<T> front; // reference to the front of this queue\nprotected LLNode<T> rear; // reference to the rear of this queue\nprotected int numElements = 0; // number of elements in this queue\npublic LinkedQueue()\n{\nfront = null; rear = null;\n}\n. . .\nThe enqueue operation\nEnqueue (element)\n1. Create a node for the new element\n2. Add the new node at the rear of the queue\n3. Update the reference to the rear of the queue\n4. Increment the number of elements\nCode for the enqueue method\npublic void enqueue(T element)\n// Adds element to the rear of this queue.\n{\nLLNode<T> newNode = new LLNode<T>(element);\nif (rear == null)\nfront = newNode;\nelse\nrear.setLink(newNode);\nrear = newNode;\nnumElements++;\n}\nThe dequeue\n<eos>"}
{"text": "<bos>\noperation\nDequeue: returns Object\n1. Set element to the information in the front node\n2. Remove the front node from the queue\n3. if the queue is empty\nSet the rear to null\n4. Decrement the number of elements\n5. return element\nCode for the dequeue method\npublic T dequeue()\n// Throws QueueUnderflowException if this queue is empty,\n// otherwise removes front element from this queue and returns it.\n{\nif (isEmpty())\nthrow new QueueUnderflowException(\"Dequeue attempted on empty queue.\");\nelse\n{\nT element;\nelement = front.getInfo();\nfront = front.getLink();\nif (front == null)\nrear = null;\nnumElements--;\nreturn element;\n}\n}\nAn Alternative Approach -\nA Circular Linked Queue\nComparing Queue Implementations\n• Storage Size\n– Array-based: takes the same amount of memory, no matter how\nmany array slots\n<eos>"}
{"text": "<bos>\nare actually used, proportional to current\ncapacity\n– Link-based: takes space proportional to actual size of the queue\n(but each element requires more space than with array\napproach)\n• Operation efficiency\n– All operations, for each approach, are O(1)\n– Except for the Constructors:\n• Array-based: O(N)\n• Link-based: O(1)\n• Special Case – For the ArrayUnboundedQueue the\nsize “penalty” can be minimized but the enlarge\nmethod is O(N)\nComparing Queue Implementations\n4.6 Application: Palindromes\n• Examples\n– A tribute to Teddy Roosevelt, who orchestrated the\ncreation of the Panama Canal:\n• A man, a plan, a canal—Panama!\n– Allegedly muttered by Napoleon Bonaparte upon his\nexile to the island of Elba:\n• Able was I ere, I saw Elba.\n• Our goal is to write a program that identifies\nPalindromic\n<eos>"}
{"text": "<bos>\nstrings\n– we ignore blanks, punctuation and the case of letters\nThe Palindrome Class\n• To help us identify palindromic strings we create\na class called Palindrome, with a single\nexported static method test\n• test takes a candidate string argument and\nreturns a boolean value indicating whether the\nstring is a palindrome\n• Since test is static we invoke it using the name\nof the class rather than instantiating an object of\nthe class\n• The test method uses both the stack and\nqueue data structures\nThe test method approach\n• The test method creates a stack and a queue\n• It then repeatedly pushes each input letter onto the\nstack, and also enqueues the letter onto the queue\n• It discards any non-letter characters\n• To simplify comparison later, we push and enqueue only\nlowercase versions of the\n<eos>"}
{"text": "<bos>\ncharacters\n• After the characters of the candidate string have been\nprocessed, test repeatedly pops a letter from the stack\nand dequeues a letter from the queue\n• As long as these letters match each other the entire way\nthrough this process, we have a palindrome\nTest for Palindrome (String candidate)\nCreate a new stack\nCreate a new queue\nfor each character in candidate\nif the character is a letter\nChange the character to lowercase\nPush the character onto the stack\nEnqueue the character onto the queue\nSet stillPalindrome to true\nwhile (there are still more characters in the structures\n&& stillPalindrome)\nPop fromStack from the stack\nDequeue fromQueue from the queue\nif (fromStack != fromQueue)\nSet stillPalindrome to false\nreturn (stillPalindrome)\nCode and Demo\n• Instructors can now walk\n<eos>"}
{"text": "<bos>\nthrough the code\ncontained in Palindrome.java in the\nch04.palindromes package, and\nPalindromeCLI.java and/or\nPalindrome.GUI both in the ch04.apps\npackage, and demonstrate the application.\nProgram Architecture\n4.7 Queue Variations\n• We consider some alternate ways to define the classic\nqueue operations.\n• We look at additional operations that could be included\nin a Queue ADT, some that allow us to “peek” into the\nqueue and others that expand the access rules\n• We review the Java Standard Library queue support.\nExceptional Situations\n• Our queues throw exceptions in the case of\nunderflow or overflow.\n• Another approach is to prevent the\nover/underflow from occurring by nullifying the\noperation, and returning a value that indicates\nfailure\n– boolean enqueue(T element) adds element to the\nrear\n<eos>"}
{"text": "<bos>\nof this queue; returns true if element is\nsuccessfully added, false otherwise\n– T dequeue()returns null if this queue is empty,\notherwise removes front element from this queue and\nreturns it\nInheritance of Interfaces\n• Java supports inheritance of interfaces.\n• In fact, the language supports multiple\ninheritance of interfaces—a single interface can\nextend any number of other interfaces.\n• Suppose interface B extends interface A. Then a\nclass that implements interface B must provide\nconcrete methods for all of the abstract methods\nlisted in both interface B and interface A.\nThe Glass Queue\n//-------------------------------------------------------------------------\n// GlassQueueInterface.java by Dale/Joyce/Weems Chapter 4\n//\n// Interface for a class that implements a queue of T and includes\n<eos>"}
{"text": "<bos>\n// operations for peeking at the front and rear elements of the queue.\n//-------------------------------------------------------------------------\npackage ch04.queues;\npublic interface GlassQueueInterface<T> extends QueueInterface<T>\n{\npublic T peekFront();\n// If the queue is empty, returns null.\n// Otherwise, returns the element at the front of this queue.\npublic T peekRear();\n// If the queue is empty, returns null.\n// Otherwise, returns the element at the rear of this queue.\n}\npackage ch04.queues;\npublic class LinkedGlassQueue<T> extends LinkedQueue<T>\nimplements GlassQueueInterface<T>\n{\npublic LinkedGlassQueue()\n{\nsuper();\n}\npublic T peekFront()\n{\nif (isEmpty())\nreturn null;\nelse\nreturn front.getInfo();\n}\npublic T peekRear()\n{\nif (isEmpty())\nreturn null;\nelse\nreturn rear.getInfo();\n}\n}\n<eos>"}
{"text": "<bos>\nThe Double-Ended Queue:\nDeque\npackage ch04.queues;\npublic interface DequeInterface<T>\n{\nvoid enqueueFront(T element) throws QueueOverflowException;\n// Throws QueueOverflowException if this queue is full;\n// otherwise, adds element to the front of this queue.\nvoid enqueueRear(T element) throws QueueOverflowException;\n// Throws QueueOverflowException if this queue is full;\n// otherwise, adds element to the rear of this queue.\nT dequeueFront() throws QueueUnderflowException;\n// Throws QueueUnderflowException if this queue is empty;\n// otherwise, removes front element from this queue and returns it.\nT dequeueRear() throws QueueUnderflowException;\n// Throws QueueUnderflowException if this queue is empty;\n// otherwise, removes rear element from this queue and returns it.\nboolean isFull();\n<eos>"}
{"text": "<bos>\nboolean isEmpty();\nint size();\n}\nA good approach for implementing\nDeque\n• Double Linked List:\n• See DLLNode in package support\nQueues in the\nJava Standard Library\n• A Queue interface was added to the Java\nLibrary Collection Framework with Java 5.0 in\n2004.\n• Elements are always removed from the “front” of\nthe queue.\n• Two operations for enqueuing: add, that throws\nan exception if invoked on a full queue, and\noffer, that returns a boolean value of false if\ninvoked on a full queue.\nQueues in the\nJava Standard Library\n• As with the library Stack, the library Queue was\nsupplanted by the Deque with the release of\nJava 6.0 in 2006\n– it requires operations allowing for additions, deletions,\nand inspections at both ends of the queue\n• There are four library classes that implement the\nDeque\n<eos>"}
{"text": "<bos>\ninterface: ArrayDeque,\nConcurrentLinkedDeque, LinkedBlockingDeque,\nand LinkedList.\n4.8 Application:\nAverage Waiting Time\n• We create a program that simulates a series of\ncustomers arriving for service, entering a queue,\nwaiting, being served, and finally leaving the\nqueue.\n• It tracks the time the customers spend waiting in\nqueues and outputs the average waiting time.\nDefinitions\n• Arrival time: the time a customers arrives\n• Service time: time customer needs\n• Departure time: the time customer leaves\n• Turnaround time: Departure time – Arrival\ntime\n• Wait time: Turnaround time – Service\nTime\nSimple Example\nAnd so on\nSimple Example Results\nProgram Architecture\nSample Run of SimulationCLI\nEnter minimum interarrival time: 0\nEnter maximum interarrival time: 10\nEnter minimum service time: 5\n<eos>"}
{"text": "<bos>\nEnter maximum service time: 20\nEnter number of queues: 2\nEnter number of customers: 2000\nAverage waiting time is 1185.632\nEvaluate another simulation instance? (Y=Yes): y\nEnter number of queues: 3\nEnter number of customers: 2000\nAverage waiting time is 5.7245\nEvaluate another simulation instance? (Y=Yes): n\nProgram completed.\n4.9 Concurrency, Interference, and\nSynchronization\n• Multitask: Perform more than one task at a time\n• Concurrency: Several interacting code\nsequences are executing simultaneously\n– through interleaving of statements by a single\nprocessor\n– through execution on several processors\nCounter\n//-------------------------------------------------------------------------\n// Counter.java by Dale/Joyce/Weems Chapter 4\nClass\n//\n// Tracks the current value of a counter.\n<eos>"}
{"text": "<bos>\n//-------------------------------------------------------------------------\npackage ch04.threads;\npublic class Counter\n{\nprivate int count;\npublic Counter()\n{\ncount = 0;\n}\npublic void increment()\n{\ncount++;\n}\npublic int getCount()\n{\nreturn count;\n}\n}\nDemo One - Basic\npackage ch04.concurrency;\nimport ch04.threads.*;\npublic class Demo01\n{\npublic static void main(String[] args)\n{\nCounter c = new Counter();\nc.increment();\nc.increment();\nc.increment();\nSystem.out.println(\"Count is: \" + c.getCount());\n}\n}\nThe output of the program: Count is: 3\nDemo Two - Threads\npackage ch04.threads; package ch04.concurrency;\npublic class Increase import ch04.threads.*;\nimplements Runnable public class Demo02\n{ {\nprivate Counter c; public static void main(String[] args) throws\nInterruptedException\nprivate int\n<eos>"}
{"text": "<bos>\namount;\n{\npublic Increase (Counter c, int amount)\nCounter c = new Counter();\n{\nRunnable r = new Increase(c, 10000);\nthis.c = c; this.amount = amount;\nThread t = new Thread(r);\n}\nt.start();\nSystem.out.println(\"Count is: \" + c.getCount());\npublic void run()\n}\n{\n}\nfor (int i = 1; i <= amount; i++)\nc.increment();\nOutput Varies: 86, 3024, 457 ????\n}\n}\nDemo Two - Threads\nDemo Three - Join\npackage ch04.threads; package ch04.concurrency;\npublic class Increase import ch04.threads.*;\nimplements Runnable public class Demo03\n{ {\nprivate Counter c; public static void main(String[] args) throws\nInterruptedException\nprivate int amount;\n{\npublic Increase (Counter c, int amount)\nCounter c = new Counter();\n{\nRunnable r = new Increase(c, 10000);\nthis.c = c; this.amount = amount;\nThread t = new Thread(r);\n}\n<eos>"}
{"text": "<bos>\nt.start();\nt.join();\npublic void run()\nSystem.out.println(\"Count is: \" + c.getCount());\n{\n}\nfor (int i = 1; i <= amount; i++)\n} Output is 10000\nc.increment();\n}\n}\nDemo Four - Interference\npackage ch04.threads; package ch04.concurrency;\nimport ch04.threads.*;\npublic class Increase\npublic class Demo04\nimplements Runnable\n{\n{\npublic static void main(String[] args)\nprivate Counter c;\nthrows InterruptedException\nprivate int amount;\n{\npublic Increase (Counter c, int amount) Counter c = new Counter();\n{ Runnable r1 = new Increase(c, 5000);\nRunnable r2 = new Increase(c, 5000);\nthis.c = c; this.amount = amount;\nThread t1 = new Thread(r1);\n}\nThread t2 = new Thread(r2);\nt1.start(); t2.start();\npublic void run()\nt1.join(); t2.join();\n{\nSystem.out.println(\"Count is: \" + c.getCount());\nfor (int i = 1; i\n<eos>"}
{"text": "<bos>\n<= amount; i++) }\nc.increment(); }\nOutput Varies: 9861, 9478 ????\n}\n}\nDemo Four - Interference\nThread t1 Thread t2\nStep 1: obtains value 12\nStep 2: obtains value 12\nStep 3: increments value to 13\nStep 4: stores the value 13\nStep 5: increments value to 13\nStep 6: stores the value 13\nDemo Five - Synchronization\n// SyncCounter.java // The IncreaseSync class is identical to Increase\n// Tracks the current value of a counter.\n// cass except that it accepts a SyncCounter instead\n// Provides synchronized access\n// of Counter as its first parameter\npackage ch04.concurrency;\npackage ch04.threads;\nimport ch04.threads.*;\npublic class SyncCounter\n{ public class Demo05\nprivate int count; {\npublic SyncCounter()\npublic static void main(String[] args) throws\n{\nInterruptedException\ncount = 0;\n{\n}\n<eos>"}
{"text": "<bos>\nSyncCounter sc = new SyncCounter();\nRunnable r1 = new IncreaseSync(sc, 5000);\npublic synchronized void increment()\n{ Runnable r2 = new IncreaseSunc(sc, 5000);\ncount++; Thread t1 = new Thread(r1);\n}\nThread t2 = new Thread(r2);\nt1.start(); t2.start();\nOutput is 10000\npublic int getCount()\nt1.join(); t2.join();\n{\nSystem.out.println(\"Count is: \" + sc.getCount());\nreturn count;\n} }\n} }\nA Synchronized Queue\n• Similarly the synchronized keyword can be\nused to control access to an entire or\nselected parts of a data structure\n• See the subsection “A Synchronized\nQueue”\nOur Queue Architecture\n<eos>"}
