{"text": "<bos>\nChapter 5\nThe\nCollection\nADT\nChapter 5: The Collection ADT\n5.1 – The Collection Interface\n5.2 – Array-Based Collections Implementation\n5.3 – Application: Vocabulary Density\n5.4 – Comparing Object Revisited\n5.5 – Sorted Array-Based Collection Implementation\n5.6 – Link-Based Collection Implementation\n5.7 – Collection Variations\n5.1 The Collection Interface\n• Stacks and queues restrict access to data based\non the order in which the data was stored\n• Sometimes we need to retrieve information\nregardless of the order in which it is stored—\ncontent based access—for example obtaining\nstudent information based on an ID number\n• the Collection ADT is the most basic ADT that\nprovides the required functionality\nAssumptions for our Collections\n• Support addition, removal, and retrieval of\nelements\n•\n<eos>"}
{"text": "<bos>\nContent based access is based on equality of\nobjects (using the equals method)\n• Allow duplicate elements, do not allow null\nelements\n• add and remove operations return a boolean\nindicating success\npackage ch05.collections;\npublic interface CollectionInterface<T>\n{\nboolean add(T element);\n// Attempts to add element to this collection. Returns true if successful, false otherwise.\nT get(T target);\n// Returns an element e from this collection such that e.equals(target).\n// If no such element exists, returns null.\nboolean contains(T target);\n// Returns true if this collection contains an element e such that\n// e.equals(target); otherwise returns false.\nboolean remove (T target);\n// Removes an element e from this collection such that e.equals(target)\n// and returns true. If no such element\n<eos>"}
{"text": "<bos>\nexists, returns false.\nboolean isFull();\nboolean isEmpty();\nint size();\n}\n5.2 Array-Based Collection\nImplementation\n• Basic Approach - a collection of N elements is\nheld in the first N locations of an array, locations\n0 to N−1\n• Maintain an instance variable, numElements\nBeginning of class\npackage ch05.collections;\npublic class ArrayCollection<T> implements CollectionInterface<T>\n{\nprotected final int DEFCAP = 100; // default capacity\nprotected T[] elements; // array to hold collection's elements\nprotected int numElements = 0; // number of elements\n// set by find method\nprotected boolean found; // true if target found, otherwise false\nprotected int location; // indicates location of target if found\npublic ArrayCollection()\n{\nelements = (T[]) new Object[DEFCAP];\n}\npublic ArrayCollection(int\n<eos>"}
{"text": "<bos>\ncapacity)\n{\nelements = (T[]) new Object[capacity];\n}\n. . .\nAdding an element\nAdd “COL”\nThe add method\npublic boolean add(T element)\n// Attempts to add element to this collection.\n// Returns true if successful, false otherwise.\n{\nif (isFull())\nreturn false;\nelse\n{\nelements[numElements] = element;\nnumElements++;\nreturn true;\n}\n}\nThe helper find method\n• protected access\n• uses Sequential Search … O(N)\n• sets instance variables found and location\n• simplifies\n– remove\n– contains\n– get\nThe helper find method\nprotected void find(T target)\n{\nlocation = 0;\nfound = false;\nwhile (location < numElements)\n{\nif (elements[location].equals(target))\n{\nfound = true;\nreturn;\n}\nelse\nlocation++;\n}\n}\nRemoving an element\nRemove “MEX”\nThe remove method\npublic boolean remove (T target)\n// Removes an element e\n<eos>"}
{"text": "<bos>\nfrom this collection\n// such that e.equals(target) and returns true;\n// if no such element exists, returns false.\n{\nfind(target);\nif (found)\n{\nelements[location] = elements[numElements - 1];\nelements[numElements - 1] = null;\nnumElements--;\n}\nreturn found;\n}\nThe contains and get methods\npublic boolean contains (T target)\n{\nfind(target);\nreturn found;\n}\npublic T get(T target)\n{\nfind(target);\nif (found)\nreturn elements[location];\nelse\nreturn null;\n}\n5.3 Application: Vocabulary Density\n• The vocabulary density of a text is the total\nnumber of words in the text divided by the\nnumber of unique words in the text.\n• Used by computational linguists to help analyze\ntexts.\n• We define a word to be a sequence of letter\ncharacters (A through Z) plus the apostrophe\ncharacter ( ’ ).\nVocabulary Density\n<eos>"}
{"text": "<bos>\nCalculation\nInitialize variables and objects\nwhile there are more words to process\nGet the next word\nif the collection does not contain the word\nAdd the word to the collection\nIncrement total number of words\nDisplay (total number words/size of the collection)\nThe application\n• Instructors can now review the application,\nVocabularyDensity, found in the ch05.apps\npackage, plus the notes on pages 307-308.\n• The code is short and simple—this is because\nso much of the complexity is handled by the\nArrayCollection class. This is a good\nexample of the power and utility of abstraction.\n5.4 Comparing Objects Revisited\n• Collection operations require comparing\nobjects for equality\n• Section 5.5 “Sorted Array-Based\nCollection Implementation” requires\ncomparing objects for order\n• This section reviews\n<eos>"}
{"text": "<bos>\nthe equals and\ncompareTo operations\nUsing the comparison (==) operator\nUsing the equals method\n• Since equals is exported from the Object\nclass it can be used with objects of any Java\nclass.\n• For example, If c1 and c2 are objects of the\nclass Circle, then we can compare them using\nc1.equals(c2)\n• But this method, as defined in the Object class,\nacts much the same as the comparison\noperator. It returns true if and only if the two\nvariables reference the same object.\n• However, we can redefine the equals method\nto fit the goals of the class.\nDefining an equals method\n• A reasonable definition for equality of Circle objects is that they are equal if\nthey have equal radii.\n• To realize this approach we define the equals method of our Circle class\nto use the radius attribute:\n@Override\npublic\n<eos>"}
{"text": "<bos>\nboolean equals(Object obj)\n{\nif (obj == this)\nreturn true;\nelse\nif (obj == null || obj.getClass() != this.getClass())\nreturn false;\nelse\n{\nCircle c = (Circle) obj;\nreturn (this.radius == c.radius);\n}\n}\nThe FamousPerson class\n• A famous person object has attributes\nrepresenting name (first name and last name),\nthe year they were born, and some short\ninteresting fact about the person\n• The class is in the support package\n• It exports getters plus equals, compareTo, and\ntoString methods.\nThe equals method\n@Override\npublic boolean equals(Object obj)\n{\nif (obj == this)\nreturn true;\nelse\nif (obj == null || obj.getClass() != this.getClass())\nreturn false;\nelse\n{\nFamousPerson fp = (FamousPerson) obj;\nreturn (this.firstName.equals(fp.firstName) &&\nthis.lastName.equals(fp.lastName));\n}\n}\nIdentifying\n<eos>"}
{"text": "<bos>\nobjects\n• Objects are identified by their “key”.\n• The key of a class, from the point of view of an\napplication, is the set of attributes that are used\nto determine the identity of an object of the\nclass, for that application.\n• For example\n– the key of a Circle object is its radius attribute\n– the key of a FamousPerson object is the combination\nof its firstName and lastName attributes\nRetrieving objects based on their key\n• Note that two objects can be equal although they\nare not identical\n• Keys form the basis of retrieval\n• Stored: Requested:\nfirstName: Ada firstName: Ada\nlastName: Lovelace lastName: Lovelace\nyearOfBirth: 1815 yearOfBirth: 0\nfact: first programmer fact:\n• Instructors can review and demonstrate the\nCSInfo application found in the\nch05.applications package\nOrdering\n<eos>"}
{"text": "<bos>\nobjects\n• In addition to checking objects for equality, there\nis another type of comparison we need.\n• To support a sorted collection we need to be\nable to tell when one object is less than, equal\nto, or greater than another object.\n• The Java library provides an interface, called\nComparable, which can be used to ensure that\na class provides this functionality.\nThe Comparable Interface\n• The Comparable interface consists of exactly one\nabstract method:\npublic int compareTo(T o);\n// Returns a negative integer, zero, or a positive\n// integer as this object is less than, equal to,\n// or greater than the specified object.\n• The compareTo method returns an integer value that\nindicates the relative \"size\" relationship between the\nobject upon which the method is invoked and the object\npassed to\n<eos>"}
{"text": "<bos>\nthe method as an argument.\nA compareTo Example\npublic int compareTo(FamousPerson other)\n// Precondition: 'other' is not null\n//\n// Compares this FamousPerson with 'other' for order. Returns a\n// negative integer, zero, or a positive integer as this object\n// is less than, equal to, or greater than 'other'.\n{\nif (!this.lastName.equals(other.lastName))\nreturn this.lastName.compareTo(other.lastName);\nelse\nreturn this.firstName.compareTo(other.firstName);\n}\n• This compareTo method uses the compareTo method of the String class.\n• Note that the equals method and the compareTo method of our Circle\nclass are compatible with each other.\n• By convention the compareTo method of a class should support the standard\norder of a class. We call the order established by a class compareTo method\nthe natural\n<eos>"}
{"text": "<bos>\norder of the class.\n5.5 Sorted Array-Based Collection\nImplementation\n• The ArrayCollection class features fast add\n(O(1)) but slow get, contains, and remove\n(O(N))\n• Many applications require fast retrieval (get and\ncontains) as they access the collection\nrepeatedly to obtain information\n• A sorted array approach permits use of the\nBinary Search for find, therefore speeding up\nboth get and contains\nComparable Elements\n• We will use the compareTo method of the\nelement class to keep underlying array sorted\n• We specify as a precondition of the add method\nthat its argument is comparable to the previous\nobjects added to the collection.\nThe SortedArrayCollection\nclass\n• Similar to ArrayCollection class but …\n• Unbounded (uses a protected enlarge method)\n• the find method uses the Binary Search\n<eos>"}
{"text": "<bos>\nalgorithm\n– cast elements as Comparable (some compilers may\ngenerate a warning)\n• add and remove must preserve the underlying\norder of the array (see next slide)\nThe add and remove operations\nadd “BOL”\nremove “BOL”\nSample\nApplication\nResults\nImplementing ADTs “by Copy” or\n“by Reference”\n• When designing an ADT we have a choice about\nhow to handle the elements—“by copy” or “by\nreference.”\n– By Copy: The ADT manipulates copies of the data\nused in the client program. Making a valid copy of an\nobject can be a complicated process.\n– By Reference: The ADT manipulates references to\nthe actual elements passed to it by the client\nprogram. This is the most commonly used approach\nand is the approach we use throughout this textbook.\n“By Copy” Notes\n• Valid copies of an object are typically created\n<eos>"}
{"text": "<bos>\nusing the object's clone method.\n• Classes that provide a clone method must\nindicate this to the runtime system by\nimplementing the Cloneable interface.\n• Drawbacks:\n– Copy of object might not reflect up-to-date status of\noriginal object\n– Copying objects takes time, especially if the objects\nare large and require complicated deep-copying\nmethods.\n– Storing extra copies of objects also requires extra\nmemory.\n“By Reference” Notes\n• Because the client program retains a reference to the\nelement, we say we have exposed the contents of the\ncollection ADT to the client program.\n• The ADT allows direct access to the individual elements\nof the collection by the client program through the client\nprogram’s own references.\n• Drawbacks:\n– We create aliases of our elements, therefore we must deal with\n<eos>"}
{"text": "<bos>\nthe potential problems associated with aliases.\n– This situation is especially dangerous if the client program can\nuse an alias to change an attribute of an element that is used by\nthe ADT to determine the underlying organization of the\nelements – for example if it changes the key value for an\nelement stored in a sorted list.\nAn Example\n• The next three slides show the results of a\nsequence of operations when each of the two\napproaches is used to store a sorted list:\n– We have three objects that hold a person’s name and\nweight (Slide 1)\n– We add the three objects onto a list that sorts objects\nby the variable weight\n– We transform one of the original objects with a diet\nmethod, that changes the weight of the object\nExample Step 1: The Three Objects\nBy Copy Approach By Reference Approach\n<eos>"}
{"text": "<bos>\nExample Step 2: Add Objects to List\nBy Copy Approach By Reference Approach\nExample Step 3: S1.diet(-105)\nBy Copy Approach By Reference Approach\nProblem: List copy is out of date Problem: List is no longer sorted\nWhich approach is better?\n• That depends.\n• If processing time and space are issues, and if we are\ncomfortable counting on the application programs to\nbehave properly, then the “by reference” approach is\nprobably best.\n• If we are not too concerned about time and space\n(maybe our list objects are not too large), but we are\nconcerned with maintaining careful control over the\naccess to and integrity of our lists, then the “by copy”\napproach is probably best.\n• The suitability of either approach depends on what the\nlist is used for.\n5.6 Link-Based Collection\nImplementation\n• Internal\n<eos>"}
{"text": "<bos>\nrepresentation: unsorted linked list\n• Reuses design/code from previous classes\n• Code is in the ch05.collections package\n• The find method sets the boolean found plus\ntwo “pointers” if element is found: previous\nand location\n• The next slide lists array-based and link-based\nfind side-by-side for comparison\nArray-Based Link-Based\nprotected void find(T target) protected void find(T target)\n{ {\nlocation = 0; location = head;\nfound = false; found = false;\nwhile (location < numElements) while (location != null)\n{ {\nif elements[location].equals(target)) if (location.getInfo().equals(target))\n{ {\nfound = true; found = true;\nreturn; return;\n} }\nelse else\nlocation++; {\n} previous = location;\n} location = location.getLink();\n}\n}\n}\nRemoving an element\npublic boolean remove (T target)\n{\nfind(target);\n<eos>"}
{"text": "<bos>\nif (found)\n{\nif (head == location)\nhead = head.getLink(); // remove first node\nelse\nprevious.setLink(location.getLink()); // remove node at location\nnumElements--;\n}\nreturn found;\n}\nOur Collection Architecture\nComparing Collection\nImplementations\n5.7 Collection Variations\n• The Collection ADT offers simple but crucial\nfunctionality–the ability to store and retrieve information.\n• This functionality sits at the heart of information\nprocessing.\n• Data structures, file systems, memory/storage,\ndatabases, the Cloud, the Internet all involve, at their\ncore, storing and retrieving information.\n• There are many variations of collections, including the\nlists, search trees, maps, hash tables, and priority\nqueues we study in the upcoming chapters\nThe Java Collections Framework\n• The Java library\n<eos>"}
{"text": "<bos>\nprovides a robust collections\nframework\n• At the center of the framework is the\nCollection interface, found in the java.util\npackage of the library. This interface supports 11\nsubinterfaces including Deque, List, and Set\nand has 33 implementing classes\n• If you are interested in learning more about the\nJava Collections Framework, reference the\nextensive documentation available at Oracle’s\nwebsite.\nThe Bag ADT\n• On pages 332 and 333 we define a\nBagInterface that extends\nCollectionInterface with the additional\nmethods grab, count, removeAll and clear\n• Implementation is left as an exercise\nThe BagInterface\npackage ch05.collections;\npublic interface BagInterface<T> extends CollectionInterface\n{\nT grab();\n// If this bag is not empty, removes and returns a random\n// element of the bag;\n<eos>"}
{"text": "<bos>\notherwise returns null.\nint count(T target);\n// Returns a count of all elements e in this collection\n// such that e.equals(target).\nint removeAll(T target);\n// Removes all elements e from this collection such that\n// e.equals(target) and returns the number of elements removed.\nvoid clear();\n// Empties this bag so that it contains zero elements.\n}\nThe Set ADT\n• Our collection ADTs allow duplicate elements. If\nwe disallow duplicate elements, we have a\ncollection commonly known as a Set.\n• The Set ADT models the mathematical set that\nis typically defined as a collection of distinct\nobjects.\nSet ADT Implementations\n• We can implement a Set class by copying and\nchanging the code from one of our collection\nimplementations—the only method we need to\nchange is the add method.\n• The new add method\n<eos>"}
{"text": "<bos>\ncould be designed to\ncheck if the element argument is not already in\nthe collection, and if not it would add the element\nand return true.\n• Otherwise, of course, it returns false.\nSet ADT Implementations\n• We can also implement a Set class by\nextending a previous class and overwriting add\n– See BasicSet1 of the ch05.collections\npackage, which extends the LinkedCollection\nclass\n• We can also implement a Set class by wrapping\na previous class and re-writing add\n– See BasicSet2 of the ch05.collections\npackage, which wraps an object of the\nLinkedCollection class.\n<eos>"}
