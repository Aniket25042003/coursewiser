{"text": "<bos>\nChapter 6\nThe List\nADT\nChapter 6: The List ADT\n6.1 – The List Interface\n6.2 – List Implementations\n6.3 – Applications: Card Deck and Games\n6.4 – Sorted Array-Based List Implementation\n6.5 – List Variations\n6.6 – Application: Large Integers\n6.1 – The List Interface\n• A list is a collection of elements, with a linear\nrelationship existing among its elements.\n• Each element on the list has a position on the\nlist, its index.\n• In addition to our lists supporting the standard\ncollection operations add, get, contains, remove,\nisFull, isEmpty, and size, they support index-\nrelated operations and iteration.\nIndexes\n• The elements of a list are indexed sequentially,\nfrom zero to one less than the size of the list\n• We define methods for adding, retrieving,\nchanging, and removing an element at an\n<eos>"}
{"text": "<bos>\nindicated index, as well as a method for\ndetermining the index of an element.\n• Each method that accepts an index as an\nargument throws an exception\n(IndexOutOfBoundsException) if the index\nis invalid\nFor example\nvoid add(int index, T element);\n// Throws IndexOutOfBoundsException if passed an index argument\n// such that index < 0 or index > size().\n// Otherwise, adds element to this list at position index; all current\n// elements at that position or higher have 1 added to their index.\n// Optional. Throws UnsupportedOperationException if not supported.\nT set(int index, T newElement);\n// Throws IndexOutOfBoundsException if passed an index argument\n// such that index < 0 or index >= size().\n// Otherwise, replaces element on this list at position index with\n// newElement and returns the\n<eos>"}
{"text": "<bos>\nreplaced element.\n// Optional. Throws UnsupportedOperationException if not supported.\nOptional Operations\n• The add and set operations are optional.\n• These operations allow the client to insert an\nelement into a list at a specified index and for\nsome list implementations, notably a sorted list\nimplementation, this could invalidate the internal\nrepresentation of the list.\n• Our implementations will throw the Java library\nsupplied UnsupportedOperationException\nin cases where an implementation does not\nsupport an operation.\nIteration\n• Our lists implement the library’s Iterable\ninterface.\n• Iterable requires a single method, iterator,\nthat creates and returns an Iterator object.\n• Methods that create and return objects are\nsometimes called Factory methods.\n• Iterator objects provide three\n<eos>"}
{"text": "<bos>\noperations:\nhasNext, next, and remove.\nExample use of an Iterator\nSuppose strings is a List ADT object that contains the four strings “alpha,”\n“gamma,” “beta,” and “delta.” The following code would delete “gamma”\nfrom the list and display the other three strings.\nIterator<String> iter = strings.iterator();\nString hold;\nwhile (iter.hasNext())\n{\nhold = iter.next();\nif (hold.equals(\"gamma\"))\niter.remove();\nelse\nSystem.out.println(hold);\n}\nListInterface\n(comments removed)\npackage ch06.lists;\nimport java.util.*;\nimport ch05.collections.CollectionInterface;\npublic interface ListInterface<T> extends CollectionInterface<T>,\nIterable<T>\n{\nvoid add(int index, T element);\nT set(int index, T newElement);\nT get(int index);\nint indexOf(T target);\nT remove(int index);\n}\n6.2 List Implementations\n• In this\n<eos>"}
{"text": "<bos>\nsection we develop an array-based and a\nlink-based implementation of the List ADT.\n• Because a list is a collection the mplementations\nshare some design and code with their\nCollection ADT counterparts.\n• Here we emphasize the new functionality—the\nindexing and the iteration\nArray-Based Implementation\n• Same approach for our array-based list:\n• … except must maintain index “order” of\nelements during operations:\nIndex Related Operations\n• The methods each follow the same pattern:\n– check the index argument\n– if it is outside the allowable range for that operation\nthrow an exception\n– otherwise carry out the operation.\n• Because of the close logical relationship\nbetween the internal representation, an array,\nand the ADT, an indexed list, the implementation\nof these operations is very\n<eos>"}
{"text": "<bos>\nstraightforward.\nFor example, the set method\npublic T set(int index, T newElement)\n// Throws IndexOutOfBoundsException if passed an index argument\n// such that index < 0 or index >= size().\n// Otherwise, replaces element on this list at position index with\n// newElement and returns the replaced element.\n{\nif ((index < 0) || (index >= size()))\nthrow new IndexOutOfBoundsException(\"Illegal index of \" + index +\n\" passed to ABList set method.\\n\");\nT hold = elements[index];\nelements[index] = newElement;\nreturn hold;\n}\nIteration\n• We use an anonymous inner class approach\n• Anonymous class has no name .. it is just\ninstantiated where needed\n• The behavior of an iterator is unspecified if the\nunderlying representation is modified while the\niteration is in progress in any way other than by\ncalling\n<eos>"}
{"text": "<bos>\nthe iterator’s remove method\npublic Iterator<T> iterator()\n{\nreturn new Iterator<T>()\n{\nprivate int previousPos = -1;\npublic boolean hasNext()\n{\nreturn (previousPos < (size() - 1)) ;\n}\npublic T next()\n{\nif (!hasNext())\nthrow new IndexOutOfBoundsException(\"Illegal invocation of next \" +\n\" in LBList iterator.\\n\");\npreviousPos++;\nreturn elements[previousPos];\n}\npublic void remove()\n{\nfor (int i = previousPos; i <= numElements - 2; i++)\nelements [i] = elements[i+1];\nelements [numElements - 1] = null;\nnumElements--;\npreviousPos--;\n}\n};\n}\nLink-Based Implementation\n• Some of the link-based collection implementation\ndesign and code can be reused for the link-based\nlist.\n• To support the add method, which adds elements\nto the end of the list, we maintain a new\nreference rear to the end of the list.\n<eos>"}
{"text": "<bos>\n• To support the indexOf method we include a\nnew targetIndex variable, which the find\nmethod sets, in addition to setting found,\nlocation, and previous.\nExample Index Related Operation\npublic T set(int index, T newElement\n// Throws IndexOutOfBoundsException if passed an index argument\n// such that index < 0 or index >= size().\n// Otherwise, replaces element on this list at position index with\n// newElement and returns the replaced element.\n{\nif ((index < 0) || (index >= size()))\nthrow new IndexOutOfBoundsException(\"Illegal index of \" + index +\n\" passed to LBList set method.\\n\");\nLLNode<T> node = front;\nfor (int i = 0; i < index; i++)\nnode = node.getLink();\nT hold = node.getInfo();\nnode.setInfo(newElement);\nreturn hold;\n}\nIteration\n• Again use an anonymous inner class within the\niterator\n<eos>"}
{"text": "<bos>\nmethod.\n• The instantiated Iterator object keeps track of\nthree instance variables to provide the iteration\nand to support the required remove operation:\n• The next method returns the element\nreferenced by nextPos and updates the three\nreferences\nIteration\n• If remove invoked in the middle of an iteration it\nremoves the element that was just returned, the\nelement referenced by currPos:\n6.3 Applications:\nCard Deck and Games\nThe Card class\n• Found in the support.cards package\n• A card object has three attributes:\n– rank: the rank of the card e.g. Five or King\n– suit: the suit of the card e.g. Heart or Spade\n– image: an image icon associated with the card\n• rank and suit are both represented by public\nenum classes provided by the Card class\n• The image files used for the image icons are\nalso\n<eos>"}
{"text": "<bos>\nlocated in the support.cards package\n• Attribute getter methods are provided plus an\nequals, a compareTo and a toString\nThe CardDeck class\n• Uses an ABList of Card objects named deck as\nits internal representation\n• Another instance variable, deal, which holds an\nIterator<Card> object, is used to deal cards\n• deal is set to deck.iterator()\n• Exports methods for shuffling the deck and\niterating through the deck\nApplications\n• CardHandCLI – command line interface\nprogram which deals a 5 card hand from a card\ndeck, allowing the user to arrange the cards\n• CardHandGUI – graphical user interface\nprogram which deals a 5 card hand from a card\ndeck, allowing the user to arrange the cards\n• HigherLower – Predict whether the next card\nwill be higher or lower\n• Pairs – Analyzes the probability of\n<eos>"}
{"text": "<bos>\nbeing dealt\na pair in a 5 card hand\n6.4 Sorted Array-Based List\nImplementation\n• Class SortedABList implements\nListInterface and is found in the\nch06.lists package\n• Much of the design and code of the\nSortedArrayCollection from the\nch05.collections package can be reused.\n• We state as a general precondition of the class\nthat the index-based add and set operations\nare not supported.\nCode for the two unsupported\nmethods\npublic void add(int index, T element)\n// Throws UnsupportedOperationException.\n{\nthrow new UnsupportedOperationException(\"Unsupported index-based add …\n}\npublic T set(int index, T newElement)\n// Throws UnsupportedOperationException.\n{\nthrow new UnsupportedOperationException(\"Unsupported index-based set …\n}\nComparator Interface\n• We want to allow clients of our SortedABList\nto\n<eos>"}
{"text": "<bos>\nbe able to specify for themselves how the\nelements should be sorted\n• The Java Comparator interface defines two\nabstract methods:\npublic abstract int compare(T o1, T o2);\n// Returns a negative integer, zero, or a positive integer to indicate that\n// o1 is less than, equal to, or greater than o2\npublic abstract boolean equals(Object obj);\n// Returns true if this Comparator equals obj; otherwise, false\n• Using an approach based on the Comparator\nclass allows for multiple sorting orders\nComparator Interface\n• Using an approach based on the Comparator\nclass allows for multiple sorting orders\n• For example our FamousPerson class typically\nbases comparison on last name, first name but it\ncould also define other approaches:\npublic static Comparator<FamousPerson> yearOfBirthComparator()\n{\nreturn\n<eos>"}
{"text": "<bos>\nnew Comparator<FamousPerson>()\n{\npublic int compare(FamousPerson element1, FamousPerson element2)\n{\nreturn (element1.yearOfBirth - element2.yearOfBirth);\n}\n};\n}\nSortedABList Constructors\n• There are two constructors\n• One uses the “natural order” of the elements\n• The other uses an order provided by the client\nwho passes an appropriate Comparator object\nas an argument to the method\n• A private variable comp of class\nComparator<T> is used to make comparisons\ninternally and is set by the invoked constructor\nSortedABList Constructors\nprotected Comparator<T> comp;\npublic SortedABList()\n// Precondition: T implements Comparable\n{\nlist = (T[]) new Object[DEFCAP];\ncomp = new Comparator<T>()\n{\npublic int compare(T element1, T element2)\n{\nreturn ((Comparable)element1).compareTo(element2);\n}\n};\n}\n<eos>"}
{"text": "<bos>\npublic SortedABList(Comparator<T> comp)\n{\nlist = (T[]) new Object[DEFCAP];\nthis.comp = comp;\n}\nOur List\nADT\nArchitecture\n6.5 List Variations\n• Java Library\n– The library provides a List interface that inherits\nfrom both the Collection and Iterable interfaces\nof the library.\n– The library’s list interface is significantly more\ncomplex than ours, defining 28 abstract methods.\n– It is implemented by the following classes:\nAbstractList, AbstractSequentialList,\nArrayList, AttributeList,\nCopyOnWriteArrayList, LinkedList,\nRoleList, RoleUnresolvedList, Stack, and\nVector.\nLinked List Variations\nA Linked List as an Array of Nodes\nWhy Use an Array?\n• Sometimes managing the free space\nourselves gives us greater flexibility\n• There are programming languages that do\nnot support dynamic allocation or\n<eos>"}
{"text": "<bos>\nreference types\n• There are times when dynamic allocation\nof each node, one at a time, is too costly in\nterms of time\nBoundedness\n• A desire for static allocation is one of the primary\nmotivations for the array-based linked approach\n• We drop our assumption that our lists are of\nunlimited size in this section - our lists will not\ngrow as needed.\n• Applications should not add elements to a full\nlist.\nA\nsorted\nlist\nImplementation Issues\n• We mark the end of the list with a “null” value\n– the “null” value must be an invalid address for a real list element\n– we use the value –1\n– we suggest using the identifier NUL and defining it to be -1\nprivate static final int NUL = –1;\n• One must directly manage the free space available for\nnew list elements.\n– Link the collection of unused array elements\n<eos>"}
{"text": "<bos>\ntogether into a\nlinked list of free nodes.\n– Write your own method to allocate nodes from the free space.\nWe suggest calling this method getNode.\n– Write your own method, we suggest calling it freeNode, to put a\nnode back into the pool of free space when it is de-allocated.\nA linked\nlist and\nfree\nspace\n6.6 Application: Large Integers\n• The largest Java integer type, long, can\nrepresent values between\n−9,223,372,036,854,775,808 and\n9,223,372,036,854,775,807\n• Believe it or not, for some applications that may\nnot be sufficient\n• A linked list of digits can grow to be any size,\nand thus can be used to represent integers of\nany size\nRepresenting large integers with\nlinked lists\nThe LargeInt class\n• Constructors – one that creates an “empty” integer and\none that creates an integer based on a\n<eos>"}
{"text": "<bos>\nString\nargument\n• setNegative – makes the large integer negative\n• toString – returns string representation\n• add – returns the sum of two large integers\n• subtract – returns the difference of two large integers\n• To support the creation and arithmetic manipulation of\nlarge integers we define a special list class …\nThe LargeIntList class\n• a list of byte (to hold digits)\n• provide operations size, addFront, addEnd,\nand both forward and reverse iterators\n• To support these requirements we use a\nreference-based doubly linked structure\nApplications\n• LargeIntCLI - in the ch06.apps package,\nallows the user to enter two large integers,\nperforms the addition and subtraction of the two\nintegers, and reports the results.\n• LargeIntGUI - in the ch06.apps package:\nCode and Demo\n• Instructors can now\n<eos>"}
{"text": "<bos>\nreview the algorithms,\nwalk through the code for the classes, and\ndemonstrate the running applications.\nImportant Concept Revisited:\nAbstraction Hierarchy\n• Here we saw another example of an abstraction\nhierarchy.\n• Applications use the LargeInt class, which uses the\nLargeIntList class, which uses the DLLNode class.\n• When working at any level in this hierarchy as a\nprogrammer we need to know only how to use the next\nlower level – we do not need to know how it is\nimplemented nor need we worry about the details of\nlower levels.\n• Abstraction is indeed the key to conquering complexity.\n<eos>"}
