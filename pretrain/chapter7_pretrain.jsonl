{"text": "<bos>\nChapter 7\nThe Binary\nSearch\nTree ADT\nChapter 7: The Binary Search\nTree ADT\n7.1 – Trees\n7.2 – Binary Search Trees\n7.3 – The Binary Search Tree Interface\n7.4 – The Implementation Level: Basics\n7.5 – Iterative Versus Recursive Method Implementations\n7.6 – The Implementation Level: Remaining Observers\n7.7 – The Implementation Level: Transformers\n7.8 – Binary Search Tree Performance\n7.9 – Application: Word Frequency Counter\n7.10 – Tree Variations\nBinary Search Tree\n• When maintaining a sorted list\n– Linked List requires O(N) find location, O(1) insertion\n– Array requires O(log N) find location, O(N) insertion\n2\n– Binary Search Tree, in general allows O(log N) find\n2\nlocation , O(1) insertion\n7.1 Trees\n• A tree is a nonlinear\nstructure in which\neach node is capable\nof having many\nsuccessor\n<eos>"}
{"text": "<bos>\nnodes,\ncalled children.\n• Trees are useful for\nrepresenting lots of\nvaried relationships\namong data items.\nDefinitions\n• Tree A structure with a unique starting node\n(the root), in which each node is capable of\nhaving multiple successor nodes (its children),\nand in which a unique path exists from the root\nto every other node.\n• Root The top node of a tree structure; a node\nwith no parent\n• Parent node The predecessor node of a node\nis its parent\n• Subtree A node and all of its descendants form\na subtree rooted at the node\nExamples\n• The root is A\n• The children of A are B,\nF, and X\n• The parent of Q is X\n• The leftmost subtree of\nX contains H and P\nRequired\n• A tree’s subtrees\nmust be disjoint\n• There is a unique\npath from the root\nof a tree to any\nother node of the\ntree\nNot a Tree →\n<eos>"}
{"text": "<bos>\nDefinitions\n• Ancestor A parent of a node, or a parent of an\nancestor\n• Descendant A child of a node, or a child of a\ndescendant\n• Leaf A node that has no children\n• Interior node A node that is not a leaf\n• Siblings Nodes with the same parent\nExamples\n• The ancestors of P are\nH, X, and A\n• The descendants of X\nare H, Q, Z, and P\n• The leaf nodes are C,\nT, F, P, Q, and Z\n• The interior nodes are\nA, B, X\n• The siblings of B are F\nand X\nDefinitions\n• Level The level of a node is its distance from the\nroot (the number of connections between itself\nand the root)\n• Height The maximum level of the tree\nExamples\n• The level of A is 0\n• The level of P is 3\n• The height of the\ntree is 3\nBreadth-First Traversal\n• Also called “level-order traversal”\n• A B F X C T H Q Z P\nBreadth-First Traversal(root)\n<eos>"}
{"text": "<bos>\nInstantiate a queue of nodes\nif (root is not null)\n{\nqueue.enqueue(root)\nwhile (!queue.isEmpty())\n{\nnode = queue.dequeue()\nTry It!\nVisit node\nEnqueue the children of node\n(from left to right) into queue\n}\n}\nDepth-First Traversal\n• A B C T F X H P Q Z\nDepth-First Traversal(root)\nInstantiate a stack of nodes\nif (root is not null)\n{\nstack.push(root)\nwhile (!stack.isEmpty())\n{\nnode = stack.top()\nTry It!\nstack.pop()\nVisit node\nPush the children of node\n(from right to left) onto queue\n}\n}\n7.2 Binary Search Trees\n• Binary tree A\ntree in which\neach node is\ncapable of having\ntwo child nodes,\na left child node\nand a right child\nnode\nA Binary Tree\nA Binary\nSearch\nTree\nThese trees facilitate\nsearching for an\nelement.\nBinary search tree\n• A binary tree in which the key\nvalue in any node\n– is greater\n<eos>"}
{"text": "<bos>\nthan or equal to the\nkey value in its left child and any\nof its descendants (the nodes in\nthe left subtree)\n– is less than the key value in its\nright child and any of its\ndescendants (the nodes in the\nright subtree)\n• We call this the “binary\nsearch tree” property\nBinary Tree Traversals\n• Preorder traversal: Visit the\nroot, visit the left subtree, visit\nthe right subtree:\n– D B A C F G\n• Inorder traversal: Visit the left\nsubtree, visit the root, visit the\nright subtree:\n– A B C D F G\n• Postorder traversal: Visit the\nleft subtree, visit the right\nsubtree, visit the root:\n– A C B G F D\nVisualizing Binary Tree Traversals\nThree\nBinary Tree\nTraversals\n7.3 – The Binary Search Tree\nInterface\n• Our binary search trees\n– are similar to the sorted lists of Chapter 6\n– implement this text’s\n<eos>"}
{"text": "<bos>\nCollectionInterface\n– implement the Java Library’s Iterable interface\n– are unbounded, allow duplicate elements, and\ndisallow null elements\n– support max and min operations\n– support preorder, inorder, and postorder traversals\npackage ch07.trees;\nimport ch05.collections.CollectionInterface;\nimport java.util.Iterator;\npublic interface BSTInterface<T> extends CollectionInterface<T>,\nIterable<T>\n{\n// Used to specify traversal order.\npublic enum Traversal {Inorder, Preorder, Postorder};\nT min();\n// If this BST is empty, returns null;\n// otherwise returns the smallest element of the tree.\nT max();\n// If this BST is empty, returns null;\n// otherwise returns the largest element of the tree.\npublic Iterator<T> getIterator(Traversal orderType);\n// Creates and returns an Iterator providing a\n<eos>"}
{"text": "<bos>\ntraversal of a \"snapshot“\n// of the current tree in the order indicated by the argument.\n}\nIteration\n• In addition to the getIterator method, a class that\nimplements the BSTInterface must provide a\nseparate iterator method, because\nBSTInterface extends Iterable.\n• This method should return an Iterator that\nprovides iteration in the “natural” order of the\ntree elements.\n• For most applications this would be an inorder\ntraversal, and we make that assumption in our\nimplementation.\nIteration\n• We intend the iterators created and returned by\ngetIterator and iterator to provide a\nsnapshot of the tree as it exists at the time the\niterator is requested.\n• They represent the state of the tree at that time\nand subsequent changes to the tree should not\naffect the results returned by the iterator’s\n<eos>"}
{"text": "<bos>\nhasNext and next methods.\n• Our iterators will throw an\nUnsupportedOperationException if\nremove is invoked.\nExample Application\n• Instructors can review and demonstrate the\napplication BSTExample found in the\nch07.apps package\n• This application demonstrates the use of\niterators with our binary search tree\n7.4 The Implementation Level:\nBasics\n• We define BSTNode.java in our support\npackage to provide nodes for our binary search\ntrees\n• Visually, a BSTNode object is:\nBSTNode.java\ninstance variables:\nprivate T info; // The info in a BST node\nprivate BSTNode<T> left; // A link to the left child node\nprivate BSTNode<T> right; // A link to the right child node\nConstructor:\npublic BSTNode(T info)\n{\nthis.info = info;\nleft = null;\nright = null;\n}\nPlus it includes the standard setters and getters\n<eos>"}
{"text": "<bos>\nBeginning of\nBinarySearchTree.java\npackage ch07.trees;\nimport java.util.*; // Iterator, Comparator\nimport ch04.queues.*;\nimport ch02.stacks.*;\nimport support.BSTNode;\npublic class BinarySearchTree<T> implements BSTInterface<T>\n{\nprotected BSTNode<T> root; // reference to the root of this BST\nprotected Comparator<T> comp; // used for all comparisons\nprotected boolean found; // used by remove\n. . .\nThe Constructors\npublic BinarySearchTree()\n// Precondition: T implements Comparable\n// Creates an empty BST object - uses the natural order of elements.\n{\nroot = null;\ncomp = new Comparator<T>()\n{\npublic int compare(T element1, T element2)\n{\nreturn ((Comparable)element1).compareTo(element2);\n}\n};\n}\npublic BinarySearchTree(Comparator<T> comp)\n// Creates an empty BST object - uses Comparator comp\n<eos>"}
{"text": "<bos>\nfor order of elements.\n{\nroot = null;\nthis.comp = comp;\n}\n. . .\nExample Observer methods\npublic boolean isFull()\n// Returns false; this link-based BST is never full.\n{\nreturn false;\n}\npublic boolean isEmpty()\n// Returns true if this BST is empty; otherwise, returns false.\n{\nreturn (root == null);\n}\npublic T min()\n// If this BST is empty, returns null;\n// otherwise returns the smallest element of the tree.\n{\nif (isEmpty())\nreturn null;\nelse\n{\nBSTNode<T> node = root;\nwhile (node.getLeft() != null)\nnode = node.getLeft();\nreturn node.getInfo();\n}\n}\n7.5 Iterative versus Recursive\nMethod Invocations\n• Trees are inherently recursive; a tree consists of\nsubtrees\n• In this section we look at recursive and iterative\napproaches to the size method\n• We then discuss the benefits of recursion versus\n<eos>"}
{"text": "<bos>\niteration for this problem\nRecursive Approach\n• We create a public method, size, that calls a private recursive\nmethod, recSize and passes it a reference to the root of the tree.\npublic int size()\n// Returns the number of elements in this BST.\n{\nreturn recSize(root);\n}\n• We design the recSize method to return the number of nodes in\nthe subtree referenced by the argument passed to it.\n• Note that the number of nodes in a tree is:\n1 + number of nodes in left subtree + number of nodes in right subtree\nrecSize Algorithm\nVersion 1\nrecSize(node): returns int\nif (node.getLeft( ) is null) AND (node.getRight( ) is null)\nreturn 1\nelse\nreturn 1 + recSize(node.getLeft( )) + recSize(node.getRight( ))\n• The corresponding method would crash when we try\nto access node.getLeft when node is null.\nrecSize\n<eos>"}
{"text": "<bos>\nAlgorithm\nVersion 2\nrecSize(node): returns int Version 2\nif (node is null)\nreturn 0\nelse\nif (node.getLeft() is null) AND (node.getRight() is null)\nreturn 1\nelse\nreturn 1 + recSize(node.getLeft()) + recSize(node.getRight())\n• Works, but can be simplified. There is no need to\nmake the leaf node a special case – it would also be\nhandled properly by the final else clause\nrecSize Algorithm\nVersion 3\nrecSize(node): returns int Version 3\nif node is null\nreturn 0\nelse\nreturn 1 + recSize(node.getLeft( )) + recSize(node.getRight( ))\n• Works and is “simple”.\n• This example illustrates two important points about\nrecursion with trees:\n– always check for the empty tree first\n– leaf nodes do not need to be treated as separate cases.\nThe recSize Code\nprivate int recSize(BSTNode<T> node)\n// Returns the\n<eos>"}
{"text": "<bos>\nnumber of elements in subtree rooted at node.\n{\nif (node == null)\nreturn 0;\nelse\nreturn 1 + recSize(node.getLeft()) + recSize(node.getRight());\n}\nIterative Version\n• We use a stack to hold nodes we have\nencountered but not yet processed\n• We must be careful that we process each node\nin the tree exactly once. We follow these rules:\n– Process a node immediately after removing it from\nthe stack.\n– Do not process nodes at any other time.\n– Once a node is removed from the stack, do not push\nit back onto the stack.\nCode for the iterative approach\npublic int size()\n// Returns the number of elements in this BST.\n{\nint count = 0;\nif (root != null)\n{\nLinkedStack<BSTNode<T>> nodeStack = new LinkedStack<BSTNode<T>> ();\nBSTNode<T> currNode;\nnodeStack.push(root);\nwhile (!nodeStack.isEmpty())\n{\ncurrNode\n<eos>"}
{"text": "<bos>\n= nodeStack.top();\nnodeStack.pop();\ncount++;\nif (currNode.getLeft() != null)\nnodeStack.push(currNode.getLeft());\nif (currNode.getRight() != null)\nnodeStack.push(currNode.getRight());\n}\n}\nreturn count;\n}\nRecursion or Iteration?\n• Is the depth of recursion relatively shallow? Yes\n• Is the recursive solution shorter or clearer than\nthe nonrecursive version? Yes\n• Is the recursive version much less efficient than\nthe nonrecursive version? No\n• This is a good use of recursion.\n7.6 The Implementation Level:\nRemaining Operations\n• In this section, we use recursion to implement\nthe remaining Binary Search Tree operations\n– contains\n– get\n– add\n– remove\n– iterator\n– getIterator\nThe contains operation\n• We implement contains using a private\nrecursive method called recContains which\n– is passed the\n<eos>"}
{"text": "<bos>\ntarget we are searching for and a\nnode representing the root of the subtree in which to\nsearch\n– has two base cases\n• if node is null returns false\n• if node contains target returns true\n– has two recursive cases\n• one searches the left subtree of node\n• one searches the right subtree of node\nThe contains method\npublic boolean contains (T target)\n// Returns true if this BST contains a node with info i such that\n// comp.compare(target, i) == 0; otherwise, returns false.\n{\nreturn recContains(target, root);\n}\nprivate boolean recContains(T target, BSTNode<T> node)\n// Returns true if the subtree rooted at node contains info i such that\n// comp.compare(target, i) == 0; otherwise, returns false.\n{\nif (node == null)\nreturn false; // target is not found\nelse if (comp.compare(target, node.getInfo())\n<eos>"}
{"text": "<bos>\n< 0)\nreturn recContains(target, node.getLeft()); // Search left subtree\nelse if (comp.compare(target, node.getInfo()) > 0)\nreturn recContains(target, node.getRight()); // Search right subtree\nelse\nreturn true; // target is found\n}\nThe get method is similar\npublic T get(T target)\n// Returns info i from node of this BST where comp.compare(target, i) == 0;\n// if no such node exists, returns null.\n{\nreturn recGet(target, root);\n}\nprivate T recGet(T target, BSTNode<T> node)\n// Returns info i from the subtree rooted at node such that\n// comp.compare(target, i) == 0; if no such info exists, returns null.\n{\nif (node == null)\nreturn null; // target is not found\nelse if (comp.compare(target, node.getInfo()) < 0)\nreturn recGet(target, node.getLeft()); // get from left subtree\nelse\nif\n<eos>"}
{"text": "<bos>\n(comp.compare(target, node.getInfo()) > 0)\nreturn recGet(target, node.getRight()); // get from right subtree\nelse\nreturn node.getInfo(); // target is found\n}\nIteration: Review of Traversal\nDefinitions\n• Preorder traversal: Visit the root, visit the\nleft subtree, visit the right subtree\n• Inorder traversal: Visit the left subtree,\nvisit the root, visit the right subtree\n• Postorder traversal: Visit the left subtree,\nvisit the right subtree, visit the root\nthe getIterator method\n• client passes getIterator an argument\nindicating one of the three traversal orders\n• getIterator creates the appropriate\niterator and returns it by traversing the tree in\nthe desired order and building a queue of T\n• It then creates an iterator using the\nanonymous inner class approach\n• returned iterator represents\n<eos>"}
{"text": "<bos>\na snapshot of\nthe tree at the time getIterator is invoked\nand does not support remove\npublic Iterator<T> getIterator(BSTInterface.Traversal orderType)\n{\nfinal LinkedQueue<T> infoQueue = new LinkedQueue<T>();\nif (orderType == BSTInterface.Traversal.Preorder)\npreOrder(root, infoQueue);\nelse if (orderType == BSTInterface.Traversal.Inorder)\ninOrder(root, infoQueue);\nelse if (orderType == BSTInterface.Traversal.Postorder)\npostOrder(root, infoQueue);\nreturn new Iterator<T>()\n{\npublic boolean hasNext()\n{\nreturn !infoQueue.isEmpty();\n}\npublic T next()\n{\nif (!hasNext())\nthrow new IndexOutOfBoundsException(\"illegal invocation of next …\nreturn infoQueue.dequeue();\n}\npublic void remove()\n{\nthrow new UnsupportedOperationException(\"Unsupported remove attempted …\n}\n};\n}\nInOrder traversal\nprivate void\n<eos>"}
{"text": "<bos>\ninOrder(BSTNode<T> node, LinkedQueue<T> q)\n// Enqueues the elements from the subtree rooted at node into q in inOrder.\n{ if (node != null)\n{\ninOrder(node.getLeft(), q);\nq.enqueue(node.getInfo());\ninOrder(node.getRight(), q);\n} }\npreOrder and postorder traversals\nprivate void preOrder(BSTNode<T> node, LinkedQueue<T> q)\n{\nif (node != null)\n{\nq.enqueue(node.getInfo());\npreOrder(node.getLeft(), q);\npreOrder(node.getRight(), q);\n}\n}\nprivate void postOrder(BSTNode<T> node, LinkedQueue<T> q)\n{\nif (node != null)\n{\npostOrder(node.getLeft(), q);\npostOrder(node.getRight(), q);\nq.enqueue(node.getInfo());\n}\n}\n7.7 The Implementation Level:\nTransformers\n• To complete our implementation of the Binary\nSearch Tree ADT we need to create the\ntransformer methods add and remove.\n• These are the most complex\n<eos>"}
{"text": "<bos>\noperations.\n• We use a similar approach as used in the\nsubsection “Transforming a Linked List” in\nSection 3.4, “Recursive Processing of Linked\nLists”\nThe add operation\n• A new node is always inserted into its appropriate position in\nthe tree as a leaf\nThe add operation\n• The add method invokes the recursive method, recAdd, and\npasses it the element to be added plus a reference to the root of the\ntree.\npublic boolean add (T element)\n// Adds element to this BST. The tree retains its BST property.\n{\nroot = recAdd(element, root);\nreturn true;\n}\n• The call to recAdd returns a BSTNode. It returns a reference to the\nnew tree, that is, to the tree that includes element. The statement\nroot = recAdd(element, root);\ncan be interpreted as “Set the reference of the root of this tree to the\nroot of the\n<eos>"}
{"text": "<bos>\ntree that is generated when element is added to this tree.”\nThe add method\nprivate BSTNode<T> recAdd(T element, BSTNode<T> node)\n// Adds element to tree rooted at node; tree retains its BST property.\n{\nif (node == null)\n// Addition place found\nnode = new BSTNode<T>(element);\nelse if (element.compareTo(node.getInfo()) <= 0)\nnode.setLeft(recAdd(element, node.getLeft())); // Add in left subtree\nelse\nnode.setRight(recAdd(element, node.getRight())); // Add in right subtree\nreturn tree;\n}\npublic boolean add (T element)\n// Adds element to this BST. The tree retains its BST property.\n{\nroot = recAdd(element, root);\nreturn true;\n}\nThe remove Operation\n• The most complicated of the binary search\ntree operations.\n• We must ensure when we remove an\nelement we maintain the binary search\ntree property.\n<eos>"}
{"text": "<bos>\nThe code for remove:\n• The set up for the remove operation is the same as that for the add\noperation.\n• The private recRemove method is invoked from the public remove\nmethod with arguments equal to the target element to be removed\nand the root of the tree to remove it from.\n• The recursive method returns a reference to the revised tree\n• The remove method returns the boolean value stored in found,\nindicating the result of the remove operation.\npublic boolean remove (T target)\n// Removes a node with info i from tree such that\n// comp.compare(target,i) == 0 and returns true;\n// if no such node exists, returns false.\n{\nroot = recRemove(target, root);\nreturn found;\n}\nThe recRemove method\nprivate BSTNode<T> recRemove(T target, BSTNode<T> node)\n// Removes element with info i from tree rooted at\n<eos>"}
{"text": "<bos>\nnode such that\n// comp.compare(target, i) == 0 and returns true;\n// if no such node exists, returns false.\n{\nif (node == null)\nfound = false;\nelse if (comp.compare(target, node.getInfo()) < 0)\nnode.setLeft(recRemove(target, node.getLeft()));\nelse if (comp.compare(target, node.getInfo()) > 0)\nnode.setRight(recRemove(target, node.getRight()));\nelse\n{\nnode = removeNode(node);\nfound = true;\n}\nreturn node;\n}\nThree cases for the removeNode\noperation\n• Removing a leaf (no children): removing a leaf is\nsimply a matter of setting the appropriate link of\nits parent to null.\n• Removing a node with only one child: make the\nreference from the parent skip over the removed\nnode and point instead to the child of the node\nwe intend to remove\n• Removing a node with two children: replaces the\nnode’s info\n<eos>"}
{"text": "<bos>\nwith the info from another node in\nthe tree so that the search property is retained -\nthen remove this other node\nRemoving a Leaf Node\nRemoving a node with one child\nRemoving a Node With Two Children\nThe Remove Node Algorithm\nremoveNode (node): returns BSTNode\nif (node.getLeft( ) is null) AND (node.getRight( ) is null)\nreturn null\nelse if node.getLeft( ) is null\nreturn node.getRight( )\nelse if node.getRight( ) is null\nreturn node.getLeft( )\nelse\nFind predecessor\nnode.setInfo(predecessor.getInfo( ))\nnode.setLeft(recRemove(predecessor.getInfo( ), node.getLeft( )))\nreturn node\nNote: We can remove one of the tests if we notice that the action taken when the\nleft child reference is null also takes care of the case in which both child references\nare null. When the left child reference is null,\n<eos>"}
{"text": "<bos>\nthe right child reference is returned. If\nthe right child reference is also null, then null is returned, which is what we want if\nthey are both null.\nThe removeNode method\nprivate BSTNode<T> removeNode(BSTNode<T> node)\n// Removes the information at node from the tree.\n{\nT data;\nif (node.getLeft() == null)\nreturn node.getRight();\nelse if (node.getRight() == null)\nreturn node.getLeft();\nelse\n{\ndata = getPredecessor(node.getLeft());\nnode.setInfo(data);\nnode.setLeft(recRemove(data, node.getLeft()));\nreturn node;\n}\n}\nThe getPredecessor method\n• The logical predecessor is the maximum value in node’s\nleft subtree.\n• The maximum value in a binary search tree is in its\nrightmost node.\n• Therefore, given node’s left subtree, we just keep\nmoving right until the right child is null.\n• When this\n<eos>"}
{"text": "<bos>\noccurs, we return the info reference of the\nnode.\nprivate T getPredecessor(BSTNode<T> subtree)\n// Returns the information held in the rightmost node of subtree\n{\nBSTNode temp = subtree;\nwhile (temp.getRight() != null)\ntemp = temp.getRight();\nreturn temp.getInfo();\n}\nOur Binary\nSearch Tree\nArchitecture\n7.8 Binary Search Tree\nPerformance\n• A binary search tree is an appropriate structure for many\nof the same applications discussed previously in\nconjunction with sorted lists.\n• Similar to a sorted array-based list, it can be searched\nquickly, using a binary search.\n• Similar to a linked list, it allows insertions and removals\nwithout having to move large amounts of data.\n• There is a space cost - the binary search tree, with its\nextra reference in each node, takes up more memory\nspace than a\n<eos>"}
{"text": "<bos>\nsingly linked list.\nText Analysis Experiment Revisited\nText Analysis Experiment Revisited\n• Due to operation complexity, performance gains\nfrom the binary search tree are only clearly\nevident as the size of the file increases.\n• The table also reveals a serious issue when the\nbinary search tree structure is used for the Linux\nWord file. The application bombs—it stops\nexecuting and reports a “Stack overflow error.”\n• The problem is that the underlying tree is\ncompletely skewed.\nInsertion\nOrder and\nTree Shape\nLinux Word\nFile is like this →\nBalancing a Binary Search Tree\n• A beneficial addition to our Binary Search Tree\nADT operations is a balance operation\n• The specification of the operation is:\npublic balance();\n// Restructures this BST to be optimally balanced\n• It is up to the client\n<eos>"}
{"text": "<bos>\nprogram to use the\nbalance method appropriately\nOur Approach\n• Basic algorithm:\nSave the tree information in an array\nInsert the information from the array back into the tree\n• The structure of the new tree depends on the\norder that we save the information into the\narray, or the order in which we insert the\ninformation back into the tree, or both\n• We save the information “in order” so that the\narray is sorted\nTo Ensure a Balanced Tree\n• Even out as much as possible, the number\nof descendants in each node’s left and\nright subtrees\n• First insert the “middle” item of the inOrder\narray\n– Then insert the left half of the array using the\nsame approach\n– Then insert the right half of the array using the\nsame approach\nBalance\nOur Balance Tree\nIterator iter = tree.getIterator(Inorder )\nint index\n<eos>"}
{"text": "<bos>\n= 0 Algorithm\nwhile (iter.hasnext())\narray[index] = iter.next( )\nindex++\ntree = new BinarySearchTree()\ntree.InsertTree(0, index - 1)\nInsertTree(low, high)\nif (low == high) // Base case 1\ntree.add(array[low])\nelse if ((low + 1) == high) // Base case 2\ntree.add(array[low])\ntree.add(array[high])\nelse\nmid = (low + high) / 2\ntree.add(array[mid])\ntree.InsertTree(low, mid – 1)\ntree.InsertTree(mid + 1, high)\nUsing\nrecursive\ninsertTree\n7.9 Application: Word Frequency\nCounter\n• In this section we develop a word frequency\ncounter that uses our binary search tree\n• Read a text file and generate an alphabetical\nlisting of the unique words, along with a count of\nhow many times each word occurs\n• We allow users to specify a minimum word size\nand a minimum frequency count\n• Present a few summary\n<eos>"}
{"text": "<bos>\nstatistics\npackage support;\nimport java.text.DecimalFormat;\npublic class WordFreq implements Comparable<WordFreq>\n{\nprivate String word; private int freq;\nDecimalFormat fmt = new DecimalFormat(\"00000\");\npublic WordFreq(String newWord)\n{\nThe WordFreq\nword = newWord; freq = 0;\n}\nClass\npublic String getWordIs(){return word;}\npublic int getFreq(){return freq;}\npublic void inc() { freq++; }\npublic int compareTo(WordFreq other)\n{\nreturn this.word.compareTo(other.word);\n}\npublic String toString()\n{\nreturn(fmt.format(freq) + \" \" + word);\n}\n}\nThe Application\n• Scans the input file for words, and after reading\na word, it checks to see if a match is already in\nthe tree, and if not it inserts a WordFreq object\nthat holds the word and a frequency count of 1\n• If the word is already in the tree,\n<eos>"}
{"text": "<bos>\nincrement the\nfrequency associated with the word\nAlgorithm to process a word\nwordToTry = new WordFreq(word)\nwordInTree = tree.get(wordToTry)\nif (wordInTree != null)\nwordInTree.inc()\nelse\nwordToTry.inc() // to set its frequency to 1\ntree.add(wordToTry);\nProcessing\na word\nThe Application\n• Instructors can now review the code and\ndemonstrate/discuss the application.\n7.10 Tree Variations\n• Trees can be binary, trinary (up to three children per\nnode), n-ary (up to n children per node), alternating ary,\nbalanced, not balanced, partially balanced, self-\nadjusting, and store information in their nodes or their\nedges or both.\n• The Java Library does not include a general tree\nstructure and neither do most textbooks.\n• Often with trees we let the specific target application\ndictate the definition,\n<eos>"}
{"text": "<bos>\nassumptions, rules, and operations\nassociated with a specific implementation.\nApplication-Specific Variations\n• Decision Trees:\nApplication-Specific Variations\n• Expression/Parse Trees:\nApplication-\nSpecific\nVariations\n• R Trees:\nApplication-Specific Variations\n• Tries/Prefix\nTrees:\nBalanced Search Trees\n• The Binary Search Tree ADT presented in this\nchapter is an excellent collection structure for\nholding “random” data, but suffers from one\nmajor weakness—it can become unbalanced.\n• Many search tree variations have been invented\nto address this weakness, each in turn with their\nown strengths and weaknesses.\nBalanced Search Trees\n• B-Trees: a search tree that allows internal nodes\nto hold multiple values and have multiple\nchildren\nBalanced Search Trees\n• B-Tree Variants: A popular variant\n<eos>"}
{"text": "<bos>\nof the B-Tree\nis the 2-3-4 tree, where nodes are constrained to\nhold 1, 2, or 3 values and therefore have 2, 3, or\n4 subtrees (thus the name of the tree)\n• Searching, insertion, and removal of information\nis always O(log N) and the amount of work\n2\nrequired to process the information within any\nnode is constant.\nBalanced Search Trees\n• A 2-3-4 tree can be implemented using a binary tree\nstructure called a red-black tree. In this structure nodes\nare “colored” either red or black (each node must hold an\nextra boolean value that indicates this information). The\ncolor of a node indicates how its value fits into the\ncorresponding 2-3-4 tree.\n• The Java Library includes two important classes that use\ntree implementations. The Java TreeMap class supports\nmaps (see Chapter 8) and the Java TreeSet\n<eos>"}
{"text": "<bos>\nclass\nsupports sets (see Section 5.7, “Collection Variations”).\nIn both cases the internal representation is a red-black\ntree.\nBalanced Search Trees\n• AVL Trees: the\ndifference in height\nbetween a node’s\ntwo subtrees can be\nat most 1.\n• During addition and\nremoval of nodes\nextra work is\nrequired to ensure\nthe tree remains\nbalanced.\n<eos>"}
