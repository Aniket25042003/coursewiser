{"text": "<bos>\nChapter 8\nThe Map\nADT\nChapter 8: The Map ADT\n8.1 – The Map Interface\n8.2 – Map Implementations\n8.3 – Application: String-to-String Map\n8.4 – Hashing\n8.5 – Hash Functions\n8.6 – A Hash-Based Map\n8.7 – Map Variations\n8.1 The Map Interface\n• Maps associate a\nkey with exactly\none value\n• In other words\n– a map structure\ndoes not permit\nduplicate keys\n– but two distinct\nkeys can map onto\nthe same value\nLegal mapping variations\nMapInterface\n//------------------------------------------------------------------------\n// MapInterface.java by Dale/Joyce/Weems Chapter 8\n//\n// A map provides (K = key, V = value) pairs, mapping the key onto\n// the value.\n// Keys are unique. Keys cannot be null.\n//\n// Methods throw IllegalArgumentException if passed a null key argument.\n//\n// Values can be null, so a null\n<eos>"}
{"text": "<bos>\nvalue returned by put, get, or remove does\n// not necessarily mean that an entry did not exist.\n//------------------------------------------------------------------------\n//\n// . . . continued on next slide\npackage ch08.maps;\nimport java.util.Iterator;\npublic interface MapInterface<K, V> extends Iterable<MapEntry<K,V>>\n{\nV put(K k, V v);\n// If an entry in this map with key k already exists then the value\n// associated with that entry is replaced by value v and the original\n// value is returned; otherwise, adds the (k, v) pair to the map and\n// returns null.\nV get(K k);\n// If an entry in this map with a key k exists then the value associated\n// with that entry is returned; otherwise null is returned.\nV remove(K k);\n// If an entry in this map with key k exists then the entry is removed\n//\n<eos>"}
{"text": "<bos>\nfrom the map and the value associated with that entry is returned;\n// otherwise null is returned.\n//\n// Optional. Throws UnsupportedOperationException if not supported.\n// Also requires contains(K key), isFull(), isEmpty() and size()\n}\nIteration\n• We require an iteration that returns key-value\npairs\n• The class MapEntry represents the key-value\npairs\n– requires the key and value to be passed as\nconstructor arguments\n– provides getter operations for both key and value\n– provides a setter operation for the value\n– provides a toString\nMapExample\n• Instructors can now discuss and demonstrate\nthe MapExample application found in the\nch08.apps package … it uses the\nArrayListMap class presented in the next\nsection\n8.2 Map Implementations\n• Unsorted Array\n– The put operation creates a new MapEntry\n<eos>"}
{"text": "<bos>\nobject\nand performs a brute force search (O(N)) of all the\ncurrent keys in the array to prevent key duplication\n– If a duplicate key is found, then the associated\nMapEntry object is replaced by the new object and\nits value attribute is returned, for example\nmap.put(cow)\nMap Implementations\n• Unsorted Array\n– Like put, the get, remove, and contains\noperations would all require brute force searches of\nthe current array contents, so they are all O(N)\n• Sorted Array\n– The binary search algorithm can be used, greatly\nimproving the efficiency of the important get and\ncontains operations.\n– Although it is not a requirement, in general it is\nexpected that a map will provide fast implementation\nof these two operations.\nMap Implementations\n• Unsorted Linked List\n– Similar to an unsorted array, most\n<eos>"}
{"text": "<bos>\noperations require\nbrute force search\n– In terms of space, a linked list grows and shrinks as\nneeded so it is possible that some advantage can be\nfound in terms of memory management, as compared\nto an array.\nMap Implementations\n• Sorted Linked List\n– Even though a linked list is kept sorted, it does not\npermit use of the binary search algorithm as there is\nno efficient way to inspect the “middle” element.\n– So there is not much advantage to using a sorted\nlinked list to implement a map, as compared to an\nunsorted linked list\nMap Implementations\n• Binary Search Tree\n– If a map can be implemented as a balanced binary\nsearch tree, then all of the primary operations (put,\nget, remove, and contains) can exhibit efficiency\nO(log N).\n2\nArrayListMap\n• Instructors can now discuss the ArrayListMap\n<eos>"}
{"text": "<bos>\nclass found in the ch08.maps package and\nreview the associated notes found on pages 511\nand 512\n8.3 Application:\nString-to-String Map\n• The StringPairApp found in the ch08.apps\npackage reads # separated pairs of strings (key\n# value) from specified input file and then allows\nthe user to enter keys and reports back to them\nthe associated value if there is one.\n• It is a short yet versatile application that\ndemonstrates the use of our Map ADT\n8.4 Hashing\n• An efficient approach to implementing a Map\n• Typically provides O(1) operation\nimplementation\n• Uses an array (typically called a hash table) to\nhold the key/value pairs\n• Hashing involves determining array indices\ndirectly from the key of the entry being\nstored/accessed.\nCompression function\n• If we have a positive\nintegral key, such as\n<eos>"}
{"text": "<bos>\nan\nID number, we can just\nuse the key as the index\ninto the array\n• If the range of key\nvalues is larger than the\narray we must\n“compress” the key into\na usable index\nCollisions\n• If two keys compress to the same array location\nwe call it a “collision”\n• minimizing such collisions is the biggest\nchallenge in designing a good hashing system\n– we cover this in Section 8.5, “Hash Functions.”\n• In our discussion of collision resolution policies,\nwe will assume\n– use of an array info to hold the information\n– the int variable location to indicate an array/hash-\ntable slot.\nCollision resolution policies\n• Linear probing: store the colliding entry into the\nnext available space:\nItem Removal\n• Complicates searching: can not terminate search\nupon finding a null entry therefore:\n– use a special\n<eos>"}
{"text": "<bos>\nvalue for a removed entry\n– use a boolean value associated with each hash table slot:\n– disallow removal\nCollision resolution policies\n• Linear probing approach can lead to inefficient\nclusters of entries\n• Quadratic probing: the value added at each\nstep is dependent on how many locations have\nalready been inspected.\n– The first time it looks for a new location it adds 1 to\nthe original location\n– the second time it adds 4 to the original location\n– the third time it adds 9 to the original location\n– and so on—the ith time it adds i2:\nComparison\nCollision resolution policies\nBuckets and Chaining\n8.5 Hash Functions\n• To get the most benefit from a hashing system\nwe need for the eventual locations used in the\nunderlying array to be as spread out as possible.\n• Two factors affect this spread\n<eos>"}
{"text": "<bos>\n– the size of the underlying array\n– the set of integral values presented to the\ncompression function\nArray Size\n• space versus time trade-off\n• hash systems will often monitor their own load—\nthe percentage of array indices being used\n• Once the load reaches a certain level, for\nexample 75%, the system is rebuilt using a\nlarger array\n• This approach is often called “rehashing”\nbecause after the array is enlarged all of the\nprevious entries have to be reinserted into the\nnew array\nThe Hash Function\n• Keys might not be integral\n• Even if integral, keys might not provide a good\n“spread”\n• So, we add another step, the hash function:\n• Synonyms for “hash code” include “hash value,”\nand sometimes we just use the word “hash.”\nCreating a hash function\n• Selecting: Identify selected parts of the\n<eos>"}
{"text": "<bos>\nkey – try\nto use parts that will provide a good variety of\nresults\n• Digitizing: the selected parts must be\ntransformed to integers\n• Combining: combine the resultant integers using\na mathematical function\nConsiderations\n• A hash code is not unique. Do not use a hash code as a\nkey.\n• If two entries are considered to be equal, then they\nshould hash to the same value.\n• When defining a hash function, consider the work\nrequired to calculate it.\n• A precise analysis of the complexity of hashing depends\non the domain and distribution of keys, the hash\nfunction, the size of the table, and the collision resolution\npolicy. In practice it is usually not difficult to achieve\nclose to O(1) efficiency using hashing.\nJava’s Support for Hashing\n• The Java Library includes a HashMap class (discussed\nin\n<eos>"}
{"text": "<bos>\nSection 8.7) and a HashSet class that use hash\ntechniques to support storing objects\n• The Java Object class exports a hashCode method\nthat returns an int hash code.\n– The standard Java hash code for an object is a function of the object’s memory\nlocation.\n• For most applications, hash codes based on memory\nlocations are not usable. Many of the Java classes that\ndefine commonly used objects (such as String and\nInteger), override the Object class’s hashCode\nmethod.\n• If you plan to use hash tables in your programs, you\nshould do likewise.\n8.6 A Hash-Based Map\nHmap.java\n• is implemented with an internal hash table that\nuses the hashCode method of the key class\n• is unbounded\n• has a default capacity of 1,000 and a default\nload factor of 75%\n• does not support the remove operation\n• is\n<eos>"}
{"text": "<bos>\nlocated in the ch08.maps package\n• is used by the VocDensMeasureHMap\napplication located in the ch08.apps package\n8.7 Map Variations\n• Some programming languages, (e.g., Awk,\nHaskell, JavaScript, Lisp, MUMPS, Perl, PHP,\nPython, and Ruby), directly support\n• Many other languages, including Java, C++,\nObjective-C, and Smalltalk provide map\nfunctionality through their standard code libraries\nMaps are known by many names:\n• Symbol table - one of the first carefully studied and\ndesigned data structures, and were related to compiler\ndesign\n• Dictionary - the idea of looking up a word (the key) in a\ndictionary to find its definition (the value) makes the\nconcept of a dictionary a good fit for maps\n• Hashes - because a hash system is a very efficient and\ncommon way to implement a map, you will\n<eos>"}
{"text": "<bos>\nsometimes\nsee the two terms used interchangeably\n• Associative Arrays - You can view a map as an array—\none that associates keys with values rather than indices\nwith values.\n<eos>"}
