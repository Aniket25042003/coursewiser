{"text": "<bos>\nChapter 9\nThe\nPriority\nQueue\nADT\nChapter 9: The\nPriority Queue ADT\n9.1 – The Priority Queue Interface\n9.2 – Priority Queue Implementations\n9.3 – The Heap\n9.4 – The Heap Implementation\n9.1 The Priority Queue Interface\n• A priority queue is an abstract data type with an\ninteresting accessing protocol - only the highest-\npriority element can be accessed\n• Priority queues are useful for any application\nthat involves processing items by priority\nThe Interface\npackage ch09.priorityQueues;\npublic interface PriQueueInterface<T>\n{\nvoid enqueue(T element);\n// Throws PriQOverflowException if this priority queue is full;\n// otherwise, adds element to this priority queue.\nT dequeue();\n// Throws PriQUnderflowException if this priority queue is empty;\n// otherwise, removes element with highest priority\n<eos>"}
{"text": "<bos>\nfrom this\n// priority queue and returns it.\nboolean isEmpty();\n// Returns true if this priority queue is empty; otherwise, returns false.\nboolean isFull();\n// Returns true if this priority queue is full; otherwise, returns false.\nint size();\n// Returns the number of elements in this priority queue. }\n9.2 Priority Queue Implementations\n• There are many ways to implement a priority queue\n– An Unsorted List - dequeuing would require searching\nthrough the entire list\n– An Array-Based Sorted List - Enqueuing is expensive\n– A Sorted Linked List - Enqueuing again is 0(N)\n– A Binary Search Tree - On average, 0(log N) steps for\n2\nboth enqueue and dequeue\n– A Heap - (next section) guarantees 0(log N) steps, even\n2\nin the worst case\n9.3 The Heap\n• Heap An implementation of a Priority Queue\nbased on a\n<eos>"}
{"text": "<bos>\ncomplete binary tree, each of whose\nelements contains a value that is greater than or\nequal to the value of each of its children\n• In other words, a heap is an implementation of a\nPriority Queue that uses a binary tree that\nsatisfies two properties\n– the shape property: the tree must be a complete\nbinary tree\n– the order property: for every node in the tree, the\nvalue stored in that node is greater than or equal to\nthe value in each of its children.\nTree Terminology\n• A full binary tree\n• A complete binary tree\nExamples\nTwo\nHeaps\nContaining\nthe Letters\n‘A’ through\n‘J’\nThe\ndequeue\noperation\nSteps d,e,f\nrepresent the\n“reheap\ndown”\noperation\nThe enqueue operation\nsteps b, c represent the “reheap up” operation\n9.4 The Heap Implementation\nA Non-linked Representation of\nBinary Trees\n• A binary\n<eos>"}
{"text": "<bos>\ntree can be stored in an array in such a way\nthat the relationships in the tree are not physically\nrepresented by link members, but are implicit in the\nalgorithms that manipulate the tree stored in the array.\n• We store the tree elements in the array, level by level,\nleft-to-right. We call the array elements and store the\nindex of the last tree element in a variable lastIndex.\n• The tree elements are stored with the root in\nelements[0] and the last node in\nelements[lastIndex].\nA Binary Tree and Its Array\nRepresentation\nA Binary Search Tree Stored in\nan Array with Dummy Values\nArray Representation continued\n• To implement the algorithms that manipulate the\ntree, we must be able to find the left and right child\nof a node in the tree:\n– elements[index] left child is in elements[index*2 + 1]\n–\n<eos>"}
{"text": "<bos>\nelements[index] right child is in elements[index*2 + 2]\n• We can also can determine the location of its parent\nnode:\n– elements[index]’s parent is in elements[(index – 1)/2].\n• This representation works best, space wise, if the\ntree is complete (which it is for a heap)\nBeginning of HeapPriQ.java\n//-------------------------------------------------------------------------\n// HeapPriQ.java by Dale/Joyce/Weems Chapter\n9 // Priority Queue using Heap (implemented with an ArrayList)\n//\n// Two constructors are provided: one that use the natural order of the\n// elements as defined by their compareTo method and one that uses an\n// ordering based on a comparator argument.\n//-------------------------------------------------------------------------\npackage ch09.priorityQueues;\nimport java.util.*; //\n<eos>"}
{"text": "<bos>\nArrayList, Comparator\npublic class HeapPriQ<T> implements PriQueueInterface<T>\n{\nprotected ArrayList<T> elements; // priority queue elements\nprotected int lastIndex; // index of last element in priority queue\nprotected int maxIndex; // index of last position in ArrayList\nprotected Comparator<T> comp;\n. . .\nThe enqueue method\npublic void enqueue(T element) throws PriQOverflowException\n// Throws PriQOverflowException if this priority queue is full;\n// otherwise, adds element to this priority queue.\n{\nif (lastIndex == maxIndex)\nthrow new PriQOverflowException(\"Priority queue is full\");\nelse\n{\nlastIndex++;\nelements.add(lastIndex, element);\nreheapUp(element);\n}\n}\nThe reheapUp algorithm is pictured on the next slide\nreheapUp operation\nprivate void reheapUp(T element)\n// Current lastIndex\n<eos>"}
{"text": "<bos>\nposition is empty.\n// Inserts element into the tree and ensures shape and order properties.\n{\nint hole = lastIndex;\nwhile ((hole > 0) // hole is not root and element > hole's parent\n&&\n(comp.compare(element, elements.get((hole - 1) / 2)) > 0))\n{\nelements.set(hole,elements.get((hole - 1) / 2)); // move hole's parent down\nhole = (hole - 1) / 2; // move hole up\n}\nelements.set(hole, element); // place element into final hole\n}\nThe dequeue method\npublic T dequeue() throws PriQUnderflowException\n// Throws PriQUnderflowException if this priority queue is empty;\n// otherwise, removes element with highest priority from this\n// priority queue and returns it.\n{\nT hold; // element to be dequeued and returned\nT toMove; // element to move down heap\nif (lastIndex == -1)\nthrow new\n<eos>"}
{"text": "<bos>\nPriQUnderflowException(\"Priority queue is empty\");\nelse\n{\nhold = elements.get(0); // remember element to be returned\ntoMove = elements.remove(lastIndex); // element to reheap down\nlastIndex--; // decrease priority queue size\nif (lastIndex != -1)\nreheapDown(toMove); // restore heap properties\nreturn hold; // return largest element\n}\n}\nThe reheapDown algorithm is pictured on the next slide\nreheapDown operation\nprivate void reheapDown(T element)\n// Current root position is \"empty\";\n// Inserts element into the tree and ensures shape and order properties.\n{\nint hole = 0; // current index of hole\nint next; // next index where hole should move to\nnext = newHole(hole, element); // find next hole\nwhile (next != hole)\n{\nelements.set(hole,elements.get(next)); // move element up\nhole = next; // move\n<eos>"}
{"text": "<bos>\nhole down\nnext = newHole(hole, element); // find next hole\n}\nelements.set(hole, element); // fill in the final hole\n}\nprivate int newHole(int hole, T element)\n// If either child of hole is larger than element return the index\n// of the larger child; otherwise return the index of hole.\n{\nThe\nint left = (hole * 2) + 1;\nint right = (hole * 2) + 2;\nif (left > lastIndex)\nnewHole\n// hole has no children\nreturn hole;\nelse\nif (left == lastIndex) method\n// hole has left child only\nif (comp.compare(element, elements.get(left)) < 0)\n// element < left child\nreturn left;\nelse\n// element >= left child\nreturn hole;\nelse\n// hole has two children\nif (comp.compare(elements.get(left), elements.get(right)) < 0)\n// left child < right child\nif (comp.compare(elements.get(right), element) <= 0)\n// right child <=\n<eos>"}
{"text": "<bos>\nelement\nreturn hole;\nelse\n// element < right child\nreturn right;\nelse\n// left child >= right child\nif (comp.compare(elements.get(left), element) <= 0)\n// left child <= element\nreturn hole;\nelse\n// element < left child\nreturn left;\n}\nHeaps Versus Other\nRepresentations of Priority\nQueues\n<eos>"}
